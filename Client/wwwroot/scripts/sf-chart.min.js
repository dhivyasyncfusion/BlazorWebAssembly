(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-chart"],{

/***/ "./bundles/sf-chart.js":
/*!*****************************!*\
  !*** ./bundles/sf-chart.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-chart.js */ "./modules/sf-chart.js");
/* harmony import */ var _modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_chart_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-chart.js":
/*!*****************************!*\
  !*** ./modules/sf-chart.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Chart = function () {
  'use strict';

  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return _extendStatics(d, b);
    };
    return function (d, b) {
      _extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  /* eslint-disable no-case-declarations */
  /* eslint-disable camelcase */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Chart native blazor source file
   */
  var SfChart = /** @class */function () {
    function SfChart(dataId, id, element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions) {
      if (isZooming === void 0) {
        isZooming = false;
      }
      if (isScrollbar === void 0) {
        isScrollbar = false;
      }
      window.sfBlazor = window.sfBlazor;
      this.mouseY = 0;
      this.mouseX = 0;
      this.isTouch = false;
      this.eventInterval = 80;
      this.mouseMoveRef = null;
      this.mouseMoveThreshold = null;
      this.chartOnMouseClickRef = null;
      this.chartRightClickRef = null;
      this.mouseLeaveRef = null;
      this.chartKeyDownRef = null;
      this.chartKeyUpRef = null;
      this.chartMouseWheelRef = null;
      this.chartOnMouseDownRef = null;
      this.mouseEndRef = null;
      this.chartMouseWheelThreshold = null;
      this.domMouseMoveRef = null;
      this.domMouseMoveThreshold = null;
      this.scrollbarMouseMoveThreshold = null;
      this.scrollbarMouseWheelThreshold = null;
      this.domMouseUpRef = null;
      this.longPressBound = null;
      this.touchObject = null;
      //values to be passed
      this.pinchZoomingEnable = false;
      this.crosshairEnable = false;
      this.toggleVisibility = true;
      this.enableHighlight = true;
      this.highlightMode = 'None';
      this.selectionMode = 'None';
      this.rectSeries = true;
      this.isSeriesMode = false;
      this.seriesTypes = [];
      this.redraw = false;
      this.selectedDataIndexes = [];
      this.highlightDataIndexes = [];
      this.previousSelectedEle = [];
      this.highlightColor = '';
      this.highlightPattern = 'None';
      this.selectionPattern = 'None';
      this.legendModule = [];
      this.allowMultiSelection = false;
      this.drawType = [];
      this.previousHighlightedIndex = -1;
      this.tooltipBase = new ITooltipBase();
      this.markerExplodeBase = new IMarkerExplodeBase();
      this.crosshairBase = new ICrosshairBase();
      this.userInteractionBase = new IUserInteractionBase();
      this.zoomBase = new IZoomBase();
      this.zoomToolkitBase = new IZoomToolkitBase();
      this.isChartPanning = false;
      this.axes = [];
      this.scrollDownRef = null;
      this.wheelEventEndTimeout = null;
      this.isWheelScrolling = false;
      this.isChartZoom = false;
      this.isDisposed = false;
      this.pinchStyle = 'opacity: 0; position: absolute; display: block; width: 100px; height: 100px; background: transparent; border: 2px solid blue;';
      this.pinchtarget = null;
      this.documentKeyHandler = function (e) {
        // 74 - J
        if (e.altKey && e.keyCode === 74 && !sf.base.isNullOrUndefined(this.element)) {
          this.element.focus();
        }
      };
      this.id = id;
      this.element = element;
      //this.scrollElement = element;
      this.dotnetref = dotnetRef;
      this.isZooming = isZooming;
      this.isScrollbar = isScrollbar;
      this.options = options;
      this.currentLegendIndex = 0;
      this.currentPointIndex = 0;
      this.currentSeriesIndex = 0;
      this.currentAnnotationIndex = 0;
      this.previousTargetId = "";
      this.isZoomed = false;
      this.selectionHighlightOptions(selectionHighlightOptions);
      this.selectedDataIndexes = selectionHighlightOptions.selectedDataIndexes || [];
      this.unSelected = id + "_ej2_deselected";
      this.dataId = dataId;
      window.sfBlazor.setCompInstance(this);
      this.isDisposed = false;
      this.getTooltipData();
      this.userInteractionBase.svgRenderer = new sf.svgbase.SvgRenderer(this.element.id);
      //this.scrollbarBase = {} as IScrollbarBase;
      //this.scrollbarBase.svgRenderer = new SvgRenderer(this.element.id);
      this.removeTooltipData();
    }
    SfChart.prototype.render = function () {
      this.unWireEvents(this.id, this.dotnetref);
      this.wireEvents(this.id, this.dotnetref);
    };
    SfChart.prototype.destroy = function () {
      this.isDisposed = true;
      this.unWireEvents(this.id, this.dotnetref);
      this.dotnetref.invokeMethodAsync("DisposeDotNetReference");
    };
    SfChart.prototype.selectionHighlightOptions = function (options) {
      this.enableHighlight = options.enableHighlight;
      this.pinchZoomingEnable = options.pinchZoomingEnable;
      this.toggleVisibility = options.toggleVisibility;
      this.highlightMode = options.highlightMode;
      this.selectionMode = options.selectionMode;
      this.seriesTypes = options.seriesTypes;
      this.highlightColor = options.highlightColor;
      this.highlightPattern = options.highlightPattern;
      this.selectionPattern = options.selectionPattern;
      this.allowMultiSelection = options.allowMultiSelection;
      this.drawType = options.drawType;
      this.oldMode = this.currentMode;
    };
    SfChart.prototype.getTooltipData = function (clipRects, seriesMarkers, seriesBorders, axes) {
      var element = document.getElementById(this.element.id + "_tooltip_data");
      if (element) {
        this.userInteractionBase.chartData = element.getAttributeNames().map(function (name) {
          return element.getAttribute(name);
        });
        this.userInteractionBase.chartData.shift();
        var index = this.userInteractionBase.chartData.indexOf("display: block;");
        if (index > -1) {
          this.userInteractionBase.chartData.splice(index, 1);
        }
        if (this.userInteractionBase.isStockChart) {
          var indexValue = this.userInteractionBase.chartData.indexOf("");
          while (indexValue > -1) {
            this.userInteractionBase.chartData.splice(indexValue, 1);
            indexValue = this.userInteractionBase.chartData.indexOf("");
          }
        }
        if (!sf.base.isNullOrUndefined(this.userInteractionBase.visibleSeries)) {
          this.userInteractionBase.visibleSeries.forEach(function (series) {
            series.visible = document.getElementById(series.id) ? true : false;
          });
        }
        if (this.userInteractionBase.chartData.length > 0 && clipRects && seriesMarkers && seriesBorders && axes) {
          this.getVisibleSeries(this, clipRects, seriesMarkers, seriesBorders, axes);
          this.isDataLoaded = true;
        }
        if (sf.base.isNullOrUndefined(this.tooltipBase.tooltipElementSize) && this.tooltipBase.tooltipModule && this.tooltipBase.tooltipModule.template) {
          this.getElementSize(this.element.id + '_tooltip');
        }
      }
    };
    SfChart.prototype.removeTooltipData = function () {
      var element = document.getElementById(this.element.id + "_tooltip_data");
      if (element && element.getAttributeNames().length > 1) {
        this.dotnetref.invokeMethodAsync('RemoveTooltipData');
      }
    };
    SfChart.prototype.tooltipOptions = function (tooltip, options) {
      this.userInteractionBase.availableSize = options.availableSize;
      this.userInteractionBase.chartBorderWidth = options.borderWidth;
      this.userInteractionBase.disableTrackTooltip = options.disableTrackTooltip;
      this.userInteractionBase.axisClipRect = options.axisClipRect;
      this.userInteractionBase.isPointMouseDown = options.isPointMouseDown;
      this.userInteractionBase.isPointDragging = options.isPointDragging;
      this.userInteractionBase.isInverted = options.isInverted;
      this.userInteractionBase.chartAreaType = options.chartAreaType;
      this.tooltipBase.isTooltipMarker = options.isMarkerEnable;
      this.tooltipBase.tooltipModule = tooltip;
      this.tooltipBase.tooltipFormat = !sf.base.isNullOrUndefined(options.tooltipFormat) ? this.getTooltipFormat(options.tooltipFormat) : options.tooltipFormat;
      this.userInteractionBase.enableRTL = options.enableRTL;
      this.crosshairBase.crosshair = options.crosshair;
      this.crosshairEnable = options.crosshair.enable;
      this.markerExplodeBase.markerExploded = options.markerExplode;
      this.userInteractionBase.chartRadius = options.chartRadius;
      this.userInteractionBase.theme = options.theme;
      this.crosshairBase.themeStyleCrosshairLine = options.themeStyleCrosshairLine;
      this.crosshairBase.themeStyleCrosshairFill = options.themeStyleCrosshairFill;
      this.crosshairBase.themeStyleCrosshairLabel = options.themeStyleCrosshairLabel;
      this.crosshairBase.themeStyleCrosshairTextSize = options.themeStyleCrosshairTextSize;
      this.crosshairBase.themeStyleCrosshairFontFamily = options.themeStyleCrosshairFontFamily;
      this.crosshairBase.themeStyleCrosshairFontWeight = options.themeStyleCrosshairFontWeight;
      this.tooltipBase.tooltipModule.template = options.templateString ? options.templateString : this.tooltipBase.tooltipModule.template;
      this.userInteractionBase.initialRect = options.initialRect;
      this.userInteractionBase.secondaryElementOffset = options.secondaryElementOffset;
      if (sf.base.isNullOrUndefined(this.tooltipBase.tooltipElementSize) && this.tooltipBase.tooltipModule.template) {
        this.getElementSize(this.element.id + '_tooltip');
      }
      this.userInteractionBase.isStockChart = this.element.id.indexOf('_stockChart') > -1;
      this.tooltipBase.tooltipEventCalled = options.tooltipEventCalled;
      this.tooltipBase.sharedTooltipEventCalled = options.sharedTooltipEventCalled;
      this.tooltipBase.crosshairMouseMoveEventCalled = options.crosshairMouseMoveEventCalled;
      this.tooltipBase.seriesTooltipTop = options.seriesTooltipTop;
      this.userInteractionBase.useGrouping = options.useGrouping;
      this.tooltipBase.tooltipDuration = this.tooltipBase.tooltipModule.duration != 0 ? this.tooltipBase.tooltipModule.duration : this.tooltipBase.tooltipModule.shared ? 100 : 300;
      if (this.crosshairEnable) {
        this.togglePointerEvents(this.element.id, false);
      } else if (this.pinchZoomingEnable) {
        this.togglePointerEvents(this.element.id, true);
      }
    };
    SfChart.prototype.getElementSize = function (id) {
      var element = document.getElementById(id);
      if (element && element.childNodes.length === 0) {
        element.appendChild(document.getElementById('tooltip_template'));
        this.tooltipBase.tooltipElementSize = {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
        element.removeChild(element.firstChild);
      }
    };
    SfChart.prototype.clipPathID = function (index) {
      return this.element.id + '_ChartSeriesClipRect_' + index;
    };
    SfChart.prototype.markerClipPathId = function (index) {
      return this.element.id + '_ChartMarkerClipRect_' + index;
    };
    SfChart.prototype.getVisibleSeries = function (charts, clipRects, seriesMarkers, seriesBorders, axes) {
      charts.userInteractionBase.visibleSeries = [];
      charts.userInteractionBase.axes = axes;
      var seriesCollection = document.getElementById(charts.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");
      var indicatorCollection = document.getElementById(charts.element.id + "IndicatorCollection").querySelectorAll("[id*='_Group']");
      var trendlineCollection = document.getElementById(charts.element.id + "TrendLineCollection").querySelectorAll("[id*='TrendlineSeriesGroup']");
      var allSeries = [];
      if (seriesCollection.length > 0) {
        seriesCollection.forEach(function (item) {
          allSeries.push(item);
        });
      }
      if (indicatorCollection.length > 0) {
        indicatorCollection.forEach(function (item) {
          allSeries.push(item);
        });
      }
      if (trendlineCollection.length > 0) {
        trendlineCollection.forEach(function (item) {
          allSeries.push(item);
        });
      }
      var _loop_1 = function _loop_1(i) {
        var elementId = allSeries[i].id;
        var element = document.getElementById(elementId);
        var dataPoints = !sf.base.isNullOrUndefined(element) ? element.getAttribute('data-point').split(',') : null;
        series = {
          id: elementId,
          name: dataPoints[15],
          index: parseInt(dataPoints[4]),
          interior: dataPoints[2],
          visible: dataPoints[8] === 'True',
          category: dataPoints[10],
          seriesType: dataPoints[11],
          type: dataPoints[3],
          drawType: dataPoints[12],
          marker: seriesMarkers[i],
          border: seriesBorders[i],
          shape: dataPoints[13],
          points: !sf.base.isNullOrUndefined(this_1.userInteractionBase.chartData[i]) && this_1.userInteractionBase.chartData[i] != "" ? JSON.parse(charts.userInteractionBase.chartData[i]) : [],
          clipRect: clipRects[i],
          tooltipFormat: dataPoints[14] !== "" ? this_1.getTooltipFormat(dataPoints[14]) : dataPoints[14],
          enableTooltip: dataPoints[16] === "True",
          dataEditSettings: dataPoints[17] === "True",
          chartIsTransposed: dataPoints[18] === "True",
          opacity: parseFloat(dataPoints[19]),
          x_Axis: this_1.userInteractionBase.axes.filter(function (axis) {
            return axis.name === dataPoints[20];
          })[0],
          y_Axis: this_1.userInteractionBase.axes.filter(function (axis) {
            return axis.name === dataPoints[21];
          })[0],
          axesCount: this_1.userInteractionBase.axes.length,
          volume: dataPoints[22],
          markerDataLabelFormat: dataPoints[23],
          xMin: parseInt(dataPoints[24]),
          xMax: parseInt(dataPoints[25])
        };
        charts.userInteractionBase.visibleSeries.push(series);
      };
      var this_1 = this,
        series;
      for (var i = 0; i < allSeries.length; i++) {
        _loop_1(i);
      }
    };
    SfChart.prototype.getTooltipFormat = function (text) {
      text = text.replace('tooltip', 'tT').replace('text', 't').replace('high', 'h').replace('low', 'l').replace('open', 'o').replace('close', 'c').replace('volume', 'v').replace('size', 'sI').replace('percentage', 'p').replace('minimum', 'mI').replace('maximum', 'mX').replace('outliers', 'oL').replace('upperQuartile', 'uQ').replace('lowerQuartile', 'lQ').replace('median', 'm').replace('average', 'a');
      return text;
    };
    SfChart.prototype.calculateSecondaryOffset = function (id) {
      var svgRect = document.getElementById(id.replace('_stockChart_chart', '') + '_svg').getBoundingClientRect();
      var rect = document.getElementById(id).getBoundingClientRect();
      if (!this.userInteractionBase.secondaryElementOffset) {
        return;
      }
      this.userInteractionBase.secondaryElementOffset.left = Math.max(svgRect.left - rect.left, 0);
      this.userInteractionBase.secondaryElementOffset.top = Math.max(svgRect.top - rect.top, 0);
    };
    SfChart.prototype.unWireEvents = function (id, dotnetref) {
      var element = document.getElementById(id);
      if (!element) {
        return;
      }
      this.dotnetref = dotnetref;
      Chart.dotnetrefCollection = Chart.dotnetrefCollection.filter(function (item) {
        return item.id !== id;
      });
      /*! Find the Events type */
      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      /*! Bind the Event handler */
      element.removeEventListener('mousemove', this.mouseMoveRef);
      element.removeEventListener('touchmove', this.mouseMoveRef);
      sf.base.EventHandler.remove(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
      sf.base.EventHandler.remove(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
      sf.base.EventHandler.remove(element, 'click', this.chartOnMouseClickRef);
      sf.base.EventHandler.remove(element, 'contextmenu', this.chartRightClickRef);
      sf.base.EventHandler.remove(element, cancelEvent, this.mouseLeaveRef);
      sf.base.EventHandler.remove(element, 'keydown', this.chartKeyDownRef);
      sf.base.EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
      sf.base.EventHandler.remove(element, 'keyup', this.chartKeyUpRef);
      if (this.isZooming || this.isScrollbar) {
        var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';
        element.removeEventListener(wheelEvent, this.chartMouseWheelRef);
      }
      if (this.isScrollbar) {
        window.removeEventListener('mousedown', this.scrollDownRef);
        window.removeEventListener('touchstart', this.scrollDownRef);
        window.removeEventListener('mousemove', this.domMouseMoveRef);
        window.removeEventListener('touchmove', this.domMouseMoveRef);
        window.removeEventListener('mouseup', this.domMouseUpRef, false);
        window.removeEventListener('touchend', this.domMouseUpRef, false);
      }
      if (document.getElementsByClassName('e-chart').length == 0) {
        var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
        sf.base.EventHandler.remove(window, resize, Chart.resizeBound);
      }
      if (this.touchObject) {
        this.touchObject.destroy();
        this.touchObject = null;
      }
      /*! Apply the style for chart */
    };
    SfChart.prototype.wireEvents = function (id, dotnetref) {
      var element = document.getElementById(id);
      if (!element) {
        return;
      }
      this.dotnetref = dotnetref;
      Chart.dotnetrefCollection.push({
        id: id,
        dotnetref: dotnetref
      });
      /*! Find the Events type */
      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      this.chartOnMouseDownRef = this.chartOnMouseDown.bind(this, dotnetref, id);
      this.mouseEndRef = this.mouseEnd.bind(this, dotnetref, id);
      this.mouseMoveRef = this.mouseMove.bind(this, dotnetref, id);
      this.chartOnMouseClickRef = this.chartOnMouseClick.bind(this, dotnetref, id);
      this.chartRightClickRef = this.chartRightClick.bind(this, dotnetref, id);
      this.chartKeyDownRef = this.chartOnKeyDown.bind(this, this.dotnetref, this.id);
      this.chartKeyUpRef = this.chartOnKeyUp.bind(this, this.dotnetref, this.id);
      this.mouseLeaveRef = this.mouseLeave.bind(this, dotnetref, id);
      /*! Bind the Event handler */
      element.addEventListener('mousemove', this.mouseMoveRef);
      element.addEventListener('touchmove', this.mouseMoveRef);
      sf.base.EventHandler.add(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
      sf.base.EventHandler.add(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
      sf.base.EventHandler.add(element, 'click', this.chartOnMouseClickRef);
      sf.base.EventHandler.add(element, 'contextmenu', this.chartRightClickRef);
      sf.base.EventHandler.add(element, cancelEvent, this.mouseLeaveRef);
      sf.base.EventHandler.add(element, "keydown", this.chartKeyDownRef);
      sf.base.EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
      sf.base.EventHandler.add(element, "keyup", this.chartKeyUpRef);
      if (this.isZooming || this.isScrollbar) {
        this.chartMouseWheelRef = this.chartMouseWheel.bind(this, dotnetref, id);
        var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';
        element.addEventListener(wheelEvent, this.chartMouseWheelRef);
      }
      if (this.isScrollbar) {
        this.scrollDownRef = this.scrollDown.bind(this, dotnetref, id);
        this.domMouseMoveRef = this.domMouseMove.bind(this, dotnetref, id);
        this.domMouseUpRef = this.domMouseUp.bind(this, dotnetref, id);
        window.addEventListener('mousedown', this.scrollDownRef);
        window.addEventListener('touchstart', this.scrollDownRef);
        window.addEventListener('mousemove', this.domMouseMoveRef);
        window.addEventListener('touchmove', this.domMouseMoveRef);
        window.addEventListener('mouseup', this.domMouseUpRef, false);
        window.addEventListener('touchend', this.domMouseUpRef, false);
      }
      Chart.resizeBound = Chart.chartResize.bind(this, Chart.dotnetrefCollection);
      var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
      sf.base.EventHandler.add(window, resize, Chart.resizeBound);
      this.longPressBound = this.longPress.bind(this, dotnetref, id);
      this.touchObject = new sf.base.Touch(element, {
        tapHold: this.longPressBound,
        tapHoldThreshold: 500
      });
      /*! Apply the style for chart */
    };
    SfChart.prototype.getEventArgs = function (e, id) {
      var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
      this.setMouseXY(clientX, clientY, id);
      var touches = e.touches;
      var touchList = [];
      if (e.type.indexOf('touch') > -1) {
        for (var i = 0, length_1 = touches.length; i < length_1; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: e.pointerId || 0
          });
        }
      }
      return {
        type: e.type,
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        pointerType: e.pointerType,
        target: e.target.id,
        changedTouches: {
          clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
          clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
        },
        touches: touchList,
        pointerId: e.pointerId
      };
    };
    SfChart.prototype.getWheelArgs = function (e, id) {
      this.setMouseXY(e.clientX, e.clientY, id);
      return {
        detail: e.detail,
        wheelDelta: e['wheelDelta'],
        target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        browserName: sf.base.Browser.info.name,
        isPointer: sf.base.Browser.isPointer
      };
    };
    SfChart.prototype.setMouseXY = function (pageX, pageY, id) {
      var svgRect = document.getElementById(id.replace('_stockChart_chart', '') + '_svg').getBoundingClientRect();
      var rect = document.getElementById(id).getBoundingClientRect();
      if (!this.userInteractionBase.secondaryElementOffset) {
        return;
      }
      this.userInteractionBase.secondaryElementOffset.left = Math.max(svgRect.left - (this.userInteractionBase.isStockChart ? document.getElementById(id.replace('_stockChart_chart', '')).getBoundingClientRect().left : rect.left), 0);
      this.userInteractionBase.secondaryElementOffset.top = Math.max(svgRect.top - rect.top, 0);
      this.mouseY = pageY - rect.top - this.userInteractionBase.secondaryElementOffset.top;
      this.mouseX = pageX - rect.left - this.userInteractionBase.secondaryElementOffset.left;
    };
    SfChart.prototype.chartOnMouseDown = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var target = e.target;
      var chart = window.sfBlazor.getCompInstance(this.dataId);
      if (target.id.indexOf('legend') > 0) {
        chart.previousHighlightedIndex = -1;
      }
      var pageX;
      var pageY;
      var touchArg;
      if (e.type === 'touchstart') {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.setMouseXY(pageX, pageY, id);
      if (e.type.indexOf('touch') > -1) {
        var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        var isMultiTouch = e.touches.length > 1;
        if (chart.pinchZoomingEnable) {
          this.pinchtarget = document.getElementById(id + '_Pinch_target');
          this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (clientY - 50) + 'px; left: ' + (clientX - 50) + 'px;');
          this.togglePointerEvents(id, chart.crosshairEnable && chart.userInteractionBase.startMove ? isMultiTouch : true);
          e.preventDefault();
          if (sf.base.Browser.info.name.toLowerCase() !== 'mozilla' && isMultiTouch) {
            e.stopImmediatePropagation();
          }
        } else if (chart.crosshairEnable && chart.userInteractionBase.startMove) {
          this.togglePointerEvents(id, false);
          e.preventDefault();
        }
      }
      if (this.zoomBase.zoomingModule) {
        Chart.removeTooltipCrosshair();
        if (target.id.indexOf('_Zooming_') > -1) {
          Chart.zoomToolkitMouseDown(this, target);
        }
        if (!(target.id.indexOf('_Zooming_') > -1 || target.id.indexOf('_scrollBar_') > -1)) {
          Chart.onZoomingMouseDown(this.getEventArgs(e, id), this);
        }
      }
      if (this.userInteractionBase.isStockChart && chart.zoomBase.zoomSettings.enablePan) {
        if (chart.userInteractionBase.axes[0].valueType === "Logarithmic") {
          document.getElementById(this.element.id).setAttribute('cursor', 'not-allowed');
        } else {
          document.getElementById(this.element.id).setAttribute('cursor', 'pointer');
        }
      }
      dotnetref.invokeMethodAsync('OnZoomingMouseDown', this.getEventArgs(e, id));
      return false;
    };
    SfChart.prototype.togglePointerEvents = function (id, stopPointerEvents) {
      if (stopPointerEvents) {
        this.setPointerEvents(id, "none");
      } else {
        this.setPointerEvents(id, "auto");
      }
    };
    SfChart.prototype.setPointerEvents = function (id, pointEventStyle) {
      var chartRectStyle = document.getElementById(id + "_sfchart_rect_style");
      chartRectStyle.innerHTML = '#' + id + '_ChartAreaBorder, #' + id + '_ChartBorder {' + 'pointer-events: ' + pointEventStyle + '; }';
    };
    SfChart.prototype.chartMouseWheel = function (dotnetref, id, e) {
      var _this = this;
      this.dotnetref = dotnetref;
      if (this.zoomBase.zoomingModule || this.isScrollbar) {
        Chart.removeTooltipCrosshair();
        Chart.zoomingMouseWheelHandler(e, this);
      }
      dotnetref.invokeMethodAsync('OnChartMouseWheel', this.getWheelArgs(e, id));
      if (this.wheelEventEndTimeout) {
        clearTimeout(this.wheelEventEndTimeout);
      }
      this.wheelEventEndTimeout = setTimeout(function () {
        dotnetref.invokeMethodAsync('UpdateChartData');
        _this.isWheelScrolling = false;
      }, 100);
      e.preventDefault();
      return false;
    };
    SfChart.prototype.mouseMove = function (dotnetref, id, e, isNavigation) {
      if (isNavigation === void 0) {
        isNavigation = false;
      }
      var target = e.target;
      if (!sf.base.isNullOrUndefined(document.getElementById(target.id))) {
        if (this.highlightMode !== 'None' || this.enableHighlight) {
          if (!sf.base.isNullOrUndefined(target) || target.id.indexOf('Point') > -1 || target.id.indexOf('Symbol') > -1) {
            if (target.id.indexOf('text') > -1) {
              target = Chart.findDOMElement(target.id.replace('text', 'shape'));
            } else {
              target = Chart.findDOMElement(target.id);
            }
            if (!sf.base.isNullOrUndefined(target) && target.hasAttribute('class') && (target.getAttribute('class').indexOf('highlight') > -1 || target.getAttribute('class').indexOf('selection') > -1)) {
              return;
            }
          }
          if (this.highlightMode !== 'None') {
            Chart.calculateSelectedElements(e, this.dataId);
          }
          var currentIndex = void 0;
          var values = [this.id + "_chart_legend_text_", this.id + "_chart_legend_shape_marker_", this.id + "_chart_legend_shape_", this.id + "_chart_legend_g_"];
          for (var i = 0; i < values.length; i++) {
            if (!sf.base.isNullOrUndefined(target) && !target.id.indexOf(values[i])) {
              currentIndex = parseInt(target.id.split(values[i])[1]);
              break;
            }
          }
          var chart = window.sfBlazor.getCompInstance(this.dataId);
          if (!sf.base.isNullOrUndefined(target) && target.id.indexOf('legend') > 0 && (Chart.isTargetChanged(currentIndex, chart) || this.highlightMode !== 'None') && !sf.base.Browser.isDevice) {
            this.legendVisible = true;
            Chart.legendSelection(e, chart.dataId);
          }
          if (!sf.base.isNullOrUndefined(target) && !(target.id.indexOf('legend') > 0)) {
            Chart.resetPreviousHighlightIndex(chart);
          }
          if (!sf.base.isNullOrUndefined(target) && this.highlightMode == 'None' && !(target.id.indexOf('legend') > 0) && chart.highlightDataIndexes.length > 0) {
            Chart.removeSelectionStyles(this.dataId);
          }
        }
      }
      if (isNavigation) {
        return;
      }
      var pageX;
      var pageY;
      var touchArg;
      if (e.type === 'touchmove') {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
        var chart = window.sfBlazor.getCompInstance(this.dataId);
        if (this.pinchtarget && chart.pinchZoomingEnable) {
          this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (pageY - 50) + 'px; left: ' + (pageX - 50) + 'px;');
          e.preventDefault();
        }
        if (chart.crosshairBase.crosshair.enable && chart.userInteractionBase.startMove) {
          e.preventDefault();
        }
      } else {
        this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
        pageX = e.clientX;
        pageY = e.clientY;
      }
      this.dotnetref = dotnetref;
      if (document.getElementById(id.replace('_stockChart_chart', '') + '_svg')) {
        this.setMouseXY(pageX, pageY, id);
        if (this.userInteractionBase.chartStartMove && !(!this.isTouch && this.isChartZoom)) {
          if (this.tooltipBase.tooltipModule != null) {
            Chart.tooltipMousemovehandler(this);
          }
          if (this.markerExplodeBase.markerExploded) {
            Chart.markerMove(this, false);
          }
          if (this.crosshairBase.crosshair && this.crosshairBase.crosshair.enable) {
            Chart.crosshairMousemoveHandler(this);
          }
        }
        if (!this.isTouch) {
          if (!sf.base.isNullOrUndefined(target) && target.id.indexOf('_Zooming_') > -1) {
            Chart.zoomToolkitTooltip(this, target.id, e);
          } else {
            Chart.zoomToolkitRemoveTooltip(this);
          }
        }
        if (this.zoomBase.zoomingModule) {
          Chart.onZoomingMouseMove(this.getEventArgs(e, id), this);
        }
        dotnetref.invokeMethodAsync('OnZoomingMouseMove', this.getEventArgs(e, id));
        this.isTouch = false;
      }
    };
    SfChart.prototype.mouseEnd = function (dotnetref, id, e) {
      var _this = this;
      this.dotnetref = dotnetref;
      var pageX;
      var pageY;
      var touchArg = e.type === 'touchmove' ? e : null;
      pageX = e.type === 'touchmove' ? touchArg.changedTouches[0].clientX : e.clientX;
      pageY = e.type === 'touchmove' ? touchArg.changedTouches[0].clientY : e.clientY;
      this.isTouch = e.type.indexOf('touch') > -1 ? true : e.pointerType === 'touch' || e.pointerType === '2';
      if (document.getElementById(id.replace('_stockChart_chart', '') + '_svg')) {
        this.setMouseXY(pageX, pageY, id);
        if (this.isTouch) {
          if (this.tooltipBase.tooltipModule.enable && !this.crosshairBase.crosshair.enable && !Chart.isSelected() && sf.svgbase.withInAreaBounds(this.mouseX, this.mouseY, this.userInteractionBase.axisClipRect) && this.tooltipBase.tooltipModule.shared || this.tooltipBase.tooltipModule.shared) {
            Chart.tooltip(this);
            if (this.markerExplodeBase.markerExploded) {
              Chart.markerMove(this, false);
            }
          }
          if (this.clearTooltip) {
            clearTimeout(this.clearTooltip);
          }
          this.clearTooltip = setTimeout(function () {
            Chart.removeTooltip(300, _this);
          }, 1000);
          Chart.removeMarker(this);
        }
        if (this.userInteractionBase.startMove) {
          Chart.removeCrosshair(this, 2000);
          this.userInteractionBase.startMove = false;
        }
        var chart = window.sfBlazor.getCompInstance(this.dataId);
        if (this.highlightMode == 'None' && chart.highlightDataIndexes.length > 0) {
          Chart.removeSelectionStyles(this.dataId);
        }
      }
      if (e.type == 'touchend') {
        if (this.pinchZoomingEnable) {
          var isMultiTouch = e.touches.length > 0;
          this.togglePointerEvents(id, this.crosshairEnable ? isMultiTouch : true);
        } else {
          this.togglePointerEvents(id, false);
        }
      }
      if (this.zoomBase.zoomingModule) {
        this.zoomBase.threshold = new Date().getTime() + 300;
        Chart.onZoomingMouseEnd(this.getEventArgs(e, id), this);
      }
      dotnetref.invokeMethodAsync('OnZoomingMouseEnd', this.getEventArgs(e, id));
      this.isTouch = false;
      return false;
    };
    SfChart.prototype.chartOnMouseClick = function (dotnetref, id, e) {
      Chart.calculateSelectedElements(e, this.dataId);
      var target = e.target;
      var chart = window.sfBlazor.getCompInstance(this.dataId);
      if (target.id.indexOf('legend') > 0 && !chart.toggleVisibility) {
        this.legendVisible = true;
        Chart.legendSelection(e, chart.dataId);
      }
    };
    SfChart.prototype.chartRightClick = function (dotnetref, id, event) {
      this.dotnetref = dotnetref;
      var chart = window.sfBlazor.getCompInstance(this.dataId);
      if (chart.crosshairBase.crosshair.enable && (event.buttons === 2 || event.pointerType === 'touch')) {
        event.preventDefault();
        event.stopPropagation();
      }
      dotnetref.invokeMethodAsync('OnChartMouseRightClick', this.getEventArgs(event, id));
      return false;
    };
    SfChart.prototype.chartOnKeyDown = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var actionKey = "";
      var target = e.target;
      if (this.isZoomed && e.code == "Tab" || e.code == "Space") {
        e.preventDefault();
      }
      if (this.options.showTooltip && (e.code == "Tab" && this.previousTargetId.indexOf("Series") > -1 || e.code === "Escape")) {
        actionKey = "ESC";
      }
      if (e.ctrlKey && (e.key === '+' || e.code === 'Equal' || e.key === '-' || e.code === 'Minus')) {
        e.preventDefault();
        this.isZoomed = this.options.enableZoom;
        Chart.fadeOut(this.element);
        actionKey = this.isZoomed ? e.code : "";
      } else if (e["keyCode"] === 82 && this.isZoomed) {
        // KeyCode 82 (R) for reseting
        e.preventDefault();
        this.isZoomed = false;
        actionKey = "R";
      } else if (e.code.indexOf("Arrow") > -1) {
        e.preventDefault();
        actionKey = this.isZoomed ? e.code : "";
      }
      if (e.ctrlKey && e.key === 'p') {
        e.preventDefault();
        actionKey = "CtrlP";
      }
      if (actionKey != "") {
        if (this.zoomBase.zoomingModule) {
          if (actionKey == 'Equal' || actionKey == 'Minus') {
            this.zoomBase.zoomingModule.isZoomed = this.zoomBase.zoomingModule.performedUI = true;
            this.zoomBase.zoomingModule.isPanning = this.zoomBase.isChartDrag = false;
            if (actionKey == 'Equal') {
              Chart.zoomToolkitZoomIn(this, target.getAttribute('opacity'));
            } else {
              Chart.zoomToolkitZoomOut(this, target.getAttribute('opacity'));
            }
            Chart.performZoomRedraw(this, true);
          }
          if (actionKey == 'ArrowUp' || actionKey == 'ArrowDown' || actionKey == 'ArrowLeft' || actionKey == 'ArrowRight') {
            var yArrowPadding = actionKey == 'ArrowUp' ? 10 : actionKey == 'ArrowDown' ? -10 : 0;
            var xArrowPadding = actionKey == 'ArrowLeft' ? -10 : actionKey == 'ArrowRight' ? 10 : 0;
            this.zoomBase.zoomingModule.isPanning = this.zoomBase.isChartDrag = true;
            Chart.doPan(this, this.zoomBase.axisCollections, xArrowPadding, yArrowPadding);
            Chart.performZoomRedraw(this, true);
          }
          if (actionKey == 'R') {
            Chart.zoomToolkitReset(this);
          }
        }
        dotnetref.invokeMethodAsync("OnChartKeyboardNavigations", actionKey, e.target['id']);
      }
      return false;
    };
    SfChart.prototype.processPointSelection = function (dotnetref, chartId, targetId, actionKey) {
      var chartElement = document.getElementById(chartId);
      if (sf.base.isNullOrUndefined(chartElement)) {
        return;
      }
      if (actionKey === "Enter") {
        this.chartOnMouseClick(dotnetref, chartId, {
          target: document.getElementById(targetId),
          type: 'click'
        });
      } else if (actionKey === "Tab" || actionKey === "ArrowMove") {
        this.mouseMove(dotnetref, chartId, {
          target: document.getElementById(targetId),
          type: 'mousemove'
        }, true);
      }
    };
    SfChart.prototype.chartOnKeyUp = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var actionKey = "";
      var target = e.target;
      var targetId = e.target['id'];
      var groupElement;
      var markerGroup;
      var targetElement = e.target;
      var titleElement = Chart.getElement(this.element.id + "_ChartTitle");
      var seriesElement = Chart.getElement(this.element.id + "SeriesCollection");
      var legendElement = Chart.getElement(this.element.id + "_chart_legend_translate_g");
      var pagingElement = Chart.getElement(this.element.id + "_chart_legend_pageup");
      var annotationElement = Chart.getElement(this.element.id + "_Annotation_Collections");
      var zoomInElement = Chart.getElement(this.element.id + "_Zooming_ZoomIn");
      var zoomOutElement = Chart.getElement(this.element.id + "_Zooming_ZoomOut");
      var resetElement = Chart.getElement(this.element.id + "_Zooming_Reset");
      if (!this.isZoomed && e.keyCode !== 82) {
        if (titleElement) {
          titleElement.setAttribute("class", "e-chart-focused");
        }
        if (seriesElement && seriesElement.firstElementChild) {
          var firstChild = seriesElement.firstElementChild.children[1];
          if (firstChild) {
            var className = firstChild.getAttribute("class");
            if (className && className.indexOf("e-chart-focused") === -1) {
              className = className + " e-chart-focused";
            } else if (!className) {
              className = "e-chart-focused";
            }
            firstChild.setAttribute("class", className + " e-chart-focused");
          }
        }
        if (legendElement) {
          var firstChild = legendElement.firstElementChild;
          if (firstChild) {
            var className = firstChild.getAttribute("class");
            if (className && className.indexOf("e-chart-focused") === -1) {
              className = className + " e-chart-focused";
            } else if (!className) {
              className = "e-chart-focused";
            }
            firstChild.setAttribute("class", className);
          }
        }
        if (annotationElement) {
          var firstChild = annotationElement.firstElementChild;
          if (firstChild) {
            var className = firstChild.getAttribute("class");
            if (className && className.indexOf("e-chart-focused") === -1) {
              className = className + " e-chart-focused";
            } else if (!className) {
              className = "e-chart-focused";
            }
            firstChild.setAttribute("class", className);
          }
        }
        if (pagingElement) {
          pagingElement.setAttribute("class", "e-chart-focused");
        }
        if (zoomInElement) {
          zoomInElement.setAttribute("class", "e-chart-focused");
        }
        if (zoomOutElement) {
          zoomOutElement.setAttribute("class", "e-chart-focused");
        }
        if (resetElement) {
          resetElement.setAttribute("class", "e-chart-focused");
        }
        if (e.code == "Tab") {
          if (this.previousTargetId != "") {
            if (this.previousTargetId.indexOf("_Series_") > -1 && targetId.indexOf("_Series_") == -1) {
              groupElement = Chart.getElement(this.element.id + "SeriesCollection");
              if (!sf.base.isNullOrUndefined(groupElement.children[this.currentSeriesIndex])) {
                var previousElement = this.previousTargetId.indexOf("_Symbol") > -1 ? Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex).children[this.currentPointIndex + 1] : this.previousTargetId.indexOf("_Point_") > -1 ? groupElement.children[this.currentSeriesIndex].children[this.currentPointIndex + 1] : groupElement.children[this.currentSeriesIndex];
                Chart.setTabIndex(previousElement, groupElement.firstElementChild);
                this.currentPointIndex = 0;
                this.currentSeriesIndex = 0;
              }
            } else if (this.previousTargetId.indexOf("_chart_legend_page") > -1 && targetId.indexOf("_chart_legend_page") == -1 && targetId.indexOf("_chart_legend_g_") == -1) {
              Chart.setTabIndex(e.target, Chart.getElement(this.element.id + "_chart_legend_pageup"));
            } else if (this.previousTargetId.indexOf("_chart_legend_g_") > -1 && targetId.indexOf("_chart_legend_g_") == -1) {
              groupElement = Chart.getElement(this.element.id + "_chart_legend_translate_g");
              Chart.setTabIndex(groupElement.children[this.currentLegendIndex], groupElement.firstElementChild);
            }
          }
          this.previousTargetId = targetId;
          if (targetId.indexOf("SeriesGroup") > -1) {
            this.currentSeriesIndex = +targetId.split("SeriesGroup")[1];
            targetElement.removeAttribute("tabindex");
            targetElement.blur();
            if (targetElement.children[1].id.indexOf("_Point_") == -1) {
              markerGroup = Chart.getElement(this.element.id + "SymbolGroup" + targetId.split("SeriesGroup")[1]);
            }
            targetId = Chart.focusChild(markerGroup != null ? markerGroup.children[1] : targetElement.children[1]);
          }
          actionKey = this.options.enableHighlight || this.options.showTooltip ? "Tab" : "";
        } else if (e.code.indexOf("Arrow") > -1) {
          e.preventDefault();
          this.previousTargetId = targetId;
          if (targetId.indexOf("_chart_legend_page") > -1) {
            if (e.code == "ArrowLeft") {
              Chart.getElement(this.element.id + "_chart_legend_pagedown").removeAttribute("tabindex");
              Chart.focusChild(Chart.getElement(this.element.id + "_chart_legend_pageup"));
            } else if (e.code == "ArrowRight") {
              Chart.getElement(this.element.id + "_chart_legend_pageup").removeAttribute("tabindex");
              Chart.focusChild(Chart.getElement(this.element.id + "_chart_legend_pagedown"));
            }
          } else if (targetId.indexOf("_chart_legend_") > -1) {
            var legendElement_1 = targetElement.parentElement.children;
            legendElement_1[this.currentLegendIndex].removeAttribute("tabindex");
            this.currentLegendIndex += e.code == "ArrowUp" || e.code == "ArrowRight" ? +1 : -1;
            this.currentLegendIndex = Chart.getActualIndex(this.currentLegendIndex, legendElement_1.length);
            var currentLegend = legendElement_1[this.currentLegendIndex];
            Chart.focusChild(currentLegend);
            targetId = currentLegend.children[1].id;
            actionKey = this.options.enableHighlight ? "ArrowMove" : "";
          } else if (targetId.indexOf("_Annotation_") > -1) {
            var annotationElement_1 = targetElement.parentElement.children;
            annotationElement_1[this.currentAnnotationIndex].removeAttribute("tabindex");
            this.currentAnnotationIndex += e.code == "ArrowUp" || e.code == "ArrowRight" ? +1 : -1;
            this.currentAnnotationIndex = Chart.getActualIndex(this.currentAnnotationIndex, annotationElement_1.length);
            var currentAnnotation = annotationElement_1[this.currentAnnotationIndex];
            Chart.focusChild(currentAnnotation);
            targetId = currentAnnotation.children[1].id;
            actionKey = "";
          } else if (targetId.indexOf("_Series_") > -1) {
            groupElement = targetElement.parentElement.parentElement;
            var currentPoint = e.target;
            targetElement.removeAttribute("tabindex");
            targetElement.blur();
            if (e.code == "ArrowRight" || e.code == "ArrowLeft") {
              var seriesIndexes = [];
              for (var i = 0; i < groupElement.children.length; i++) {
                if (groupElement.children[i].id.indexOf("SeriesGroup") > -1) {
                  seriesIndexes.push(+groupElement.children[i].id.split("SeriesGroup")[1]);
                }
              }
              this.currentSeriesIndex = seriesIndexes.indexOf(this.currentSeriesIndex) + (e.code == "ArrowRight" ? 1 : -1);
              this.currentSeriesIndex = seriesIndexes[Chart.getActualIndex(this.currentSeriesIndex, seriesIndexes.length)];
              groupElement = Chart.getElement(this.element.id + "SeriesGroup" + this.currentSeriesIndex);
              markerGroup = Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex);
              this.currentPointIndex = Chart.getActualIndex(this.currentPointIndex, markerGroup ? markerGroup.childElementCount : groupElement.childElementCount);
              currentPoint = groupElement.children[1].id.indexOf("_Point_") == -1 && markerGroup ? markerGroup.children[this.currentPointIndex + 1] : groupElement.children[this.currentPointIndex + 1];
            } else {
              this.currentPointIndex += e.code == "ArrowUp" ? 1 : -1;
              if (targetId.indexOf("_Symbol") > -1) {
                this.currentPointIndex = Chart.getActualIndex(this.currentPointIndex, Chart.getElement(this.element.id + "SymbolGroup" + this.currentSeriesIndex).childElementCount - 1);
                currentPoint = Chart.getElement(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex + "_Symbol");
              } else if (targetId.indexOf("_Point_") > -1) {
                this.currentPointIndex = Chart.getActualIndex(this.currentPointIndex, Chart.getElement(this.element.id + "SeriesGroup" + this.currentSeriesIndex).childElementCount - 1);
                currentPoint = Chart.getElement(this.element.id + "_Series_" + this.currentSeriesIndex + "_Point_" + this.currentPointIndex);
              }
            }
            targetId = Chart.focusChild(currentPoint);
            actionKey = this.options.showTooltip ? "ArrowMove" : "";
          }
        } else if ((e.code == "Enter" || e.code == "Space") && (targetId.indexOf("_chart_legend_") > -1 || targetId.indexOf("_Point_") > -1)) {
          targetId = targetId.indexOf("_chart_legend_page") > -1 ? targetId : targetId.indexOf("_chart_legend_") > -1 ? targetElement.children[1].id : targetId;
          actionKey = "Enter";
        }
      }
      if (targetId.indexOf("_Zooming_") > -1) {
        if (this.zoomBase.zoomingModule) {
          if (e.code == "Enter" || e.code == "Space") {
            this.zoomBase.zoomingModule.isZoomed = this.zoomBase.zoomingModule.performedUI = true;
            this.zoomBase.zoomingModule.isPanning = this.zoomBase.isChartDrag = false;
            if (targetId.indexOf("_Zooming_ZoomIn") > -1) {
              Chart.zoomToolkitZoomIn(this, target.getAttribute('opacity'));
              actionKey = "Enter";
            } else if (targetId.indexOf("_Zooming_ZoomOut") > -1) {
              Chart.zoomToolkitZoomOut(this, target.getAttribute('opacity'));
              actionKey = "Enter";
            } else if (targetId.indexOf("_Zooming_Reset") > -1) {
              Chart.zoomToolkitReset(this);
              actionKey = "Enter";
            }
            Chart.performZoomRedraw(this, false);
          }
        }
      }
      if (actionKey != "") {
        if (actionKey == "ArrowMove" || actionKey == "Tab") {
          if (targetId.indexOf('_Point_') > -1) {
            var seriesIndex_1 = parseInt(targetId.split('_Series_')[1].split('_Point_')[0]);
            var pointIndex = parseInt(targetId.split('_Series_')[1].replace('_Symbol', '').split('_Point_')[1]);
            var currentSeries_1;
            this.userInteractionBase.visibleSeries.forEach(function (series) {
              if (series.index === seriesIndex_1) {
                currentSeries_1 = series;
              }
            });
            var pointRegion = Chart.isRectSeries(currentSeries_1.type) ? currentSeries_1.points[pointIndex].r[0] : currentSeries_1.points[pointIndex].s[0];
            this.mouseX = Math.ceil(pointRegion.x + this.userInteractionBase.initialRect.x);
            this.mouseY = Math.ceil(pointRegion.y + this.userInteractionBase.initialRect.y);
            Chart.tooltipMousemovehandler(this);
          } else {
            Chart.removeTooltip(1, this);
          }
        }
        if (actionKey == "ESC") {
          Chart.removeTooltip(1, this);
        }
        this.processPointSelection(dotnetref, id, targetId, actionKey);
        dotnetref.invokeMethodAsync("OnChartKeyboardNavigations", actionKey, targetId);
      }
      return false;
    };
    SfChart.prototype.mouseLeave = function (dotnetref, id, e) {
      if (this.tooltipBase.tooltipModule != null) {
        Chart.removeTooltip(this.tooltipBase.tooltipModule.fadeOutDuration, this);
      }
      if (this.crosshairBase.crosshair != null) {
        Chart.removeCrosshair(this, 1000);
      }
      this.dotnetref = dotnetref;
      if (this.zoomBase.zoomingModule) {
        this.zoomBase.isChartDrag = this.userInteractionBase.isPointMouseDown = false;
        Chart.mouseCancelHandler(this);
      }
      dotnetref.invokeMethodAsync('OnChartMouseLeave', this.getEventArgs(e, id));
      return false;
    };
    SfChart.prototype.longPress = function (dotnetref, id, e) {
      this.dotnetref = dotnetref;
      var clientX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;
      var clientY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;
      this.setMouseXY(clientX, clientY, id);
      var args = {
        type: 'TapHold',
        clientX: clientX,
        clientY: clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        pointerType: '',
        target: '',
        changedTouches: {
          clientX: clientX,
          clientY: clientY
        },
        touches: [],
        pointerId: 0
      };
      this.userInteractionBase.startMove = true;
      if (sf.svgbase.withInAreaBounds(this.mouseX, this.mouseY, this.userInteractionBase.axisClipRect)) {
        Chart.markerMove(this, false);
        if (this.tooltipBase.tooltipModule.enable) {
          Chart.tooltip(this);
        }
        if (this.crosshairBase.crosshair.enable) {
          Chart.createCrosshair(this);
        }
      }
      this.dotnetref.invokeMethodAsync('OnChartLongPress');
      return false;
    };
    SfChart.prototype.getAxisScrollbar = function (id, axes) {
      var axisName = "";
      var splitId = [];
      if (!Chart.isExist(id, "_scrollBar_svg")) {
        splitId = id.split("_");
        axisName = splitId[splitId.length - 1];
      } else {
        splitId = id.split("_scrollBar_svg");
        axisName = splitId[splitId.length - 1];
      }
      var scrollbarAxis = axes.filter(function (axis) {
        return axis.name === axisName;
      })[0];
      return scrollbarAxis;
    };
    SfChart.prototype.scrollDown = function (dotnetref, id, event) {
      var targetId = event.target.id;
      if (targetId.indexOf("scrollBar") > -1) {
        var chart = window.sfBlazor.getCompInstance(this.dataId);
        var scrollbar = chart.scrollbarBase;
        scrollbar.targetId = targetId;
        var scrollbarAxis = this.getAxisScrollbar(targetId, scrollbar.axes);
        scrollbar.axis = scrollbarAxis;
        var scrollbarOptions = scrollbar.scrollbarOptions[scrollbarAxis.name];
        scrollbarOptions.isVertical = scrollbarAxis.orientation === 'Vertical';
        var isInverse = scrollbarAxis.isAxisInverse;
        var eventArgs = Chart.getScrollEventArgs(event, [chart.id, chart.id + '_scrollBar_svg' + scrollbarAxis.name]);
        this.mouseX = eventArgs['mouseX'];
        this.mouseY = eventArgs['mouseY'];
        //Chart.getMouseXY(event, id, scrollbarAxis.name);
        scrollbar.isResizeLeft = Chart.isExist(targetId, '_leftCircle_') || Chart.isExist(targetId, '_leftArrow_');
        scrollbar.isResizeRight = Chart.isExist(targetId, '_rightCircle_') || Chart.isExist(targetId, '_rightArrow_');
        //  this.previousXY = this.isVertical ? this.mouseY : this.mouseX;
        scrollbar.previousXY = scrollbarOptions.isVertical && isInverse ? this.mouseY : scrollbarOptions.isVertical ? scrollbarOptions.width - this.mouseY : isInverse ? scrollbarOptions.width - this.mouseX : this.mouseX;
        scrollbar.previousWidth = scrollbarOptions.thumbRectWidth;
        scrollbar.previousRectX = scrollbarOptions.thumbRectX;
        scrollbar.startZoomPosition = scrollbarAxis.zoomPosition;
        scrollbar.startZoomFactor = scrollbarAxis.zoomFactor;
        scrollbar.startRange = scrollbarAxis.visibleRange;
        scrollbar.scrollStarted = true;
        var scrollArgs = {
          name: 'ScrollStart',
          zoomPosition: scrollbarAxis.zoomPosition,
          zoomFactor: scrollbarAxis.zoomFactor,
          range: scrollbarAxis.visibleRange,
          // previousZoomPosition: zoomPosition,
          // previousZoomFactor: zoomFactor,
          // previousRange: range,
          axis: scrollbarAxis
        };
        chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('ScrollStart', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, null));
        //this.component.trigger(scrollStart, this.getArgs(scrollStart));
        if (Chart.isExist(targetId, 'scrollBarThumb_') || Chart.isExist(targetId, 'gripCircle')) {
          scrollbar.isThumbDrag = true;
          scrollbarOptions.svgObject.style.cursor = '-webkit-grabbing';
        } else if (Chart.isExist(targetId, 'scrollBarBackRect_')) {
          var currentX = Chart.moveLength(scrollbar);
          scrollbarOptions.thumbRectX = Chart.isWithIn(currentX, scrollbar) ? currentX : scrollbarOptions.thumbRectX;
          Chart.positionThumb(scrollbarOptions.thumbRectX, scrollbarOptions.thumbRectWidth, scrollbar);
          Chart.setZoomFactorPosition(scrollbar, scrollbarOptions.thumbRectX, scrollbarOptions.thumbRectWidth, false);
          if (scrollbarOptions.isLazyLoad) {
            var thumbMove = scrollbarOptions.thumbRectX > scrollbar.previousRectX ? 'RightMove' : 'LeftMove';
            var args = Chart.calculateLazyRange(scrollbar, thumbMove);
            if (args) {
              chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('ScrollStart', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, args.currentRange));
              // this.component.trigger(scrollEnd, args);
            }
          }
        }
      }
      return false;
    };
    SfChart.prototype.domMouseMove = function (dotnetref, id, event) {
      var targetId = event.target.id;
      var chart = window.sfBlazor.getCompInstance(this.dataId);
      if (!sf.base.isNullOrUndefined(chart) && !sf.base.isNullOrUndefined(targetId) && targetId.indexOf(chart.id) > -1) {
        var scrollbar = chart.scrollbarBase;
        targetId = !sf.base.isNullOrUndefined(scrollbar) && scrollbar.scrollStarted ? scrollbar.targetId : targetId;
        if (targetId.indexOf("scrollBar") > -1) {
          var scrollbarAxis = this.getAxisScrollbar(targetId, scrollbar.axes);
          var scrollbarOptions = scrollbar.scrollbarOptions[scrollbarAxis.name];
          var isInverse = scrollbarAxis.isAxisInverse;
          if (sf.base.isNullOrUndefined(scrollbarOptions) || scrollbarOptions && !document.getElementById(scrollbarOptions.svgObject.id)) {
            return null;
          }
          var eventArgs = Chart.getScrollEventArgs(event, [chart.id, chart.id + '_scrollBar_svg' + scrollbarAxis.name]);
          this.mouseX = eventArgs['mouseX'];
          this.mouseY = eventArgs['mouseY'];
          //Chart.getMouseXY(event, id, scrollbarAxis.name);
          Chart.setCursor(event.target, this.dataId, scrollbarAxis.name);
          Chart.setTheme(event.target, this.dataId, scrollbarAxis.name);
          //let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;
          var mouseXY = scrollbarOptions.isVertical && isInverse ? scrollbarOptions.width - this.mouseY : scrollbarOptions.isVertical ? this.mouseY : this.mouseX;
          var range = scrollbarAxis.visibleRange;
          var zoomPosition = scrollbarOptions.zoomPosition;
          var zoomFactor = scrollbarOptions.zoomFactor;
          var moveLength = scrollbar.previousRectX - scrollbarOptions.thumbRectX;
          var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';
          var args = void 0;
          if (scrollbarOptions.isLazyLoad && (scrollbar.isThumbDrag || scrollbar.isResizeLeft || scrollbar.isResizeRight)) {
            args = Chart.calculateLazyRange(scrollbar, thumbMove);
          }
          var currentRange = args ? args.currentRange : null;
          if (scrollbar.isThumbDrag) {
            scrollbar.isScrolling = scrollbar.isThumbDrag;
            mouseXY = scrollbarOptions.isVertical || isInverse ? scrollbarOptions.width - mouseXY : mouseXY;
            var currentX = scrollbarOptions.thumbRectX + (mouseXY - scrollbar.previousXY);
            if (mouseXY >= currentX + scrollbarOptions.thumbRectWidth) {
              Chart.setCursor(event.target, this.dataId, scrollbarAxis.name);
            } else {
              scrollbarOptions.svgObject.style.cursor = '-webkit-grabbing';
            }
            if (mouseXY >= 0 && mouseXY <= currentX + scrollbarOptions.thumbRectWidth) {
              scrollbarOptions.thumbRectX = Chart.isWithIn(currentX, scrollbar) ? currentX : scrollbarOptions.thumbRectX;
              Chart.positionThumb(scrollbarOptions.thumbRectX, scrollbarOptions.thumbRectWidth, scrollbar);
              scrollbar.previousXY = mouseXY;
              Chart.setZoomFactorPosition(scrollbar, currentX, scrollbarOptions.thumbRectWidth, false);
            }
            chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollChanged', scrollbarAxis.name, zoomPosition, zoomFactor, currentRange));
            // this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor, currentRange));
          } else if (scrollbar.isResizeLeft || scrollbar.isResizeRight) {
            Chart.resizeThumb(scrollbar, this.mouseX, this.mouseY);
            chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollChanged', scrollbarAxis.name, zoomPosition, zoomFactor, currentRange));
            // this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor, currentRange));
          }
        }
      }
      return false;
    };
    SfChart.prototype.domMouseUp = function (dotnetref, id, event) {
      var targetId = event.target.id;
      var chart = window.sfBlazor.getCompInstance(this.dataId);
      var scrollbar = chart.scrollbarBase;
      targetId = !sf.base.isNullOrUndefined(scrollbar) && scrollbar.scrollStarted ? scrollbar.targetId : targetId;
      if (targetId.indexOf("scrollBar") > -1) {
        var args = void 0;
        var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
        scrollbarOptions.startX = scrollbarOptions.thumbRectX;
        var scrollbarAxis = this.getAxisScrollbar(targetId, scrollbar.axes);
        var circleRadius = 8;
        var circleWidth = 1;
        var currentScrollWidth = scrollbarOptions.startX + scrollbarOptions.thumbRectWidth + circleRadius + circleWidth;
        var currentZPWidth = circleRadius + circleWidth / 2;
        if ((scrollbar.isResizeLeft || scrollbar.isResizeRight) && !scrollbarOptions.isLazyLoad) {
          scrollbarAxis.zoomFactor = currentScrollWidth >= scrollbarOptions.width - 1 && scrollbarOptions.startX - currentZPWidth <= 0 ? 1 : scrollbarOptions.zoomFactor;
        }
        if (scrollbarOptions.isLazyLoad) {
          var moveLength = scrollbar.previousRectX - scrollbarOptions.startX;
          if ((moveLength > 0 || moveLength < 0) && scrollbar.isThumbDrag) {
            var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';
            if (thumbMove === 'RightMove') {
              scrollbarOptions.startX = scrollbarOptions.startX + Math.abs(moveLength) < scrollbarOptions.width - circleRadius ? scrollbarOptions.startX : scrollbarOptions.width - circleRadius - scrollbarOptions.thumbRectWidth;
            } else {
              scrollbarOptions.startX = scrollbarOptions.startX + scrollbarOptions.thumbRectWidth - Math.abs(moveLength) > circleRadius ? scrollbarOptions.startX : circleRadius;
            }
            args = Chart.calculateLazyRange(scrollbar, thumbMove);
            if (args) {
              chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollEnd', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, args.currentRange));
              // this.component.trigger(scrollEnd, args);
              scrollbar.targetId = targetId;
              scrollbar.scrollStarted = false;
            }
          }
          if (scrollbar.isResizeLeft || scrollbar.isResizeRight) {
            args = Chart.calculateLazyRange(scrollbar);
            if (args) {
              chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollEnd', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, args.currentRange));
              // this.component.trigger(scrollEnd, args);
              scrollbar.targetId = targetId;
              scrollbar.scrollStarted = false;
            }
          }
        }
        scrollbar.isThumbDrag = false;
        scrollbar.isResizeLeft = false;
        scrollbar.isResizeRight = false;
        scrollbar.isScrollEnd = false;
        scrollbar.isScrolling = false;
        if (scrollbar.scrollStarted && !scrollbarOptions.isLazyLoad) {
          chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollChanged', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, args ? args.currentRange : null));
          // this.component.trigger(
          //     scrollEnd, this.getArgs(scrollChanged, this.startRange, this.startZoomPosition, this.startZoomFactor)
          // );
          scrollbar.targetId = targetId;
          scrollbar.scrollStarted = false;
        }
        chart.dotnetref.invokeMethodAsync('UpdateChartData');
      }
      if (chart.userInteractionBase.isStockChart) {
        chart.userInteractionBase.startMove = false;
      }
      return false;
    };
    return SfChart;
  }();
  var Index = /** @class */function () {
    function Index(seriesIndex, pointIndex) {
      this.series = seriesIndex;
      this.point = pointIndex;
    }
    return Index;
  }();
  var IChartInternalLocation = /** @class */function () {
    function IChartInternalLocation(x, y) {
      this.x = x;
      this.y = y;
    }
    return IChartInternalLocation;
  }();
  var IColorValue = /** @class */function () {
    function IColorValue(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }
    return IColorValue;
  }();
  var ITooltipBase = /** @class */function () {
    function ITooltipBase() {
      this.currentPoints = [];
      this.previousPoints = [];
      this.valueX = 0;
      this.valueY = 0;
      this.tooltipTempList = [];
    }
    return ITooltipBase;
  }();
  var IMarkerExplodeBase = /** @class */function () {
    function IMarkerExplodeBase() {
      this.markerCurrentPoints = [];
      this.markerPreviousPoints = [];
      this.trackBallClass = 'EJ2-TrackBall';
    }
    return IMarkerExplodeBase;
  }();
  var ICrosshairBase = /** @class */function () {
    function ICrosshairBase() {
      this.crosshairX = 0;
      this.crosshairY = 0;
      this.rx = 2;
      this.ry = 2;
    }
    return ICrosshairBase;
  }();
  var IUserInteractionBase = /** @class */function () {
    function IUserInteractionBase() {
      this.lierIndex = 0;
      this.chartStartMove = true;
      this.axes = [];
      this.isFirstRendered = true;
      this.toolbarHeight = 43;
    }
    return IUserInteractionBase;
  }();
  var IBrowser = /** @class */function () {
    function IBrowser(name, isPointer, isDevice, isTouch, isIos) {
      this.browserName = name;
      this.isPointer = isPointer;
      this.isDevice = isDevice;
      this.isTouch = isTouch;
      this.isIos = isIos;
    }
    return IBrowser;
  }();
  var RectOption = /** @class */function (_super) {
    __extends(RectOption, _super);
    function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;
      _this.y = rect.y;
      _this.x = rect.x;
      _this.height = rect.height;
      _this.width = rect.width;
      _this.rx = rx ? rx : 0;
      _this.ry = ry ? ry : 0;
      _this.transform = transform ? transform : '';
      _this.stroke = border.width !== 0 && _this.stroke !== '' ? border.color : 'transparent';
      return _this;
    }
    return RectOption;
  }(sf.svgbase.PathOption);
  var IZoom = /** @class */function () {
    function IZoom(sfChart) {
      this.isZoomStart = true;
      this.touchStartList = [];
      this.touchMoveList = [];
      this.chart = sfChart;
      this.browser = new IBrowser(sf.base.Browser.info.name, sf.base.Browser.isPointer, sf.base.Browser.isDevice, sf.base.Browser.isTouch, sf.base.Browser.isIos || sf.base.Browser.isIos7);
      this.isDevice = this.browser.isDevice;
      this.zooming = sfChart.zoomBase.zoomSettings;
      this.elementId = sfChart.element.id;
      this.zoomAxes = [];
      this.zoomingRect = new sf.svgbase.Rect(0, 0, 0, 0);
      this.isZoomed = this.performedUI = this.zooming.enablePan && this.zooming.enableSelectionZooming;
    }
    return IZoom;
  }();
  var IZoomToolkitBase = /** @class */function () {
    function IZoomToolkitBase() {
      this.iconRectOverFill = 'transparent';
      this.iconRectSelectionFill = 'transparent';
    }
    return IZoomToolkitBase;
  }();
  var IZoomBase = /** @class */function () {
    function IZoomBase() {
      this.axisCollections = [];
      this.previousMouseMoveX = 0;
      this.previousMouseMoveY = 0;
      this.mouseDownX = 0;
      this.mouseDownY = 0;
      this.clipRectId = '_ChartAreaClipRect__Rect';
      this.zoomToolkitId = '_Zooming_KitCollection';
      this.zoomToolkitZoom = '_Zooming_Zoom';
      this.zoomToolkitZoomIn = '_Zooming_ZoomIn';
      this.zoomToolkitZoomOut = '_Zooming_ZoomOut';
      this.zoomToolkitPan = '_Zooming_Pan';
      this.zoomToolkitReset = '_Zooming_Reset';
      this.chartZoomTip = 'EJ2_Chart_ZoomTip';
    }
    return IZoomBase;
  }();
  var CircleOption = /** @class */function (_super) {
    __extends(CircleOption, _super);
    function CircleOption(id, fill, border, opacity, cx, cy, r) {
      var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;
      _this.cy = cy;
      _this.cx = cx;
      _this.r = r;
      return _this;
    }
    return CircleOption;
  }(sf.svgbase.PathOption);
  var Chart = {
    initialize: function initialize(dataId, element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions) {
      var _this = this;
      var instance = new SfChart(dataId, element.id, element, dotnetRef, isZooming, isScrollbar, options, selectionHighlightOptions);
      if (element.id.indexOf('_stockChart_') > -1) {
        var stockchartId_1 = element.id.split('_stockChart_')[0];
        var stockchartDotnetRef = window.sfBlazor.StockChart.dotnetrefCollection.find(function (item) {
          return item.id == stockchartId_1;
        }).dotnetref;
        window.sfBlazor.StockChart.getTooltipPosition(stockchartDotnetRef).then(function (tooltipPosition) {
          _this.stockChartTooltipPosition = tooltipPosition;
        });
      }
      this.isUpdatingClipRect = false;
      instance.render();
    },
    destroy: function destroy(dataId) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.destroy();
      }
    },
    getArgs: function getArgs(eventName, axisName, zoomPosition, zoomFactor, currentRanges) {
      return {
        name: eventName,
        axisName: axisName,
        zoomPosition: isFinite(zoomPosition) ? zoomPosition : 1,
        zoomFactor: isFinite(zoomFactor) ? zoomFactor : 1,
        currentRangeMax: currentRanges ? currentRanges.maximum.toString() : '',
        currentRangeMin: currentRanges ? currentRanges.minimum.toString() : ''
      };
    },
    getMouseXY: function getMouseXY(e, id, axisName) {
      var pageX;
      var pageY;
      var touchArg;
      if (e.type.indexOf('touch') > -1) {
        touchArg = e;
        pageX = touchArg.changedTouches[0].clientX;
        pageY = touchArg.changedTouches[0].clientY;
      } else {
        pageX = e.clientX;
        pageY = e.clientY;
      }
      var svgRect = document.getElementById(id + '_scrollBar_svg' + axisName).getBoundingClientRect();
      this.mouseX = pageX - Math.max(svgRect.left, 0);
      this.mouseY = pageY - Math.max(svgRect.top, 0);
    },
    isExist: function isExist(id, match) {
      return id.indexOf(match) > -1;
    },
    moveLength: function moveLength(scrollbar) {
      var mouseXY = scrollbar.previousXY;
      var thumbX = scrollbar.previousRectX;
      var circleRadius = 8;
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      var moveLength = 10 / 100 * (scrollbarOptions.width - circleRadius * 2);
      if (mouseXY < thumbX) {
        moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);
      } else {
        moveLength = thumbX + (thumbX + scrollbarOptions.thumbRectWidth + moveLength < scrollbarOptions.width - circleRadius ? moveLength : circleRadius);
      }
      return moveLength;
    },
    isWithIn: function isWithIn(currentX, scrollbar) {
      var circleRadius = 8;
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      return currentX - circleRadius >= 0 && currentX + scrollbarOptions.thumbRectWidth + circleRadius <= scrollbarOptions.width;
    },
    positionThumb: function positionThumb(currentX, currentWidth, scrollbar) {
      var gripWidth = 14;
      var gripCircleDiameter = 2;
      var padding = gripWidth / 2 - gripCircleDiameter;
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      scrollbarOptions.slider.setAttribute('x', currentX.toString());
      scrollbarOptions.slider.setAttribute('width', currentWidth.toString());
      scrollbarOptions.leftCircleEle.setAttribute('cx', currentX.toString());
      scrollbarOptions.rightCircleEle.setAttribute('cx', (currentX + currentWidth).toString());
      this.setArrowDirection(scrollbar);
      scrollbarOptions.gripCircle.setAttribute('transform', 'translate(' + (currentX + currentWidth / 2 + (scrollbarOptions.isVertical ? 1 : -1) * padding) + ',' + (scrollbarOptions.isVertical ? '10' : '5') + ') rotate(' + (scrollbarOptions.isVertical ? '180' : '0') + ')');
    },
    setZoomFactorPosition: function setZoomFactorPosition(scrollbar, currentX, currentWidth, isRequire) {
      if (isRequire === void 0) {
        isRequire = true;
      }
      var axis = scrollbar.axis;
      var scrollbarOptions = scrollbar.scrollbarOptions[axis.name];
      scrollbarOptions.isScrollUI = true;
      var circleRadius = scrollbarOptions.height / 2;
      var circleWidth = 1;
      var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;
      var currentZPWidth = circleRadius + circleWidth / 2;
      var axisSize = scrollbarOptions.isVertical ? axis.rect.h : scrollbarOptions.width;
      scrollbarOptions.zoomFactor = (currentWidth + (currentScrollWidth >= scrollbarOptions.width ? circleRadius + circleWidth : 0)) / axisSize;
      axis.zoomFactor = isRequire && !scrollbarOptions.isLazyLoad ? scrollbarOptions.zoomFactor : axis.zoomFactor;
      scrollbarOptions.zoomPosition = currentScrollWidth > axisSize ? 1 - axis.zoomFactor : currentX < circleRadius + circleWidth ? 0 : (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / axisSize;
      axis.zoomPosition = scrollbarOptions.zoomPosition < 0 ? 0 : scrollbarOptions.zoomPosition > 0.9 ? 1 : scrollbarOptions.zoomPosition;
      if (!scrollbarOptions.isLazyLoad) {
        this.dotnetref.invokeMethodAsync('ChartScrolled', axis.name, axis.zoomFactor, axis.zoomPosition);
      }
    },
    calculateLazyRange: function calculateLazyRange(scrollbar, thumbMove, delta) {
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      var scrollThumbX = scrollbarOptions.thumbRectX;
      var currentScrollWidth = scrollbarOptions.thumbRectWidth;
      var zoomFactor;
      var zoomPosition;
      var currentStart;
      var currentEnd;
      var args;
      var range = scrollbarOptions.scrollRange;
      var previousRange = this.getStartEnd(scrollbarOptions.previousStart, scrollbarOptions.previousEnd, false, scrollbar);
      var circleRadius = 8;
      var circleWidth = 16;
      if (scrollbar.isResizeRight || thumbMove === 'RightMove') {
        currentScrollWidth = scrollbar.isResizeRight ? currentScrollWidth + circleWidth : currentScrollWidth;
        zoomFactor = currentScrollWidth / scrollbarOptions.width;
        zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / scrollbarOptions.width : scrollbar.axis.zoomPosition;
        currentStart = thumbMove === 'RightMove' ? range.start + zoomPosition * range.delta : scrollbarOptions.previousStart;
        currentEnd = currentStart + zoomFactor * range.delta;
      } else if (scrollbar.isResizeLeft || thumbMove === 'LeftMove') {
        zoomPosition = (scrollThumbX - circleRadius) / scrollbarOptions.width;
        zoomFactor = currentScrollWidth / scrollbarOptions.width;
        currentStart = range.start + zoomPosition * range.delta;
        currentStart = currentStart >= range.start ? currentStart : range.start;
        currentEnd = thumbMove === 'LeftMove' ? currentStart + zoomFactor * range.delta : scrollbarOptions.previousEnd;
      } else if (scrollbar.isThumbDrag || scrollbar.isScrollWheel) {
        zoomPosition = thumbMove === 'RightMove' || delta > 0 ? (scrollThumbX + circleRadius) / scrollbarOptions.width : (scrollThumbX - circleRadius) / scrollbarOptions.width;
        zoomFactor = scrollbarOptions.thumbRectWidth / scrollbarOptions.width;
        currentStart = range.start + zoomPosition * range.delta;
        currentStart = currentStart >= range.start ? currentStart : range.start;
        currentEnd = currentStart + zoomFactor * range.delta;
      }
      if (currentEnd) {
        args = {
          axis: scrollbar.axis,
          currentRange: this.getStartEnd(currentStart, currentEnd, true, scrollbar),
          previousAxisRange: previousRange
        };
      }
      return args;
    },
    getStartEnd: function getStartEnd(start, end, isCurrentStartEnd, scrollbar) {
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      var valueType = scrollbarOptions.valueType;
      if ((valueType === 'DateTime' || valueType === 'DateTimeCategory') && isCurrentStartEnd) {
        scrollbarOptions.previousStart = start;
        scrollbarOptions.previousEnd = end;
      } else if (isCurrentStartEnd) {
        scrollbarOptions.previousStart = Math.round(start);
        scrollbarOptions.previousEnd = Math.ceil(end);
      }
      switch (valueType) {
        case 'Double':
        case 'Category':
        case 'Logarithmic':
          start = Math.round(start);
          end = Math.ceil(end);
          break;
        case 'DateTime':
        case 'DateTimeCategory':
          start = start;
          end = end;
          break;
      }
      return {
        minimum: start,
        maximum: end
      };
    },
    setCursor: function setCursor(target, dataId, axisName) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      var scrollbar = chart.scrollbarBase;
      if (scrollbar) {
        var id = target.id;
        if (id && scrollbar.scrollbarOptions[axisName]) {
          scrollbar.scrollbarOptions[axisName].svgObject.style.cursor = id.indexOf('scrollBarThumb_') > -1 || id.indexOf('_gripCircle') > -1 ? '-webkit-grab' : id.indexOf('Circle_') > -1 || id.indexOf('Arrow_') > -1 ? scrollbar.scrollbarOptions[axisName].isVertical ? 'ns-resize' : 'ew-resize' : 'auto';
        }
      }
    },
    setTheme: function setTheme(target, dataId, axisName) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      var scrollbar = chart.scrollbarBase;
      var scrollbarOptions = scrollbar.scrollbarOptions[axisName];
      if (scrollbarOptions) {
        var id = target.id;
        var isLeftHover = id.indexOf('_leftCircle_') > -1 || id.indexOf('_leftArrow_') > -1;
        var isRightHover = id.indexOf('_rightCircle_') > -1 || id.indexOf('_rightArrow_') > -1;
        var style = scrollbar.scrollbarThemeStyle;
        var leftArrowEle = scrollbarOptions.leftArrowEle;
        var rightArrowEle = scrollbarOptions.rightArrowEle;
        var leftCircleEle = scrollbarOptions.leftCircleEle;
        var rightCircleEle = scrollbarOptions.rightCircleEle;
        var isAxis = this.isCurrentAxis(target, leftArrowEle);
        leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;
        leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        if (scrollbar.theme === 'HighContrastLight') {
          leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;
          leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;
          rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;
          rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;
          leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
          rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        }
      }
    },
    isCurrentAxis: function isCurrentAxis(target, ele) {
      return target.id.split('_')[2] === ele.id.split('_')[2];
    },
    resizeThumb: function resizeThumb(scrollbar, mouseX, mouseY) {
      var currentWidth;
      var circleRadius = scrollbar.scrollbarOptions[scrollbar.axis.name].height / 2;
      var padding = 5;
      var gripWidth = 14;
      var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
      var thumbX = scrollbar.previousRectX;
      var isInverse = scrollbar.axis.isAxisInverse;
      this.mouseX = mouseX;
      this.mouseY = mouseY;
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbar.axis.name];
      // let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;
      var mouseXY = scrollbarOptions.isVertical && isInverse ? this.mouseY : scrollbarOptions.isVertical ? scrollbarOptions.width - this.mouseY : isInverse ? scrollbarOptions.width - this.mouseX : this.mouseX;
      var diff = Math.abs(scrollbar.previousXY - mouseXY);
      if (scrollbar.isResizeLeft && mouseXY >= 0) {
        var currentX = thumbX + (mouseXY > scrollbar.previousXY ? diff : -diff);
        currentWidth = currentX - circleRadius >= 0 ? scrollbar.previousWidth + (mouseXY > scrollbar.previousXY ? -diff : diff) : scrollbar.previousWidth;
        currentX = currentX - circleRadius >= 0 ? currentX : thumbX;
        if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {
          scrollbarOptions.thumbRectX = scrollbar.previousRectX = currentX;
          scrollbarOptions.thumbRectWidth = scrollbar.previousWidth = currentWidth;
          scrollbar.previousXY = mouseXY;
          this.positionThumb(currentX, currentWidth, scrollbar);
          this.setZoomFactorPosition(scrollbar, currentX, currentWidth);
        }
      } else if (scrollbar.isResizeRight) {
        currentWidth = mouseXY >= minThumbWidth + scrollbarOptions.thumbRectX && mouseXY <= scrollbarOptions.width - circleRadius ? mouseXY - scrollbarOptions.thumbRectX : scrollbar.previousWidth;
        scrollbarOptions.thumbRectWidth = scrollbar.previousWidth = currentWidth;
        scrollbar.previousXY = mouseXY;
        this.positionThumb(scrollbarOptions.startX, currentWidth, scrollbar);
        this.setZoomFactorPosition(scrollbar, scrollbarOptions.startX, currentWidth);
        if (!scrollbarOptions.isLazyLoad) {
          this.setZoomFactorPosition(scrollbar, scrollbarOptions.startX, currentWidth);
        }
      }
    },
    setHighlightSelectionOptions: function setHighlightSelectionOptions(dataId, selectionHighlightOptions) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.selectionHighlightOptions(selectionHighlightOptions);
      }
    },
    showTooltip: function showTooltip(x, y, isPoint, id) {
      if (isPoint === void 0) {
        isPoint = false;
      }
      var chart = window.sfBlazor.getCompInstance(id);
      if (isPoint) {
        for (var _i = 0, _a = chart.userInteractionBase.visibleSeries; _i < _a.length; _i++) {
          var series = _a[_i];
          for (var _b = 0, _c = series.points; _b < _c.length; _b++) {
            var point = _c[_b];
            var pointX = series.x_Axis.valueType == 'DateTime' ? point.xV : point.x;
            var xValue = x;
            if (series.x_Axis.valueType == 'DateTime') {
              xValue = new Date(xValue).getTime();
            }
            if (x == pointX && y === point.yV) {
              chart.mouseX = point.r[0].x + series.clipRect.x;
              chart.mouseY = point.r[0].y + series.clipRect.y;
              Chart.tooltipMousemovehandler(chart);
              Chart.markerMove(chart, false);
              break;
            }
          }
        }
      } else {
        chart.mouseX = x;
        chart.mouseY = y;
        Chart.tooltipMousemovehandler(chart);
        Chart.markerMove(chart, false);
      }
    },
    hideTooltip: function hideTooltip(id) {
      var chart = window.sfBlazor.getCompInstance(id);
      Chart.removeTooltip(sf.base.Browser.isDevice ? 2000 : 1000, chart);
    },
    showCrosshair: function showCrosshair(x, y, id) {
      var chart = window.sfBlazor.getCompInstance(id);
      chart.mouseX = x;
      chart.mouseY = y;
      Chart.crosshairMousemoveHandler(chart);
    },
    hideCrosshair: function hideCrosshair(id) {
      var chart = window.sfBlazor.getCompInstance(id);
      Chart.removeCrosshair(chart, sf.base.Browser.isDevice ? 2000 : 1000);
    },
    updateZoomingOptions: function updateZoomingOptions(id, isZoomed) {
      var chart = window.sfBlazor.getCompInstance(id);
      if (!sf.base.isNullOrUndefined(chart)) {
        chart.zoomBase.zoomingModule.isZoomed = isZoomed;
        chart.zoomBase.zoomingModule.isPanning = isZoomed;
      }
    },
    setTooltipData: function setTooltipData(dataId, clipRects, seriesMarkers, seriesBorders, axes, tooltip, dateValuePairs, numberValuePairs, axisClipRect) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (chart.tooltipBase.tooltipModule && !chart.userInteractionBase.isStockChart) {
        this.removeTooltip(sf.base.Browser.isDevice ? 1000 : 100, chart);
        this.removeCrosshair(chart, sf.base.Browser.isDevice ? 1000 : 100);
      }
      if (tooltip) {
        if (chart.tooltipBase.tooltipModule.template != null) {
          tooltip.template = chart.tooltipBase.tooltipModule.template;
        }
        chart.tooltipBase.tooltipModule = tooltip;
      }
      chart.dateValuePairs = dateValuePairs;
      chart.numberValuePairs = numberValuePairs;
      chart.userInteractionBase.chartStartMove = false;
      chart.getTooltipData(clipRects, seriesMarkers, seriesBorders, axes);
      chart.userInteractionBase.chartStartMove = true;
      chart.zoomBase.axisCollections = axes;
      chart.userInteractionBase.axisClipRect = axisClipRect;
      if (chart.zoomBase.zoomingModule) {
        if (!this.isUpdatingClipRect && chart.userInteractionBase.isStockChart) {
          this.isUpdatingClipRect = true;
          this.updateClipRect(this.getElement(chart.element.id + chart.zoomBase.clipRectId), chart);
          this.isUpdatingClipRect = false;
        } else if (!chart.userInteractionBase.isStockChart) {
          this.updateClipRect(this.getElement(chart.element.id + chart.zoomBase.clipRectId), chart);
        }
      }
      if (chart.isDataLoaded) {
        setTimeout(function () {
          chart.removeTooltipData();
        }, 500);
      }
      this.applyZoomingToolkit(chart);
    },
    setTooltipOptions: function setTooltipOptions(dataId, tooltip, tooltipOptions, clipRects, seriesMarkers, seriesBorders, axes, dateValuePairs, numberValuePairs) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.dateValuePairs = dateValuePairs;
        currentInstance.numberValuePairs = numberValuePairs;
        currentInstance.userInteractionBase.chartStartMove = false;
        currentInstance.tooltipOptions(tooltip, tooltipOptions);
        currentInstance.zoomBase.axisCollections = axes;
        if (sf.base.isNullOrUndefined(currentInstance.userInteractionBase.visibleSeries)) {
          currentInstance.getVisibleSeries(currentInstance, clipRects, seriesMarkers, seriesBorders, axes);
        }
        currentInstance.userInteractionBase.chartStartMove = true;
        if (currentInstance.zoomBase.isResized && currentInstance.zoomBase.zoomingModule) {
          currentInstance.zoomBase.isResized = false;
          this.updateClipRect(this.getElement(currentInstance.element.id + currentInstance.zoomBase.clipRectId), currentInstance);
        }
      }
    },
    setZoomOptions: function setZoomOptions(dataId, chartZoomSettings) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chart)) {
        var theme = chart.userInteractionBase.theme;
        chart.zoomBase.zoomSettings = chartZoomSettings;
        chart.zoomBase.zoomingModule = new IZoom(chart);
        chart.zoomToolkitBase.selectionColor = theme == 'Material3Dark' ? "#CAC4D0" : theme == 'Material3' ? "#49454E" : theme == 'Bootstrap5' || theme == 'Bootstrap5Dark' ? '#0D6EFD' : theme == 'Tailwind' ? '#4F46E5' : theme == 'TailwindDark' ? '#22D3EE' : theme == 'Material' ? '#E3165B' : theme == 'MaterialDark' ? '#00B0FF' : theme == 'Bootstrap4' ? '#007BFF' : theme == 'Fluent' || theme == 'FluentDark' ? '#0078D4' : theme == 'Bootstrap' ? '#317AB9' : theme == 'BootstrapDark' ? '#0070F0' : theme == 'Fabric' ? '#0078D6' : theme == 'FabricDark' ? '#0074CC' : theme == 'HighContrast' || theme == 'HighContrastLight' ? '#FFD939' : chart.zoomToolkitBase.selectionColor;
        chart.zoomToolkitBase.iconRectOverFill = theme == 'Bootstrap4' ? '#5A6268' : theme == 'Material3' ? '#EADDFF' : theme == 'Material3Dark' ? '#4F378B' : chart.zoomToolkitBase.iconRectOverFill;
        chart.zoomToolkitBase.iconRectSelectionFill = theme == 'Bootstrap4' ? '#5B6269' : theme == 'Material3' ? '#EADDFF' : theme == 'Material3Dark' ? '#4F378B' : chart.zoomToolkitBase.iconRectSelectionFill;
        chart.zoomToolkitBase.selectedId = chart.zoomBase.zoomingModule.isPanning ? chart.element.id + '_Zooming_Pan_1' : chart.element.id + '_Zooming_Zoom_1';
        chart.zoomToolkitBase.fillColor = theme == 'Bootstrap4' ? '#495057' : theme == 'Tailwind' ? '#6B7280' : theme == 'TailwindDark' ? 'D1D5DB' : theme == 'Fluent' ? '#A19F9D' : theme == 'FluentDark' ? '#484644' : '#737373';
        if (!this.getElement(chart.element.id + chart.zoomBase.clipRectId) && chart.zoomBase.zoomingModule) {
          this.createClipRect(chart);
        }
        this.applyZoomingToolkit(chart);
      }
    },
    setUIBooleanValues: function setUIBooleanValues(dataId, isPointMouseDown, disableTrackTooltip, isPointDragging) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.userInteractionBase.isPointDragging = isPointDragging;
        currentInstance.userInteractionBase.isPointMouseDown = isPointMouseDown;
        currentInstance.userInteractionBase.disableTrackTooltip = disableTrackTooltip;
      }
    },
    setTooltipArgsData: function setTooltipArgsData(dataId, header, textCollection) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.tooltipBase.formattedText = [];
        currentInstance.tooltipBase.argsData.headerText = header;
        currentInstance.tooltipBase.argsData.text = textCollection;
        this.seriesTooltip(currentInstance, currentInstance.tooltipBase.currentPoints[0], true);
      }
    },
    setSharedTooltipArgsData: function setSharedTooltipArgsData(dataId, header, textCollection) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.tooltipBase.sharedArgsData.headerText = header;
        currentInstance.tooltipBase.sharedArgsData.text = textCollection;
        this.groupedTooltip(currentInstance, currentInstance.tooltipBase.currentPoints, true, currentInstance.tooltipBase.lastData);
      }
    },
    invokeBlurEffect: function invokeBlurEffect(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chart)) {
        this.blurEffect(chart.element.id, chart);
      }
    },
    invokeRemoveSelectedElements: function invokeRemoveSelectedElements(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chart)) {
        chart.selectedDataIndexes = [];
        chart.styleId = chart.element.id + '_ej2_chart_selection';
        this.removeSelectedElements(dataId);
      }
    },
    redrawSelection: function redrawSelection(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      chart.isSeriesMode = chart.oldMode == "Series";
      var chartSelectedDatas = chart.selectedDataIndexes;
      var charthighlightedDatas = chart.highlightDataIndexes;
      if (chart.styleId.indexOf("highlight") > -1 && chart.highlightDataIndexes.length > 0) {
        chart.highlightDataIndexes = [];
        this.removeSelectedElements(dataId);
        chartSelectedDatas = charthighlightedDatas;
      } else {
        chart.selectedDataIndexes = [];
        this.removeSelectedElements(dataId);
      }
      this.blurEffect(chart.element.id, chart);
      this.selectDataIndex(chart.dataId, chartSelectedDatas);
    },
    removeSelectionStyles: function removeSelectionStyles(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      chart.highlightDataIndexes = [];
      for (var i = 0; i < chart.seriesTypes.length; i++) {
        this.removeLegendSelectionClass(document.getElementsByClassName(chart.unSelected), chart);
        this.removeLegendSelectionClass(document.getElementsByClassName(this.generateStyle(chart.element.id + 'SeriesGroup' + i, chart)), chart);
        this.removeLegendSelectionClass(this.getSeriesElements(i, chart), chart);
      }
      for (var i = 0; i < chart.seriesTypes.length; i++) {
        this.removeSvgClass(this.findDOMElement(chart.element.id + '_chart_legend_shape_' + i), this.findDOMElement(chart.element.id + '_chart_legend_shape_' + i).getAttribute("class"));
      }
    },
    removeLegendSelectionClass: function removeLegendSelectionClass(elements, chart) {
      for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (!sf.base.isNullOrUndefined(element)) {
          this.removeSvgClass(element, element.getAttribute("class"));
          if (!sf.base.isNullOrUndefined(chart.highlightColor) && chart.highlightPattern == 'None') {
            element.setAttribute('fill', chart.highlightColor);
          }
        }
      }
    },
    removeSelectedElements: function removeSelectedElements(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      for (var i = 0; i < chart.seriesTypes.length; i++) {
        this.removeStyles(this.getSeriesElements(i, chart), chart);
      }
    },
    selectionChart: function selectionChart(dataId, index) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(chart)) {
        chart.currentMode = chart.selectionMode;
        chart.styleId = chart.element.id + '_ej2_chart_selection';
        this.selection(chart, index, this.findElements(chart, '', index));
      }
    },
    selectDataIndex: function selectDataIndex(dataId, chartSelectedDatas) {
      var _this = this;
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (sf.base.isNullOrUndefined(currentInstance)) {
        return;
      }
      this.isAlreadySelected({
        type: "click"
      }, currentInstance);
      chartSelectedDatas.forEach(function (selectedIndex) {
        var query = "#" + currentInstance.element.id + "_Series_" + selectedIndex.series + "_Point_" + selectedIndex.point;
        _this.performSelection(selectedIndex, currentInstance, currentInstance.element.querySelector(query));
      });
    },
    focusTarget: function focusTarget(id) {
      var element;
      var className;
      if (id.indexOf("_chart_legend_") > -1) {
        element = this.getElement(id).parentElement;
        className = element.getAttribute("class");
        this.setTabIndex(this.getElement(this.id + "_chart_legend_translate_g").firstElementChild, this.getElement(this.id + "SeriesCollection").firstElementChild);
        element.setAttribute("tabindex", "0");
        if (className && className.indexOf("e-chart-focused") === -1) {
          className = className + " e-chart-focused";
        } else if (!className) {
          className = "e-chart-focused";
        }
      } else {
        element = this.getElement(id);
        className = "e-chart-focused";
      }
      element.setAttribute("tabindex", "0");
      element.setAttribute("class", className);
      element.focus();
    },
    focusChild: function focusChild(element) {
      element.setAttribute("tabindex", "0");
      var className = element.getAttribute("class");
      element.setAttribute("tabindex", "0");
      if (className && className.indexOf("e-chart-focused") === -1) {
        className = className + " e-chart-focused";
      } else if (!className) {
        className = "e-chart-focused";
      }
      element.setAttribute("class", className);
      element.focus();
      return element.id;
    },
    getActualIndex: function getActualIndex(index, totalLength) {
      return index > totalLength - 1 ? 0 : index < 0 ? totalLength - 1 : index;
    },
    setTabIndex: function setTabIndex(previousElement, currentElement) {
      if (previousElement) {
        previousElement.removeAttribute("tabindex");
      }
      if (currentElement) {
        currentElement.setAttribute("tabindex", "0");
      }
    },
    eventInterval: 80,
    dotnetref: {},
    getScrollEventArgs: function getScrollEventArgs(e, chartIds) {
      var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
      var mouseXY = this.setScrollMouseXY(clientX, clientY, e.target['id'], chartIds);
      var touches = e.touches; //pointerId
      var touchList = [];
      if (e.type.indexOf('touch') > -1) {
        for (var i = 0, length_2 = touches.length; i < length_2; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: e.pointerId || 0
          });
        }
      }
      var id = e.target.id;
      id = id.indexOf('scrollBar') > -1 ? id : this.svgId;
      return {
        type: e.type,
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: mouseXY.mouseX,
        mouseY: mouseXY.mouseY,
        pointerType: e.pointerType,
        target: id,
        changedTouches: {
          clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
          clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
        },
        touches: touchList,
        pointerId: e.pointerId
      };
    },
    getScrollWheelArgs: function getScrollWheelArgs(e) {
      // Need to svg id for scrollbar
      // const mouseXY: { mouseX: number, mouseY: number } = this.setScrollMouseXY(e.clientX, e.clientY, e.currentTarget['id'], ["",""]);
      // return {
      //     detail: e.detail,
      //     wheelDelta: e['wheelDelta'],
      //     target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
      //     clientX: e.clientX,
      //     clientY: e.clientY,
      //     mouseX: mouseXY.mouseX,
      //     mouseY: mouseXY.mouseY,
      //     browserName: Browser.info.name,
      //     isPointer: Browser.isPointer
      // };
    },
    svgId: null,
    setScrollMouseXY: function setScrollMouseXY(pageX, pageY, id, chartIds) {
      this.svgId = chartIds[1];
      var chartId = chartIds[0];
      this.dotnetref = this.dotnetrefCollection.find(function (item) {
        return chartId === item.id;
      }).dotnetref;
      var mouseX = pageX;
      var mouseY = pageY;
      var svgElement = this.getElement(this.svgId);
      if (!sf.base.isNullOrUndefined(svgElement)) {
        var svgRect = svgElement.getBoundingClientRect();
        mouseX = pageX - Math.max(svgRect.left, 0);
        mouseY = pageY - Math.max(svgRect.top, 0);
      }
      return {
        mouseX: mouseX,
        mouseY: mouseY
      };
    },
    dotnetrefCollection: [],
    tooltipMousemovehandler: function tooltipMousemovehandler(chart) {
      if (chart.userInteractionBase.isPointMouseDown) {
        this.removeTooltip(chart.tooltipBase.tooltipModule.fadeOutDuration, chart);
        return;
      }
      if (!chart.userInteractionBase.disableTrackTooltip && !this.isSelected() && chart.tooltipBase.tooltipModule.enable) {
        if (!chart.tooltipBase.tooltipModule.shared && (!chart.isTouch || chart.userInteractionBase.startMove) || sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect) && chart.tooltipBase.tooltipModule.shared && (!chart.isTouch || chart.userInteractionBase.startMove)) {
          this.tooltip(chart);
        } else if (chart.tooltipBase.tooltipModule.shared && chart.tooltipBase.isSharedRemove) {
          this.removeTooltip(chart.tooltipBase.tooltipModule.fadeOutDuration, chart);
        }
      }
    },
    markerMove: function markerMove(chart, remove$$1) {
      var _this = this;
      if (chart.userInteractionBase.isPointMouseDown) {
        this.removeMarker(chart);
        return;
      }
      var data;
      var explodeSeries;
      var series;
      if (!chart.userInteractionBase.disableTrackTooltip && (!chart.isTouch || chart.userInteractionBase.startMove)) {
        if (!chart.tooltipBase.tooltipModule.shared || !chart.tooltipBase.tooltipModule.enable) {
          data = this.getData(chart);
          series = data.series;
          if (series && series.marker.aH) {
            var previous = chart.markerExplodeBase.markerPreviousPoints.length > 0 ? chart.markerExplodeBase.markerPreviousPoints[0] : null;
            explodeSeries = !sf.base.isNullOrUndefined(series) && (series.type == "Bubble" || series.drawType == "Scatter" || series.type == "Scatter" || series.type != "Candle" && series.type != "Hilo" && series.type != "HiloOpenClose" && series.marker.vS && series.marker.mW != 0 && series.marker.mH != 0);
            data.lierIndex = chart.userInteractionBase.lierIndex;
            if (data.point && explodeSeries && (previous == null || previous.point != data.point || previous.lierIndex > 3 && previous.lierIndex != chart.userInteractionBase.lierIndex)) {
              chart.markerExplodeBase.markerCurrentPoints.push(data);
            }
            if (data.point && explodeSeries && chart.userInteractionBase.isPointMouseDown) {
              chart.markerExplodeBase.markerCurrentPoints.push(data);
            }
          }
        } else {
          if (!sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect)) {
            return;
          }
          if (chart.tooltipBase.tooltipModule.enable) {
            var pointData = chart.userInteractionBase.chartAreaType == "PolarAxes" ? this.getData(chart) : null;
            for (var _i = 0, _a = chart.userInteractionBase.visibleSeries; _i < _a.length; _i++) {
              var series_1 = _a[_i];
              if (!series_1.enableTooltip || series_1.category == "Indicator" || !series_1.visible || !series_1.marker.aH) {
                continue;
              }
              if (chart.userInteractionBase.chartAreaType == "CartesianAxes" && series_1.visible) {
                data = this.getClosestX(chart, series_1);
              } else if (chart.userInteractionBase.chartAreaType == "PolarAxes" && series_1.visible && pointData.point) {
                data = {
                  point: series_1.points[pointData.point.iX],
                  series: series_1
                };
              }
              if (data && !sf.base.isNullOrUndefined(data.point)) {
                if (this.isSeriesAxisZoomed(series_1)) {
                  if (!data.point.s.length || this.isPointInRect(data.point.s, chart.userInteractionBase.axisClipRect)) {
                    chart.markerExplodeBase.markerCurrentPoints.push(data);
                  }
                } else {
                  chart.markerExplodeBase.markerCurrentPoints.push(data);
                }
              }
            }
            chart.markerExplodeBase.markerCurrentPoints = this.getSharedPoints(chart, chart.markerExplodeBase.markerCurrentPoints);
          }
        }
        if (chart.markerExplodeBase.markerCurrentPoints.length > 0) {
          if (chart.markerExplodeBase.markerPreviousPoints.length == 0 || chart.userInteractionBase.isPointMouseDown || chart.markerExplodeBase.markerPreviousPoints.length > 0 && (chart.tooltipBase.tooltipModule.showNearestPoint && chart.tooltipBase.tooltipModule.shared || chart.markerExplodeBase.markerPreviousPoints[0].point != chart.markerExplodeBase.markerCurrentPoints[0].point)) {
            if (chart.markerExplodeBase.markerPreviousPoints.length > 0) {
              this.removeMarker(chart);
            }
            for (var i = 0; i < chart.markerExplodeBase.markerCurrentPoints.length; i++) {
              var pointData = chart.markerExplodeBase.markerCurrentPoints[i];
              var pointDataSeries = pointData.series;
              var point = pointData.point;
              point.mK = point.mK ? point.mK : {
                vS: false
              };
              if (pointData && point || series && series.type != 'Candle' && series.type != 'Hilo' && series.type != 'HiloOpenClose') {
                window.clearTimeout(chart.markerExplodeBase.markerExplodeInterval);
                chart.markerExplodeBase.isRemove = true;
                for (var j = 0; j < point.s.length; j++) {
                  if (!this.isRectSeries(pointDataSeries.type) || point.mK.vS) {
                    this.trackBall(chart, pointDataSeries, point, point.s[j], j);
                  }
                }
              }
            }
            chart.markerExplodeBase.markerPreviousPoints = [];
            chart.markerExplodeBase.markerPreviousPoints = chart.markerExplodeBase.markerPreviousPoints.concat(chart.markerExplodeBase.markerCurrentPoints);
          }
        }
        if (!chart.tooltipBase.tooltipModule.enable && (chart.markerExplodeBase.markerCurrentPoints.length == 0 && chart.markerExplodeBase.isRemove || remove$$1 && chart.markerExplodeBase.isRemove || chart.userInteractionBase.axisClipRect && !sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect))) {
          chart.markerExplodeBase.isRemove = false;
          chart.markerExplodeBase.markerExplodeInterval = +setTimeout(function () {
            _this.removeMarker(chart);
          }, 2000);
        }
      }
      chart.markerExplodeBase.markerCurrentPoints = [];
    },
    trackBall: function trackBall(chart, series, point, location, index, explodeSeries) {
      var marker = point.mK;
      var seriesMarker = series.marker;
      var symbolId = chart.element.id + '_Series_' + series.index + '_Point_' + point.iX + '_Trackball' + (index && index != 0 ? '_' + index : '');
      var size = {
        width: (marker.mW ? marker.mW : seriesMarker.mW) + 3,
        height: (marker.mH ? marker.mH : seriesMarker.mH) + 3
      };
      var border = marker.b || series.border;
      var borderShadow = border.cL && border.cL != 'transparent' ? border.cL : marker.f ? marker.f : point.i ? point.i : series.interior;
      var borderColor = this.convertHexToColor(this.colorNameToHex(borderShadow));
      var borderWidth = marker.b ? marker.b.wT : seriesMarker.b.wT;
      var markerShadow = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + '0.2)';
      var transform = chart.userInteractionBase.chartAreaType == 'CartesianAxes' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';
      var clipPath = series.type == 'Bubble' || series.type == 'Scatter' ? 'url(#' + chart.clipPathID(series.index) + ')' : 'url(#' + chart.markerClipPathId(series.index) + ')';
      var shape = marker.sH ? marker.sH : seriesMarker.sH;
      for (var i = 0; i < 2; i++) {
        var options = new sf.svgbase.PathOption(symbolId + '_' + i, i > 0 ? marker.f || point.i || (explodeSeries ? series.interior : '#ffffff') : 'transparent', borderWidth + (i > 0 ? 0 : 8), i > 0 ? borderShadow : markerShadow, marker.oP || seriesMarker.oP, "", null);
        var shapeOption = this.calculateShapes(location, size, shape, options, seriesMarker.iU, false);
        this.drawTrackBall(chart.element.id + "_svg", shapeOption.renderOption, shapeOption.functionName, chart.markerExplodeBase.trackBallClass, clipPath, transform);
      }
    },
    colorNameToHex: function colorNameToHex(color) {
      color = color === 'transparent' ? 'white' : color;
      document.body.appendChild(sf.base.createElement('text', {
        id: 'chartmeasuretext'
      }));
      var element = document.getElementById('chartmeasuretext');
      element.style.color = color;
      color = window.getComputedStyle(element).color;
      sf.base.remove(element);
      var exp = /^(rgb|hsl)(a?)[(]\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*,\s*([\d.]+\s*%?)\s*(?:,\s*([\d.]+)\s*)?[)]$/;
      var isRGBValue = exp.exec(color);
      return this.convertToHexCode(new IColorValue(parseInt(isRGBValue[3], 10), parseInt(isRGBValue[4], 10), parseInt(isRGBValue[5], 10)));
    },
    convertToHexCode: function convertToHexCode(value) {
      return '#' + this.componentToHex(value.r) + this.componentToHex(value.g) + this.componentToHex(value.b);
    },
    componentToHex: function componentToHex(value) {
      var hex = value.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    },
    convertHexToColor: function convertHexToColor(hex) {
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? new IColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : new IColorValue(255, 255, 255);
    },
    calculateShapes: function calculateShapes(location, size, shape, options, url, isChart) {
      var dir;
      var functionName = 'path';
      var isBulletChart = isChart;
      var width = isBulletChart && shape === 'Circle' ? size.width - 2 : size.width;
      var height = isBulletChart && shape === 'Circle' ? size.height - 2 : size.height;
      var sizeBullet = 0;
      var lx = location.x;
      var ly = location.y;
      var y = location.y + -height / 2;
      var x = location.x + -width / 2;
      var eq = 72;
      var xVal;
      var yVal;
      switch (shape) {
        case 'Bubble':
        case 'Circle':
          functionName = 'ellipse';
          sf.base.merge(options, {
            'd': "",
            'rx': width / 2,
            'ry': height / 2,
            'cx': lx,
            'cy': ly
          });
          break;
        case 'Cross':
          dir = 'M' + ' ' + x + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'M' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2);
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Multiply':
          dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' + (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);
          sf.base.merge(options, {
            'd': dir,
            stroke: options.fill
          });
          break;
        case 'HorizontalLine':
          dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly;
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'VerticalLine':
          dir = 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Diamond':
          dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + ly + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'ActualRect':
          dir = 'M' + ' ' + x + ' ' + (ly + -height / 8) + ' ' + 'L' + ' ' + (lx + sizeBullet) + ' ' + (ly + -height / 8) + ' ' + 'L' + ' ' + (lx + sizeBullet) + ' ' + (ly + height / 8) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 8) + ' ' + 'L' + ' ' + x + ' ' + (ly + -height / 8) + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'TargetRect':
          dir = 'M' + ' ' + (x + sizeBullet) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + sizeBullet / 2) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + sizeBullet / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (x + sizeBullet) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (x + sizeBullet) + ' ' + (ly + -height / 2) + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Rectangle':
        case 'Hilo':
        case 'HiloOpenClose':
        case 'Candle':
        case 'Waterfall':
        case 'BoxAndWhisker':
        case 'StepArea':
        case 'StackingStepArea':
        case 'Square':
        case 'Flag':
          dir = 'M' + ' ' + x + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + -height / 2) + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Pyramid':
        case 'Triangle':
          dir = 'M' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Funnel':
        case 'InvertedTriangle':
          dir = 'M' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx - width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' z';
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Pentagon':
          for (var i = 0; i <= 5; i++) {
            xVal = width / 2 * Math.cos(Math.PI / 180 * (i * eq));
            yVal = height / 2 * Math.sin(Math.PI / 180 * (i * eq));
            if (i === 0) {
              dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';
            } else {
              dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');
            }
          }
          dir = dir.concat('Z');
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Plus':
          dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);
          sf.base.merge(options, {
            'd': dir
          });
          break;
        case 'Image':
          functionName = 'Image';
          sf.base.merge(options, {
            'href': url,
            'height': height,
            'width': width,
            x: x,
            y: y
          });
          break;
      }
      return {
        renderOption: options,
        functionName: functionName
      };
    },
    removeMarker: function removeMarker(chart) {
      this.removeHighLightedMarker(chart);
      chart.markerExplodeBase.markerPreviousPoints = [];
    },
    crosshairMousemoveHandler: function crosshairMousemoveHandler(chart) {
      if (!chart.userInteractionBase.disableTrackTooltip && chart.crosshairBase.crosshair.enable) {
        if (sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect) && (!chart.isTouch || chart.userInteractionBase.startMove)) {
          this.createCrosshair(chart);
        } else {
          this.removeCrosshair(chart, 1000);
        }
      }
    },
    removeCrosshair: function removeCrosshair(chart, duration) {
      var crosshair = this.getElement(chart.element.id + '_UserInteraction');
      var axisGroup = this.getElement(chart.element.id + '_crosshair_axis');
      this.stopAnimation(chart.crosshairBase.crosshairInterval);
      if (!chart.userInteractionBase.isFirstRendered && crosshair && crosshair.getAttribute('opacity') !== '0') {
        chart.crosshairBase.crosshairInterval = +setTimeout(function () {
          new sf.base.Animation({}).animate(crosshair, {
            duration: 200,
            progress: function progress(args) {
              // crosshair.removeAttribute('e-animate');
              crosshair.style.animation = '';
              crosshair.setAttribute('opacity', (1 - args.timeStamp / args.duration).toString());
              if (axisGroup) {
                while (axisGroup.firstChild) {
                  axisGroup.removeChild(axisGroup.firstChild);
                }
              }
            },
            end: function end() {
              crosshair.setAttribute('opacity', '0');
              if (chart.tooltipBase.tooltipModule) {
                chart.tooltipBase.valueX = null;
                chart.tooltipBase.valueY = null;
              }
            }
          });
        }, duration);
      }
    },
    createCrosshair: function createCrosshair(chart) {
      var chartRect = chart.userInteractionBase.axisClipRect;
      var horizontalCross = '';
      var verticalCross = '';
      var options;
      var crosshair = chart.crosshairBase.crosshair;
      var crossGroup = document.getElementById(chart.element.id + '_UserInteraction');
      window.clearTimeout(chart.crosshairBase.crosshairInterval);
      if (chart.tooltipBase.tooltipModule.enable && !sf.svgbase.withInAreaBounds(chart.tooltipBase.valueX, chart.tooltipBase.valueY, chartRect)) {
        return;
      }
      chart.crosshairBase.crosshairX = chart.tooltipBase.tooltipModule.enable && !chart.userInteractionBase.isInverted ? chart.tooltipBase.valueX : chart.mouseX;
      chart.crosshairBase.crosshairY = chart.tooltipBase.tooltipModule.enable && chart.userInteractionBase.isInverted ? chart.tooltipBase.valueY : chart.mouseY;
      if (chart.userInteractionBase.isFirstRendered) {
        crossGroup.setAttribute('opacity', '1');
        crossGroup.setAttribute('style', 'pointer-events:none');
        chart.userInteractionBase.isFirstRendered = false;
      } else {
        crossGroup.setAttribute('opacity', '1');
      }
      if (crosshair.lineType === 'Both' || crosshair.lineType === 'Horizontal' || chart.userInteractionBase.axes[1].crosshairTooltip.enable) {
        horizontalCross += 'M ' + chartRect.x + ' ' + chart.crosshairBase.crosshairY + ' L ' + (chartRect.x + chartRect.width) + ' ' + chart.crosshairBase.crosshairY;
      }
      if (crosshair.lineType === 'Both' || crosshair.lineType === 'Vertical' || chart.userInteractionBase.axes[0].crosshairTooltip.enable) {
        verticalCross += 'M ' + chart.crosshairBase.crosshairX + ' ' + chartRect.y + ' L ' + chart.crosshairBase.crosshairX + ' ' + (chartRect.y + chartRect.height);
      }
      if (crossGroup.childNodes.length != 0) {
        options = new sf.svgbase.PathOption('_HorizontalLine', 'none', crosshair.line.width, crosshair.line.color || chart.crosshairBase.themeStyleCrosshairLine, null, crosshair.dashArray, horizontalCross);
        this.renderCrosshairLine(options, crossGroup.childNodes[0]);
        options = new sf.svgbase.PathOption('_VerticalLine', 'none', crosshair.line.width, crosshair.line.color || chart.crosshairBase.themeStyleCrosshairLine, null, crosshair.dashArray, verticalCross);
        var crosshairAxisArgs = {
          AxisInfo: []
        };
        this.renderCrosshairLine(options, crossGroup.childNodes[3]);
        this.renderAxisTooltip(chart, chartRect, crossGroup.childNodes[6], crosshairAxisArgs);
        if (chart.tooltipBase.crosshairMouseMoveEventCalled) {
          chart.dotnetref.invokeMethodAsync('OnCrosshairMove', crosshairAxisArgs);
        }
      }
    },
    renderAxisTooltip: function renderAxisTooltip(chart, chartRect, axisGroup, crosshairAxisArgs) {
      var axis;
      var axisInfo = {
        text: "",
        value: null
      };
      var rect;
      var pathElement;
      var textElem;
      var textOptions;
      var padding = 5;
      var direction;
      var axisRect;
      if (axisGroup) {
        while (axisGroup.firstChild) {
          axisGroup.removeChild(axisGroup.firstChild);
        }
      }
      for (var k = chart.userInteractionBase.axes.length - 1, length_3 = 0; k >= length_3; k--) {
        axis = chart.userInteractionBase.axes[k];
        axisRect = !axis.placeNextToAxisLine ? axis.rect : axis.updatedRect;
        if (axis.crosshairTooltip.enable) {
          if (chart.crosshairBase.crosshairX <= axisRect.x + axisRect.w && axisRect.x <= chart.crosshairBase.crosshairX && axisRect.w != 0 || chart.crosshairBase.crosshairY <= axisRect.y + axisRect.h && axisRect.y <= chart.crosshairBase.crosshairY && axisRect.h != 0) {
            pathElement = document.getElementById(chart.element.id + '_axis_tooltip_' + k);
            textElem = document.getElementById(chart.element.id + '_axis_tooltip_text_' + k);
            axisInfo = this.getAxisText(chart, axis);
            if (!axisInfo.text) {
              continue;
            }
            if (!sf.base.isNullOrUndefined(crosshairAxisArgs)) {
              crosshairAxisArgs.AxisInfo.push({
                AxisName: axis.name,
                AxisLabel: axisInfo.text,
                Value: axisInfo.value
              });
            }
            rect = this.tooltipLocation(chart, axisInfo.text, axis, chartRect, new sf.svgbase.Rect(axisRect.x, axisRect.y, axisRect.w, axisRect.h));
            if (pathElement === null) {
              pathElement = chart.userInteractionBase.svgRenderer.drawPath({
                'id': chart.element.id + '_axis_tooltip_' + k,
                'fill': axis.crosshairTooltip.fill || chart.crosshairBase.themeStyleCrosshairFill
              });
            }
            if (textElem) {
              this.removeElement(textElem.id);
            }
            axisGroup.appendChild(pathElement);
            textOptions = new sf.svgbase.TextOption(chart.element.id + '_axis_tooltip_text_' + k, 0, 0, 'start', axisInfo.text);
            var textStyle = {
              size: axis.crosshairTooltip.textStyle.size || chart.crosshairBase.themeStyleCrosshairTextSize,
              color: axis.crosshairTooltip.textStyle.color || chart.crosshairBase.themeStyleCrosshairLabel,
              fontFamily: axis.crosshairTooltip.textStyle.fontFamily || chart.crosshairBase.themeStyleCrosshairFontFamily,
              fontStyle: axis.crosshairTooltip.textStyle.fontStyle,
              fontWeight: axis.crosshairTooltip.textStyle.fontWeight || chart.crosshairBase.themeStyleCrosshairFontWeight,
              opacity: axis.crosshairTooltip.textStyle.opacity
            };
            textElem = sf.svgbase.textElement(textOptions, textStyle, textStyle.color, axisGroup);
            direction = this.findCrosshairDirection(chart.crosshairBase.rx, chart.crosshairBase.ry, rect, chart.crosshairBase.arrowLocation, 8, chart.crosshairBase.isTop, chart.crosshairBase.isBottom, chart.crosshairBase.isLeft, chart.crosshairBase.crosshairX, chart.crosshairBase.crosshairY);
            pathElement.setAttribute('d', direction);
            textElem.textContent = axisInfo.text;
            textElem.setAttribute('x', (rect.x + padding + (chart.userInteractionBase.enableRTL ? chart.crosshairBase.elementSize.width : 0)).toString());
            textElem.setAttribute('y', (rect.y + padding + 3 * chart.crosshairBase.elementSize.height / 4).toString());
            if (chart.userInteractionBase.theme === 'Fluent' || chart.userInteractionBase.theme === "FluentDark" || chart.userInteractionBase.theme === "Fabric") {
              pathElement.setAttribute('stroke', '#cccccc');
              pathElement.setAttribute('stroke-width', '0.5');
            }
          }
        }
      }
    },
    getAxisText: function getAxisText(chart, axis) {
      var pointValue;
      var axisInfo = {
        text: "",
        value: null
      };
      chart.crosshairBase.isBottom = false;
      chart.crosshairBase.isTop = false;
      chart.crosshairBase.isLeft = false;
      chart.crosshairBase.isRight = false;
      var labelValue = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;
      var isOpposed = axis.isAxisOppositePosition;
      if (axis.orientation === 'Horizontal') {
        pointValue = this.getValueByPoint(Math.abs(chart.crosshairBase.crosshairX - axis.rect.x), axis.rect.w, axis.orientation, axis.visibleRange, axis.isAxisInverse) + labelValue;
        chart.crosshairBase.isBottom = !isOpposed;
        chart.crosshairBase.isTop = isOpposed;
      } else {
        pointValue = this.getValueByPoint(Math.abs(chart.crosshairBase.crosshairY - axis.rect.y), axis.rect.h, axis.orientation, axis.visibleRange, axis.isAxisInverse) + labelValue;
        chart.crosshairBase.isRight = isOpposed;
        chart.crosshairBase.isLeft = !isOpposed;
      }
      if (axis.valueType === 'DateTime') {
        var dateText = new sf.base.Internationalization().getDateFormat({
          format: axis.format ? axis.format : axis.dateFormat,
          type: this.firstToLowerCase('DateTime')
        })(this.convertDateAndTime(new Date(pointValue)));
        axisInfo.text = this.getGlobalizedDate(dateText, chart.dateValuePairs);
        axisInfo.value = new Date(pointValue);
        return axisInfo;
      } else if (axis.valueType === 'Category') {
        axisInfo.text = pointValue < axis.labels.length ? axis.labels[Math.floor(pointValue)] : '';
        axisInfo.value = Math.floor(pointValue);
        return axisInfo;
      } else if (axis.valueType === 'DateTimeCategory') {
        axisInfo.text = this.getIndexedAxisLabel(axis.labels[Math.round(pointValue)], this.customFormat(axis, chart), chart.dateValuePairs);
        axisInfo.value = Math.floor(pointValue);
        return axisInfo;
      } else if (axis.valueType === 'Logarithmic') {
        var label = this.formatAxisValue(Math.pow(axis.logBase, pointValue), this.getaxisFormat(axis).indexOf('{value}') > -1, axis.labelFormat, void 0, chart);
        axisInfo.text = this.getGlobalizedNumber(label, chart.numberValuePairs);
        axisInfo.value = Number(Math.pow(axis.logBase, pointValue));
        return axisInfo;
      } else {
        var customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;
        var label = customLabelFormat ? axis.labelFormat.replace('{value}', this.formatAxisValue(pointValue, customLabelFormat, axis.labelFormat, 3, chart)) : this.formatAxisValue(pointValue, customLabelFormat, axis.labelFormat, 3, chart);
        axisInfo.text = this.getGlobalizedNumber(label, chart.numberValuePairs);
        axisInfo.value = pointValue;
        return axisInfo;
      }
    },
    convertDateAndTime: function convertDateAndTime(date) {
      var newDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
      return newDate;
    },
    getGlobalizedDate: function getGlobalizedDate(resultText, dateValuePairs) {
      Object.keys(dateValuePairs).forEach(function (Key) {
        resultText = resultText['replaceAll'] ? resultText['replaceAll'](Key, dateValuePairs[Key]) : resultText['replace'](Key, dateValuePairs[Key]);
      });
      return resultText;
    },
    getGlobalizedNumber: function getGlobalizedNumber(text, numberValuePairs) {
      var subStrings = text.split("");
      var numberKeys = Object.keys(numberValuePairs);
      for (var i = 0, textLength = text.length; i < textLength; i++) {
        for (var j = 0, keyLength = numberKeys.length; j < keyLength; j++) {
          if (subStrings[i] == numberKeys[j]) {
            subStrings.splice(i, 1, numberValuePairs[numberKeys[j]]);
            break;
          }
        }
      }
      return subStrings.join("");
    },
    firstToLowerCase: function firstToLowerCase(str) {
      return str.substr(0, 1).toLowerCase() + str.substr(1);
    },
    getaxisFormat: function getaxisFormat(axis) {
      if (axis.labelFormat) {
        if (axis.labelFormat.indexOf('p') == 0 && !(axis.labelFormat.indexOf('{value}') > -1) && axis.isStack100) {
          return '{value}%';
        }
        return axis.labelFormat;
      }
      return axis.isStack100 ? '{value}%' : "";
    },
    getIndexedAxisLabel: function getIndexedAxisLabel(value, format, dateValuePairs) {
      var texts = value.split(',');
      for (var i = 0; i < texts.length; i++) {
        texts[i] = this.getGlobalizedDate(new sf.base.Internationalization().getDateFormat({
          format: format
        })(this.convertDateAndTime(new Date(parseInt(texts[i], 10)))), dateValuePairs);
      }
      return texts.join(', ');
    },
    customFormat: function customFormat(axis, chart) {
      return !axis.labelFormat ? axis.actualIntervalType === 'Years' ? 'yyyy' : this.getSkeleton(axis, chart) : axis.labelFormat;
    },
    getSkeleton: function getSkeleton(axis, chart) {
      var intervalType = axis.rangeIntervalType;
      if (axis.format) {
        return axis.format;
      }
      if (intervalType === 'Years' || intervalType === 'Quarter') {
        return 'y';
      } else if (intervalType === 'Months' || intervalType === 'Weeks') {
        return chart.userInteractionBase.isStockChart && axis.valueType === 'DateTimeCategory' ? 'MMM d' : 'MMMM d';
      } else if (intervalType === 'Days') {
        return 'MM/dd/yyyy';
      } else if (intervalType === 'Hours') {
        return 'HH:mm tt';
      } else {
        return 'HH:mm:ss tt';
      }
    },
    tooltipLocation: function tooltipLocation(chart, text, axis, bounds, axisRect) {
      var arrowPadding = 8;
      var tooltipRect;
      var boundsX = bounds.x;
      var boundsY = bounds.y;
      var islabelInside = axis.labelPosition === 'Inside';
      var scrollBarHeight = axis.scrollbarSettingsEnable ? axis.scrollBarHeight : 0;
      var crosshairFont = axis.crosshairTooltip.textStyle;
      crosshairFont.size = crosshairFont.size || chart.crosshairBase.themeStyleCrosshairTextSize;
      crosshairFont.fontFamily = crosshairFont.fontFamily || chart.crosshairBase.themeStyleCrosshairFontFamily;
      crosshairFont.fontWeight = crosshairFont.fontWeight || chart.crosshairBase.themeStyleCrosshairFontWeight;
      chart.crosshairBase.elementSize = sf.svgbase.measureText(text, crosshairFont);
      var isOpposed = axis.isAxisOppositePosition;
      if (axis.orientation === 'Horizontal') {
        var yLocation = islabelInside ? axisRect.y - chart.crosshairBase.elementSize.height - 20 : axisRect.y + scrollBarHeight;
        var height = islabelInside ? axisRect.y - chart.crosshairBase.elementSize.height - 10 : axisRect.y + 10;
        chart.crosshairBase.arrowLocation = new IChartInternalLocation(chart.crosshairBase.crosshairX, yLocation);
        tooltipRect = new sf.svgbase.Rect(chart.crosshairBase.crosshairX - chart.crosshairBase.elementSize.width / 2 - 5, height + (!islabelInside ? scrollBarHeight : 0), chart.crosshairBase.elementSize.width + 10, chart.crosshairBase.elementSize.height + 10);
        if (isOpposed) {
          tooltipRect.y = islabelInside ? axisRect.y : axisRect.y - (chart.crosshairBase.elementSize.height + 20) - scrollBarHeight;
        }
        if (tooltipRect.x < boundsX) {
          tooltipRect.x = boundsX;
        }
        if (tooltipRect.x + tooltipRect.width > boundsX + bounds.width) {
          tooltipRect.x -= tooltipRect.x + tooltipRect.width - (boundsX + bounds.width);
        }
        if (chart.crosshairBase.arrowLocation.x + arrowPadding / 2 > tooltipRect.x + tooltipRect.width - chart.crosshairBase.rx) {
          chart.crosshairBase.arrowLocation.x = tooltipRect.x + tooltipRect.width - chart.crosshairBase.rx - arrowPadding;
        }
        if (chart.crosshairBase.arrowLocation.x - arrowPadding < tooltipRect.x + chart.crosshairBase.rx) {
          chart.crosshairBase.arrowLocation.x = tooltipRect.x + chart.crosshairBase.rx + arrowPadding;
        }
      } else {
        scrollBarHeight = scrollBarHeight * (isOpposed ? 1 : -1);
        chart.crosshairBase.arrowLocation = new IChartInternalLocation(axisRect.x, chart.crosshairBase.crosshairY);
        var width = islabelInside ? axisRect.x - scrollBarHeight : axisRect.x - chart.crosshairBase.elementSize.width - 20;
        tooltipRect = new sf.svgbase.Rect(width + scrollBarHeight, chart.crosshairBase.crosshairY - chart.crosshairBase.elementSize.height / 2 - 5, chart.crosshairBase.elementSize.width + 10, chart.crosshairBase.elementSize.height + 10);
        if (isOpposed) {
          tooltipRect.x = islabelInside ? axisRect.x - chart.crosshairBase.elementSize.width - arrowPadding : axisRect.x + arrowPadding + scrollBarHeight;
          if (tooltipRect.x + tooltipRect.width > chart.userInteractionBase.availableSize.width) {
            chart.crosshairBase.arrowLocation.x -= tooltipRect.x + tooltipRect.width - chart.userInteractionBase.availableSize.width;
            tooltipRect.x -= tooltipRect.x + tooltipRect.width - chart.userInteractionBase.availableSize.width;
          }
        } else {
          if (tooltipRect.x < 0) {
            chart.crosshairBase.arrowLocation.x -= tooltipRect.x;
            tooltipRect.x = 0;
          }
        }
        if (tooltipRect.y < boundsY) {
          tooltipRect.y = boundsY;
        }
        if (tooltipRect.y + tooltipRect.height >= boundsY + bounds.height) {
          tooltipRect.y -= tooltipRect.y + tooltipRect.height - (boundsY + bounds.height);
        }
        if (chart.crosshairBase.arrowLocation.y + arrowPadding / 2 > tooltipRect.y + tooltipRect.height - chart.crosshairBase.ry) {
          chart.crosshairBase.arrowLocation.y = tooltipRect.y + tooltipRect.height - chart.crosshairBase.ry - arrowPadding / 2;
        }
        if (chart.crosshairBase.arrowLocation.y - arrowPadding / 2 < tooltipRect.y + chart.crosshairBase.ry) {
          chart.crosshairBase.arrowLocation.y = tooltipRect.y + chart.crosshairBase.ry + arrowPadding / 2;
        }
      }
      return tooltipRect;
    },
    findCrosshairDirection: function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {
      var direction = '';
      var startX = rect.x;
      var startY = rect.y;
      var width = rect.x + rect.width;
      var height = rect.y + rect.height;
      if (top) {
        direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY);
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);
        if (arrowPadding !== 0) {
          direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + height);
          direction = direction.concat(' L' + ' ' + tipX + ' ' + (height + arrowPadding) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);
        }
        if (arrowLocation.x - arrowPadding / 2 > startX) {
          direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');
        } else {
          if (arrowPadding === 0) {
            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');
          } else {
            direction = direction.concat(' L' + ' ' + startX + ' ' + (height + rY) + ' z');
          }
        }
      } else if (bottom) {
        direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + startY);
        direction = direction.concat(' L' + ' ' + tipX + ' ' + arrowLocation.y);
        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + startY);
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);
        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');
      } else if (left) {
        direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY);
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY) + ' L' + ' ' + width + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + tipY);
        direction = direction.concat(' L' + ' ' + width + ' ' + (arrowLocation.y + arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);
        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');
      } else {
        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + startY + ' Q ' + startX + ' ' + startY + ' ' + startX + ' ' + (startY + rY) + ' L' + ' ' + startX + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + tipY);
        direction = direction.concat(' L' + ' ' + startX + ' ' + (arrowLocation.y + arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + startX + ' ' + (height - rY) + ' Q ' + startX + ' ' + height + ' ' + (startX + rX) + ' ' + height);
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + height + ' Q ' + width + ' ' + height + ' ' + width + ' ' + (height - rY));
        direction = direction.concat(' L' + ' ' + width + ' ' + (startY + rY) + ' Q ' + width + ' ' + startY + ' ' + (width - rX) + ' ' + startY + ' z');
      }
      return direction;
    },
    renderCrosshairLine: function renderCrosshairLine(options, childElement) {
      var keys = Object.keys(options);
      var key = '';
      for (var i = 0; i < keys.length; i++) {
        key = keys[i] === 'strokeWidth' ? 'stroke-width' : keys[i] === 'strokeDashArray' ? 'stroke-dashArray' : keys[i] === 'direction' ? 'd' : keys[i];
        if (key != 'id') {
          childElement.setAttribute(key, options[keys[i]]);
        }
      }
    },
    isSelected: function isSelected() {
      return false;
    },
    getTooltipElement: function getTooltipElement(chart) {
      chart.tooltipBase.header = chart.tooltipBase.tooltipModule.header === null ? chart.tooltipBase.tooltipModule.shared ? '<b>${point.x}</b>' : '<b>${series.name}</b>' : chart.getTooltipFormat(chart.tooltipBase.tooltipModule.header);
      chart.tooltipBase.formattedText = [];
    },
    findData: function findData(data, previous, lierIndex) {
      return data.point && (!previous || previous.point !== data.point || previous.lierIndex > 3 && previous.lierIndex != lierIndex || previous.point === data.point);
    },
    renderSeriesTooltip: function renderSeriesTooltip(isFirst, chart) {
      var data = this.getData(chart);
      data.lierIndex = chart.userInteractionBase.lierIndex;
      chart.tooltipBase.currentPoints = [];
      if (this.findData(data, chart.tooltipBase.previousPoints.length > 0 ? chart.tooltipBase.previousPoints[0] : null, chart.userInteractionBase.lierIndex)) {
        window.clearTimeout(chart.tooltipBase.toolTipInterval);
        if (!data.series.dataEditSettings && chart.tooltipBase.previousPoints[0] && data.point.iX === chart.tooltipBase.previousPoints[0].point.iX && data.series.index === chart.tooltipBase.previousPoints[0].series.index) {
          chart.tooltipBase.isRemove = true;
          return null;
        }
        if (this.pushData(data, chart)) {
          this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart), this.findHeader(data, chart), chart);
        } else {
          this.removeTooltip(chart.tooltipBase.tooltipModule.fadeOutDuration, chart);
        }
      } else {
        if (!data.point && chart.tooltipBase.isRemove) {
          this.removeTooltip(chart.tooltipBase.tooltipModule.fadeOutDuration, chart);
          chart.tooltipBase.isRemove = false;
        } else {
          for (var _i = 0, _a = chart.userInteractionBase.visibleSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.visible && !(series.category === 'TrendLine')) {
              data = this.getClosestX(chart, series) || data;
            }
          }
        }
      }
      if (data && data.point) {
        this.findMouseValue(data, chart);
      }
    },
    triggerTooltipRender: function triggerTooltipRender(point, isFirst, textCollection, headerText, chart) {
      chart.tooltipBase.argsData = {
        data: {
          pointX: point.point.x ? point.point.x.toString() : "",
          pointY: point.point.y ? point.point.y.toString() : "",
          seriesIndex: point.series.index,
          seriesName: point.series.name,
          pointIndex: point.point.iX,
          pointText: point.point.t
        },
        headerText: headerText,
        point: point.point,
        series: {},
        text: textCollection
      };
      if (chart.tooltipBase.tooltipEventCalled) {
        chart.dotnetref.invokeMethodAsync('TooltipEventTriggered', chart.tooltipBase.argsData);
      } else {
        this.seriesTooltip(chart, point, isFirst);
      }
    },
    seriesTooltip: function seriesTooltip(chart, point, isFirst) {
      var extraPoints = [];
      if (point != null) {
        if (point.series.type === 'BoxAndWhisker') {
          isFirst = true;
        }
        chart.tooltipBase.header = chart.tooltipBase.argsData.headerText;
        chart.tooltipBase.formattedText = chart.tooltipBase.formattedText.concat(chart.tooltipBase.argsData.text);
        var clipLocation = new IChartInternalLocation(point.series.clipRect.x, point.series.clipRect.y);
        if (chart.tooltipBase.tooltipModule.template != null && chart.tooltipBase.currentPoints.length > 0) {
          chart.tooltipBase.tooltipTempList = [];
          var pointsInfo = point.point;
          var tooltipTemp = {
            x: pointsInfo.x ? this.formatPointValue(pointsInfo, "x", true, false, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            y: pointsInfo.y ? this.formatPointValue(pointsInfo, "y", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            text: pointsInfo.t.toString(),
            high: pointsInfo.h ? this.formatPointValue(pointsInfo, "h", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            low: pointsInfo.l ? this.formatPointValue(pointsInfo, "l", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            open: pointsInfo.o ? this.formatPointValue(pointsInfo, "o", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            close: pointsInfo.c ? this.formatPointValue(pointsInfo, "c", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            volume: pointsInfo.v ? this.formatPointValue(pointsInfo, "v", false, true, point.series, chart.userInteractionBase.isStockChart, chart) : "",
            pointX: pointsInfo.x ? pointsInfo.x.toString() : "",
            pointY: pointsInfo.y ? pointsInfo.y.toString() : "",
            seriesIndex: point.series.index,
            seriesName: point.series.name,
            pointIndex: point.point.iX,
            pointText: point.point.t
          };
          chart.tooltipBase.tooltipTempList.push(tooltipTemp);
          var symbolLocation = this.getSymbolLocation(point, chart);
          var isRectSeries = this.isRectSeries(point.series.type);
          var isNegative = isRectSeries && point.series.type != 'Waterfall' && point.point && parseInt(pointsInfo.y ? pointsInfo.y.toString() : "") < 0;
          var inverted = chart.userInteractionBase.isInverted && isNegative;
          var templateLocation = this.getTemplateLocation(chart.userInteractionBase.axisClipRect, symbolLocation, chart.tooltipBase.tooltipElementSize.width, chart.tooltipBase.tooltipElementSize.height, this.findMarkerHeight(chart.tooltipBase.currentPoints[0], chart), clipLocation, inverted, isNegative);
          var padding = 40;
          templateLocation.x = templateLocation.x > chart.userInteractionBase.axisClipRect.width ? chart.userInteractionBase.axisClipRect.width - padding : templateLocation.x;
          chart.dotnetref.invokeMethodAsync('SetTooltipTemplateElementSizeAsync', templateLocation.x, templateLocation.y, chart.tooltipBase.tooltipTempList);
          this.removeHighlight(chart);
          this.highlightPoints(chart);
          this.updatePreviousPoint(chart, extraPoints);
        } else {
          var borderWidth = chart.userInteractionBase.chartBorderWidth;
          var padding = 3;
          this.createTooltipRenderer(chart, isFirst, this.getSymbolLocation(point, chart), clipLocation, point.point, this.findShapes(chart), this.findMarkerHeight(chart.tooltipBase.currentPoints[0], chart), new sf.svgbase.Rect(borderWidth, borderWidth, chart.userInteractionBase.availableSize.width - padding - borderWidth * 2, chart.userInteractionBase.availableSize.height - padding - borderWidth * 2), chart.crosshairBase.crosshair.enable, extraPoints, null, "");
        }
      } else {
        this.removeHighlight(chart);
      }
      chart.tooltipBase.isRemove = true;
    },
    groupedTooltip: function groupedTooltip(chart, pointsInfo, isFirst, lastData) {
      var extraPoints = [];
      var data = pointsInfo[pointsInfo.length - 1];
      if (lastData != null && chart.tooltipBase.currentPoints.length > 0) {
        var extraPoints_1 = [];
        chart.tooltipBase.header = chart.tooltipBase.sharedArgsData.headerText;
        chart.tooltipBase.formattedText = chart.tooltipBase.sharedArgsData.text;
        this.findMouseValue(lastData, chart);
        var clipLocation = chart.tooltipBase.currentPoints.length == 1 ? new IChartInternalLocation(chart.tooltipBase.currentPoints[0].series.clipRect.x, chart.tooltipBase.currentPoints[0].series.clipRect.y) : new IChartInternalLocation(0, 0);
        if (chart.tooltipBase.tooltipModule.template != null && chart.tooltipBase.currentPoints.length > 0) {
          chart.tooltipBase.tooltipTempList = [];
          for (var i = 0; i < pointsInfo.length; i++) {
            var point = pointsInfo[i].point;
            var tooltipTemp = {
              x: point.x ? this.formatPointValue(point, "x", true, false, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              y: point.y ? this.formatPointValue(point, "y", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              text: point.t.toString(),
              high: point.h ? this.formatPointValue(point, "h", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              low: point.l ? this.formatPointValue(point, "l", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              open: point.o ? this.formatPointValue(point, "o", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              close: point.c ? this.formatPointValue(point, "c", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              volume: point.v ? this.formatPointValue(point, "v", false, true, pointsInfo[i].series, chart.userInteractionBase.isStockChart, chart) : "",
              pointX: point.x ? point.x.toString() : "",
              pointY: point.y ? point.y.toString() : "",
              seriesIndex: pointsInfo[i].series.index,
              seriesName: pointsInfo[i].series.name,
              pointIndex: pointsInfo[i].point.iX,
              pointText: pointsInfo[i].point.t
            };
            chart.tooltipBase.tooltipTempList.push(tooltipTemp);
          }
          var symbolLocation = this.findSharedLocation(chart);
          var series = chart.tooltipBase.currentPoints[0].series;
          var isRectSeries = this.isRectSeries(series.type);
          var isNegative = isRectSeries && series.type != 'Waterfall' && data.point && parseInt(data.point.y ? data.point.y.toString() : "") < 0;
          var inverted = chart.userInteractionBase.isInverted && isNegative;
          var templateLocation = this.getTemplateLocation(chart.userInteractionBase.axisClipRect, symbolLocation, 0, 0, this.findMarkerHeight(chart.tooltipBase.currentPoints[0], chart), clipLocation, inverted, isNegative);
          chart.dotnetref.invokeMethodAsync('SetTooltipTemplateElementSizeAsync', templateLocation.x, templateLocation.y, chart.tooltipBase.tooltipTempList);
          this.setTooltipTemplateElementSize(chart, symbolLocation, clipLocation, inverted, isNegative);
          this.removeHighlight(chart);
          this.highlightPoints(chart);
          this.updatePreviousPoint(chart, extraPoints_1);
        } else {
          var padding = 3;
          var borderWidth = chart.userInteractionBase.chartBorderWidth;
          this.createTooltipRenderer(chart, isFirst, this.findSharedLocation(chart), clipLocation, lastData.point, this.findShapes(chart), this.findMarkerHeight(chart.tooltipBase.currentPoints[0], chart), new sf.svgbase.Rect(borderWidth, borderWidth, chart.userInteractionBase.availableSize.width - padding - borderWidth * 2, chart.userInteractionBase.availableSize.height - padding - borderWidth * 2), chart.crosshairBase.crosshair.enable, extraPoints_1, null, "");
        }
      } else {
        extraPoints.push(data);
      }
      chart.tooltipBase.isSharedRemove = true;
    },
    setTooltipTemplateElementSize: function setTooltipTemplateElementSize(chart, symbolLocation, clipLocation, inverted, isNegative) {
      var elementSize = this.getTemplateSize(chart.element.id + '_tooltip');
      if (elementSize && chart.tooltipBase.currentPoints.length > 0) {
        var templateLocation = this.getTemplateLocation(chart.userInteractionBase.axisClipRect, symbolLocation, elementSize.width, elementSize.height, this.findMarkerHeight(chart.tooltipBase.currentPoints[0], chart), clipLocation, inverted, isNegative);
        templateLocation.x += chart.userInteractionBase.secondaryElementOffset.left;
        templateLocation.y += chart.userInteractionBase.secondaryElementOffset.top;
        var tooltipElement = document.getElementById(chart.element.id + '_tooltip');
        tooltipElement.setAttribute('style', 'top:' + templateLocation.y.toString() + 'px;left:' + templateLocation.x.toString() + 'px;pointer-events:none; position:absolute;z-index: 1;visibility: visible' + ';');
      }
    },
    isPointInRect: function isPointInRect(symbolLocation, axisClipRect) {
      var isPointIn;
      for (var _i = 0, symbolLocation_1 = symbolLocation; _i < symbolLocation_1.length; _i++) {
        var loc = symbolLocation_1[_i];
        if (sf.svgbase.withInAreaBounds(loc.x + axisClipRect.x, loc.y + axisClipRect.y, axisClipRect)) {
          isPointIn = true;
        } else if (sf.svgbase.withInAreaBounds(loc.x - axisClipRect.x, loc.y - axisClipRect.y, axisClipRect)) {
          isPointIn = true;
        } else {
          isPointIn = false;
        }
      }
      return isPointIn;
    },
    pushData: function pushData(data, chart) {
      if (data.series.enableTooltip) {
        if (chart != null) {
          chart.tooltipBase.currentPoints.push(data);
        }
        return true;
      }
      return false;
    },
    renderGroupedTooltip: function renderGroupedTooltip(isFirst, chart) {
      var _this = this;
      var data, lastData;
      var pointData = chart.userInteractionBase.chartAreaType === "PolarAxes" ? this.getData(chart) : null;
      this.stopAnimation(chart.tooltipBase.toolTipInterval);
      chart.tooltipBase.currentPoints = [];
      var pointsInfo = [];
      var text = [];
      var header;
      var argsData = [];
      var argsPoint;
      for (var i = 0; i < chart.userInteractionBase.visibleSeries.length; i++) {
        var series = chart.userInteractionBase.visibleSeries[i];
        if (!series.enableTooltip || !series.visible || series.points.length == 0) {
          continue;
        }
        if (chart.userInteractionBase.chartAreaType == "CartesianAxes" && series.visible && series.points.length > 0) {
          data = this.getClosestX(chart, series);
        } else if (chart.userInteractionBase.chartAreaType === "PolarAxes" && series.visible && pointData.point != null) {
          data = {
            point: series.points[pointData.point.iX],
            series: series
          };
        }
        if (data != null && data.point) {
          pointsInfo.push(data);
        }
      }
      pointsInfo = this.getSharedPoints(chart, pointsInfo);
      pointsInfo = this.sortPointsInfo(pointsInfo);
      var closestValue = Number.MAX_VALUE;
      var pointValue;
      var tempData;
      pointsInfo.forEach(function (dataPoint) {
        argsPoint = {
          pointX: dataPoint.point.x ? dataPoint.point.x.toString() : "",
          pointY: dataPoint.point.y ? dataPoint.point.y.toString() : "",
          seriesIndex: dataPoint.series.index,
          seriesName: dataPoint.series.name,
          pointIndex: dataPoint.point.iX,
          pointText: dataPoint.point.t
        };
        argsData.push(argsPoint);
        header = _this.findHeader(dataPoint, chart);
        chart.tooltipBase.currentPoints.push(dataPoint);
        text.push(_this.getTooltipText(dataPoint, chart));
        pointValue = !chart.userInteractionBase.isInverted ? chart.mouseX - dataPoint.series.clipRect.x : chart.mouseY - dataPoint.series.clipRect.y;
        if (dataPoint.point.s.length && Math.abs(pointValue - dataPoint.point.s[0].x) < closestValue) {
          if (_this.isSeriesAxisZoomed(dataPoint.series)) {
            if (!dataPoint.point.s.length || _this.isPointInRect(dataPoint.point.s, chart.userInteractionBase.axisClipRect)) {
              closestValue = Math.abs(pointValue - dataPoint.point.s[0].x);
              tempData = dataPoint;
            }
          } else {
            closestValue = Math.abs(pointValue - dataPoint.point.s[0].x);
            tempData = dataPoint;
          }
        }
        lastData = chart.tooltipBase.lastData = dataPoint.series.category === "TrendLine" && chart.tooltipBase.tooltipModule.shared ? lastData : tempData || lastData;
      });
      if (chart.userInteractionBase.isStockChart) {
        text.push('');
      }
      chart.tooltipBase.sharedArgsData = {
        headerText: header,
        text: text,
        data: argsData
      };
      if (chart.tooltipBase.sharedTooltipEventCalled) {
        chart.dotnetref.invokeMethodAsync('SharedTooltipEventTriggered', chart.tooltipBase.sharedArgsData);
      } else {
        this.groupedTooltip(chart, pointsInfo, isFirst, lastData);
      }
    },
    createTooltipRenderer: function createTooltipRenderer(chart, isFirst, location, clipLocation, point, shapes, offset, bounds, crosshairEnabled, extraPoints, templatePoint, customTemplate) {
      var series = chart.tooltipBase.currentPoints[0].series;
      var isRect = this.isRectSeries(series.type);
      var svgTooltip;
      if (isFirst && location != null) {
        svgTooltip = new sf.svgbase.Tooltip({
          opacity: chart.tooltipBase.tooltipModule.opacity,
          header: chart.tooltipBase.header,
          content: chart.tooltipBase.formattedText,
          fill: chart.tooltipBase.tooltipModule.fill,
          border: chart.tooltipBase.tooltipModule.border,
          enableAnimation: chart.tooltipBase.tooltipModule.enableAnimation,
          location: location != null ? new IChartInternalLocation(location.x + chart.userInteractionBase.secondaryElementOffset.left, Math.min(location.y + chart.userInteractionBase.secondaryElementOffset.top, chart.userInteractionBase.availableSize.height)) : null,
          shared: chart.tooltipBase.tooltipModule.shared,
          crosshair: crosshairEnabled,
          shapes: shapes,
          clipBounds: chart.userInteractionBase.chartAreaType == "PolarAxes" ? new IChartInternalLocation(0, 0) : clipLocation,
          areaBounds: new sf.svgbase.Rect(bounds.x + chart.userInteractionBase.secondaryElementOffset.left, bounds.y + (chart && chart.userInteractionBase.isStockChart ? chart.tooltipBase.seriesTooltipTop : 0) + chart.userInteractionBase.secondaryElementOffset.top, bounds.width, bounds.height),
          palette: this.findPalette(chart),
          controlName: "Chart",
          controlInstance: chart,
          template: customTemplate || chart.tooltipBase.tooltipModule.template,
          data: templatePoint,
          theme: chart.userInteractionBase.theme,
          offset: offset,
          textStyle: chart.tooltipBase.tooltipModule.textStyle,
          isNegative: isRect && series.type != "Waterfall" && point && point.y ? series.seriesType != "BoxPlot" ? Number(point.y) < 0 : false : false,
          inverted: chart.userInteractionBase.isInverted && isRect,
          arrowPadding: chart.tooltipBase.formattedText.length > 1 ? 0 : 7,
          availableSize: chart.userInteractionBase.availableSize,
          duration: chart.tooltipBase.tooltipDuration,
          isCanvas: false,
          rx: 4,
          ry: 4,
          isTextWrap: chart.tooltipBase.tooltipModule.enableTextWrap,
          enableRTL: chart.userInteractionBase.enableRTL
        });
      }
      if (svgTooltip != null) {
        this.removeHighlight(chart);
        this.highlightPoints(chart);
        this.updatePreviousPoint(chart, extraPoints);
        // Setting tooltip text size and weight for all themes
        svgTooltip.textStyle.size = !sf.base.isNullOrUndefined(svgTooltip.textStyle.size) ? svgTooltip.textStyle.size : "12px";
        svgTooltip.textStyle.fontWeight = !sf.base.isNullOrUndefined(svgTooltip.textStyle.fontWeight) ? svgTooltip.textStyle.fontWeight : "400"; // 400 for Regular font weight
        this.renderTooltip(svgTooltip, chart.element.id + '_tooltip', chart);
      }
    },
    tooltip: function tooltip(chart) {
      this.getTooltipElement(chart);
      if (!sf.base.isNullOrUndefined(chart.userInteractionBase.visibleSeries)) {
        if (!chart.tooltipBase.tooltipModule.shared) {
          this.renderSeriesTooltip(true, chart);
        } else {
          this.renderGroupedTooltip(true, chart);
        }
      }
    },
    getData: function getData(chart) {
      var pointData = null;
      var point = null;
      var series = null;
      var width;
      var height;
      var mouseX;
      var mouseY;
      if (!sf.base.isNullOrUndefined(chart.userInteractionBase.visibleSeries)) {
        for (var len = chart.userInteractionBase.visibleSeries.length, i = len - 1; i >= 0; i--) {
          series = chart.userInteractionBase.visibleSeries[i];
          width = series.type === 'Scatter' || series.drawType === 'Scatter' || series.marker && series.marker.vS ? (series.marker.mH + 5) / 2 : 0;
          height = series.type === 'Scatter' || series.drawType === 'Scatter' || series.marker && series.marker.vS ? (series.marker.mW + 5) / 2 : 0;
          mouseX = chart.mouseX;
          mouseY = chart.mouseY;
          if (series.dataEditSettings && this.isRectSeries(series.seriesType)) {
            if (!(series.type === 'Bar' && series.chartIsTransposed) && (series.chartIsTransposed || series.type === 'Bar')) {
              var markerWidth = series.marker.mW / 2;
              mouseX = series.y_Axis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;
            } else {
              var markerHeight = series.marker.mH / 2;
              mouseY = series.y_Axis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;
            }
          }
          if (series.visible && !sf.base.isNullOrUndefined(series.clipRect) && sf.svgbase.withInAreaBounds(mouseX, mouseY, new sf.svgbase.Rect(series.clipRect.x, series.clipRect.y, series.clipRect.w, series.clipRect.h), width, height)) {
            point = this.getRectPoint(series, series.clipRect, mouseX, mouseY, chart);
          }
          if (point) {
            return pointData = {
              point: point,
              series: series
            };
          }
        }
      }
      return pointData = {
        point: point,
        series: series
      };
    },
    getRectPoint: function getRectPoint(series, rect, x, y, chart) {
      var fromCenterX;
      var fromCenterY;
      var clickAngle;
      var arcAngle = 0;
      var startAngle;
      var endAngle;
      var distanceFromCenter;
      var isRectSeries = this.isRectSeries(series.seriesType);
      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {
        var point = _a[_i];
        if (!point.rD) {
          if (!point.r || !point.r.length) {
            continue;
          }
        }
        if (point.rD && chart.userInteractionBase.chartAreaType === 'PolarAxes' && series.drawType.indexOf('Column') > -1) {
          fromCenterX = x - (series.clipRect.w / 2 + series.clipRect.x);
          fromCenterY = y - (series.clipRect.h / 2 + series.clipRect.y);
          arcAngle = 2 * Math.PI * (point.rD.cP < 0 ? 1 + point.rD.cP : point.rD.cP);
          clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);
          clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;
          clickAngle = clickAngle + 2 * Math.PI * series.x_Axis.startAngle;
          startAngle = point.rD.sA;
          startAngle -= arcAngle;
          startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;
          endAngle = point.rD.eA;
          endAngle -= arcAngle;
          endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;
          distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
          if (clickAngle >= startAngle && clickAngle <= endAngle && (distanceFromCenter >= point.rD.iR && distanceFromCenter <= point.rD.r || distanceFromCenter <= point.rD.iR && distanceFromCenter >= point.rD.r) && distanceFromCenter <= chart.userInteractionBase.chartRadius) {
            return point;
          }
        }
        if (series.dataEditSettings && isRectSeries && this.rectRegion(x, y, point, rect, series, chart)) {
          return point;
        }
        if (this.checkRegionContainsPoint(point.r, rect, x, y, chart)) {
          return point;
        }
      }
      return null;
    },
    rectRegion: function rectRegion(x, y, point, rect, series, chart) {
      var isBar = series.type === 'Bar';
      var isInversed = series.y_Axis.isAxisInverse;
      var isTransposed = series.chartIsTransposed;
      var heightValue = 10;
      var yValue = 0;
      var xValue = 0;
      var width;
      var height = width = 2 * heightValue;
      if (isInversed && isTransposed) {
        if (isBar) {
          yValue = point.r[0].h - heightValue;
          width = point.r[0].w;
        } else {
          xValue = -heightValue;
          height = point.r[0].h;
        }
      } else if (isInversed || point.yV < 0) {
        if (isBar) {
          xValue = -heightValue;
          height = point.r[0].h;
        } else {
          yValue = point.r[0].h - heightValue;
          width = point.r[0].w;
        }
      } else if (isTransposed) {
        if (isBar) {
          yValue = -heightValue;
          width = point.r[0].w;
        } else {
          xValue = point.r[0].w - heightValue;
          height = point.r[0].h;
        }
      } else {
        if (isBar) {
          xValue = point.r[0].w - heightValue;
          height = point.r[0].h;
        } else {
          yValue = -heightValue;
          width = point.r[0].w;
        }
      }
      return point.r.some(function (region) {
        return sf.svgbase.withInAreaBounds(x, y, new sf.svgbase.Rect((chart.userInteractionBase.chartAreaType === 'CartesianAxes' ? rect.x : 0) + region.x + xValue, (chart.userInteractionBase.chartAreaType === 'CartesianAxes' ? rect.y : 0) + region.y + yValue, width, height));
      });
    },
    checkRegionContainsPoint: function checkRegionContainsPoint(regionRect, rect, x, y, chart) {
      return regionRect.some(function (region, index) {
        chart.userInteractionBase.lierIndex = index;
        return sf.svgbase.withInAreaBounds(x, y, new sf.svgbase.Rect((chart.userInteractionBase.chartAreaType === 'CartesianAxes' ? rect.x : 0) + region.x, (chart.userInteractionBase.chartAreaType === 'CartesianAxes' ? rect.y : 0) + region.y, region.w, region.h));
      });
    },
    getClosestX: function getClosestX(chart, series) {
      if (series == null) {
        return null;
      }
      var rect = series.clipRect;
      var pointData;
      if (rect && chart.mouseX <= rect.x + rect.w && chart.mouseX >= rect.x) {
        var pointValue = this.getPointValue(chart, series);
        var closestPoint = this.getClosest(series, pointValue);
        if (closestPoint != null && closestPoint.y == null && series.name == "BollingerBand") {
          return null;
        } else {
          return pointData = {
            point: closestPoint,
            series: series
          };
        }
      }
      return null;
    },
    getPointValue: function getPointValue(chart, series) {
      if (series != null && series.clipRect != null) {
        var pointValue = !chart.userInteractionBase.isInverted ? chart.mouseX - series.clipRect.x : chart.mouseY - series.clipRect.y,
          size = !chart.userInteractionBase.isInverted ? series.clipRect.w : series.clipRect.h;
        return this.getValueByPoint(pointValue, size, series.x_Axis.orientation, series.x_Axis.visibleRange, series.x_Axis.isAxisInverse);
      }
      return 0;
    },
    getValueByPoint: function getValueByPoint(pointValue, size, orientation, visibleRange, isInversed) {
      return (orientation == 'Horizontal' && !isInversed || orientation != 'Horizontal' && isInversed ? pointValue / size : 1 - pointValue / size) * visibleRange.delta + visibleRange.start;
    },
    getClosest: function getClosest(series, pointValue) {
      var closest;
      if (series == null) {
        return closest;
      }
      if (pointValue >= series.xMin - 0.5 && pointValue <= series.xMax + 0.5 && series.points.length > 0) {
        closest = this.findClosest(this.sortPoints(series.points, ['xV']), pointValue);
      }
      return closest;
    },
    sortPoints: function sortPoints(data, fields, isDescending) {
      var sortData = sf.base.extend([], data, null);
      for (var i = 0; i < sortData.length; i++) {
        for (var j = 0; j < fields.length; j++) {
          if (sortData[i][fields[j]] instanceof Date) {
            sortData[i][fields[j]] = sortData[i][fields[j]].getTime();
          }
        }
      }
      sortData.sort(function (a, b) {
        var first = 0;
        var second = 0;
        for (var i = 0; i < fields.length; i++) {
          first += a[fields[i]];
          second += b[fields[i]];
        }
        if (!isDescending && first < second || isDescending && first > second) {
          return -1;
        } else if (first === second) {
          return 0;
        }
        return 1;
      });
      return sortData;
    },
    findClosest: function findClosest(pointsData, targetValue) {
      var n = pointsData.length;
      if (targetValue <= pointsData[0].xV) {
        return pointsData[0];
      }
      if (targetValue >= pointsData[n - 1].xV) {
        return pointsData[n - 1];
      }
      var firstVal = 0,
        lastVal = n,
        midVal = 0;
      while (firstVal < lastVal) {
        midVal = Math.round((firstVal + lastVal) / 2);
        if (pointsData[midVal].xV == targetValue) {
          return pointsData[midVal];
        }
        if (targetValue < pointsData[midVal].xV) {
          if (midVal > 0 && targetValue > pointsData[midVal - 1].xV) {
            return this.getClosestValue(pointsData[midVal - 1], pointsData[midVal], targetValue);
          }
          lastVal = midVal;
        } else {
          if (midVal < n - 1 && targetValue < pointsData[midVal + 1].xV) {
            return this.getClosestValue(pointsData[midVal], pointsData[midVal + 1], targetValue);
          }
          firstVal = midVal + 1;
        }
      }
      return pointsData[midVal];
    },
    getClosestValue: function getClosestValue(point1, point2, target) {
      if (target - point1.xV >= point2.xV - target) {
        return point2;
      } else {
        return point1;
      }
    },
    getSharedPoints: function getSharedPoints(chart, pointsInfo) {
      var allPoints = pointsInfo;
      // Fix for 828793 and one of the fix for 829105
      if (!(chart.userInteractionBase.chartAreaType == 'CartesianAxes' && pointsInfo != null && pointsInfo.length > 0) || chart.tooltipBase.tooltipModule.showAllSeries) {
        return pointsInfo;
      }
      var pointValue, closest;
      for (var _i = 0, pointsInfo_1 = pointsInfo; _i < pointsInfo_1.length; _i++) {
        var point = pointsInfo_1[_i];
        pointValue = this.getPointValue(chart, point.series);
        if (this.isClosest(pointValue, point, closest)) {
          closest = point.point.xV;
        }
        if (this.isAxisValue(point.series)) {
          return pointsInfo;
        }
      }
      pointsInfo = pointsInfo.filter(function (item) {
        return closest == item.point.xV;
      });
      if (pointsInfo.length < allPoints.length && chart.tooltipBase.tooltipModule.showNearestPoint) {
        return allPoints;
      } else {
        return pointsInfo;
      }
    },
    isClosest: function isClosest(pointValue, point, closest) {
      var x_AxisRenderer = point.series.x_Axis;
      return pointValue >= x_AxisRenderer.visibleRange.start - 0.5 && pointValue <= x_AxisRenderer.visibleRange.end + 0.5 && (isNaN(closest) || Math.abs(point.point.xV - pointValue) < Math.abs(closest - pointValue));
    },
    isAxisValue: function isAxisValue(series) {
      if (!sf.base.isNullOrUndefined(series)) {
        return series.axesCount > 2 && series.x_Axis.name != 'PrimaryXAxis';
      }
      return false;
    },
    sortPointsInfo: function sortPointsInfo(pointsInfo) {
      var points = [];
      pointsInfo.forEach(function (point) {
        if (point.series.category === 'Series') {
          points.push(point);
        }
      });
      pointsInfo.forEach(function (point) {
        if (point.series.category === 'Indicator') {
          points.push(point);
        }
      });
      pointsInfo.forEach(function (point) {
        if (point.series.category === 'TrendLine') {
          points.push(point);
        }
      });
      return points;
    },
    findHeader: function findHeader(data, chart) {
      var header = chart.tooltipBase.header;
      if (sf.base.isNullOrUndefined(header)) {
        return "";
      }
      header = this.parseTemplate(data.point, data.series, header, chart);
      if (header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
        return header;
      }
      return '';
    },
    getTooltipText: function getTooltipText(pointData, chart) {
      return this.parseTemplate(pointData.point, pointData.series, this.getFormat(chart, pointData.series), chart);
    },
    getIndicatorTooltipFormat: function getIndicatorTooltipFormat(series, format) {
      var toolTip;
      if (series.seriesType === 'XY') {
        toolTip = series.name + ' : <b>${point.y}</b>';
      } else {
        toolTip = format;
      }
      return toolTip;
    },
    parseTemplate: function parseTemplate(point, series, format, chart) {
      var val;
      var textValue;
      for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {
        var dataValue = _a[_i];
        val = new RegExp('${point' + '.' + dataValue + '}', 'gm');
        if (format.indexOf(val.source) > -1) {
          format = format.replace(val.source, this.formatPointValue(point, dataValue, val.source === '${point.x}', val.source === '${point.h}' || val.source === '${point.o}' || val.source === '${point.c}' || val.source === '${point.l}' || val.source === '${point.y}', series, chart.userInteractionBase.isStockChart, chart));
        }
      }
      for (var _b = 0, _c = Object.keys(series); _b < _c.length; _b++) {
        var dataValue = _c[_b];
        val = new RegExp('${series' + '.' + dataValue + '}', 'gm');
        textValue = series[dataValue];
        if (format.indexOf(val.source) > -1) {
          format = format.replace(val.source, textValue);
        }
      }
      return format;
    },
    getTemplateLocation: function getTemplateLocation(bounds, symbolLocation, width, height, markerHeight, clipBounds, inverted, isNegative) {
      var location = new IChartInternalLocation(symbolLocation.x, symbolLocation.y);
      var elementWidth = width + 10,
        elementHeight = height + 10,
        clipX = clipBounds.x,
        clipY = clipBounds.y,
        boundsX = bounds.x,
        boundsY = bounds.y;
      if (!inverted) {
        location = new IChartInternalLocation(location.x + clipX - width / 2, location.y + clipY - height - 12 - markerHeight);
        if (location.y < boundsY || isNegative) {
          location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
        }
        if (location.y + elementHeight + 12 > boundsY + bounds.height) {
          location.y = (symbolLocation.y > bounds.height ? bounds.height : symbolLocation.y) + clipY - height - 12 - markerHeight;
        }
        if (location.x < boundsX) {
          location.x = boundsX;
        }
        if (location.x + elementWidth > boundsX + bounds.width) {
          location.x -= location.x + elementWidth - (boundsX + bounds.width);
        }
      } else {
        location = new IChartInternalLocation(location.x + clipX + markerHeight, location.y + clipY - height / 2);
        if (location.x + elementWidth + 12 > boundsX + bounds.width || isNegative) {
          location.x = (symbolLocation.x > bounds.width ? bounds.width : symbolLocation.x) + clipX - markerHeight - (elementWidth + 12);
        }
        if (location.x < boundsX) {
          location.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + clipX + markerHeight;
        }
        if (location.y <= boundsY) {
          location.y = boundsY;
        }
        if (location.y + elementHeight >= boundsY + bounds.height) {
          location.y -= location.y + elementHeight - (boundsY + bounds.height);
        }
      }
      return {
        x: location.x,
        y: location.y
      };
    },
    formatPointValue: function formatPointValue(point, dataValue, isXPoint, isYPoint, series, isStockChart, chart) {
      var textValue;
      var customLabelFormat;
      var value;
      var axis = isXPoint ? series.x_Axis : series.y_Axis;
      var format = axis.format ? axis.format : axis.dateFormat;
      var labelFormat = axis.labelFormat;
      if (axis.valueType == "DateTime" && isXPoint) {
        textValue = new sf.base.Internationalization().getDateFormat({
          format: format || 'MM/dd/yyyy',
          type: this.firstToLowerCase('DateTime')
        })(this.convertDateAndTime(new Date(point.xV)));
        textValue = this.getGlobalizedDate(textValue, chart.dateValuePairs);
      } else if (axis.valueType === 'DateTimeCategory' && isXPoint) {
        var date = axis.isUniversalDateTime ? this.convertDateAndTime(new Date(point[dataValue])) : new Date(point[dataValue]);
        textValue = new sf.base.Internationalization().getDateFormat({
          format: format || labelFormat || 'MM/dd/yyyy HH:mm:ss tt',
          type: this.firstToLowerCase('DateTime')
        })(date);
        textValue = this.getGlobalizedDate(textValue, chart.dateValuePairs);
      } else if (axis.valueType !== 'Category' && isXPoint) {
        customLabelFormat = labelFormat && labelFormat.match('{value}') !== null;
        textValue = customLabelFormat ? labelFormat.replace('{value}', this.formatAxisValue(point[dataValue], customLabelFormat, labelFormat, void 0, chart)) : this.formatAxisValue(point[dataValue], customLabelFormat, labelFormat, void 0, chart);
      } else if (isYPoint && !sf.base.isNullOrUndefined(point[dataValue])) {
        customLabelFormat = labelFormat && labelFormat.match('{value}') !== null;
        if (dataValue === 'outliers') {
          value = this.formatAxisValue(point[dataValue][this.lierIndex - 4], customLabelFormat, labelFormat, void 0, chart);
        } else {
          var pointValue = point[dataValue];
          var dataLabelFormat = series.markerDataLabelFormat ? parseInt(series.markerDataLabelFormat.substring(1)) : 2;
          var fractionCount = isStockChart ? Math.max(2, (pointValue - Math.round(pointValue)).toString().length) : dataLabelFormat;
          value = this.formatAxisValue(point[dataValue], customLabelFormat, labelFormat, fractionCount, chart);
        }
        if (isStockChart && series.category === 'Indicator' && series.name === 'AccumulationDistribution') {
          value = value.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        value = this.getGlobalizedNumber(value, chart.numberValuePairs);
        textValue = customLabelFormat ? labelFormat.replace('{value}', value) : value;
      } else {
        textValue = this.getGlobalizedNumber(point[dataValue].toString(), chart.numberValuePairs);
      }
      return textValue;
    },
    getFormat: function getFormat(chart, series) {
      var separator = chart.tooltipBase.tooltipModule.shared && !series.name ? '' : '<br/>';
      if (series.tooltipFormat) {
        if (series.seriesType === 'XY' && series.category === 'Indicator') {
          return this.getIndicatorTooltipFormat(series, chart, chart.tooltipBase.tooltipFormat);
        }
        return series.tooltipFormat;
      }
      if (chart.tooltipBase.tooltipFormat) {
        if (series.seriesType === 'XY' && series.category === 'Indicator') {
          return this.getIndicatorTooltipFormat(series, chart, chart.tooltipBase.tooltipFormat);
        }
        return chart.tooltipBase.tooltipFormat;
      }
      var textX = chart.seriesTypes[series.index] === 'Histogram' ? '${point.mI}' + '-' + '${point.mX}' : '${point.x}';
      var format = !chart.tooltipBase.tooltipModule.shared || chart.userInteractionBase.isStockChart && !(series.seriesType.indexOf('HighLow') > -1) ? textX : '${series.name}';
      switch (series.seriesType) {
        case 'XY':
          if (series.category === 'Indicator') {
            return this.getIndicatorTooltipFormat(series, chart, chart.tooltipBase.tooltipFormat);
          }
          return format + ' : ' + (chart.seriesTypes[series.index] === 'Bubble' ? '<b>${point.y}</b>  Size : <b>${point.sI}</b>' : '<b>${point.y}</b>');
        case 'HighLow':
          return format + separator + 'High : <b>${point.h}</b><br/>Low : <b>${point.l}</b>';
        case 'HighLowOpenClose':
          var volumeFormat = chart.userInteractionBase.isStockChart && series.volume ? '<br/>Volume : <b>${point.v}</b>' : '';
          return format + separator + ('High : <b>${point.h}</b><br/>Low : <b>${point.l}</b><br/>' + 'Open : <b>${point.o}</b><br/>Close : <b>${point.c}</b>');
        case 'BoxPlot':
          {
            return format + separator + (chart.userInteractionBase.lierIndex > 3 ? 'Outliers : <b>${point.oL}</b>' : 'Maximum : <b>${point.mX}</b><br/>Q3 : <b>${point.uQ}</b><br/>' + 'Median : <b>${point.m}</b><br/>Q1 : <b>${point.lQ}</b><br/>Minimum : <b>${point.mI}</b>');
          }
        default:
          return '';
      }
    },
    formatAxisValue: function formatAxisValue(point, isCustom, format, fractionCount, chart) {
      if (fractionCount === void 0) {
        fractionCount = 2;
      }
      var pointValue = Number(point);
      return new sf.base.Internationalization().getNumberFormat({
        format: isCustom ? '' : format,
        useGrouping: chart.userInteractionBase.useGrouping,
        minimumFractionDigits: 2,
        maximumFractionDigits: fractionCount > 20 ? 20 : fractionCount
      })(pointValue);
    },
    findShapes: function findShapes(chart) {
      if (!chart.tooltipBase.tooltipModule.enableMarker) {
        return [];
      }
      var marker = [];
      for (var _i = 0, _a = chart.tooltipBase.currentPoints; _i < _a.length; _i++) {
        var data = _a[_i];
        marker.push(data.series.shape);
      }
      return marker;
    },
    findMarkerHeight: function findMarkerHeight(pointData, chart) {
      var series = pointData.series;
      return (series.marker.vS || chart.tooltipBase.tooltipModule.shared && (!this.isRectSeries(series.type) || series.marker.vS) || series.type === 'Scatter' || series.type === 'Scatter') && !(series.seriesType === 'Candle' || series.seriesType === 'Hilo' || series.seriesType === 'HiloOpenClose') ? (series.marker.mH + 5) / 2 + 2 * series.marker.b.wT : 0;
    },
    findSharedLocation: function findSharedLocation(chart) {
      if (chart.userInteractionBase.isStockChart) {
        if (this.stockChartTooltipPosition && this.stockChartTooltipPosition === 'Nearest') {
          return new IChartInternalLocation(chart.tooltipBase.valueX, chart.tooltipBase.valueY + chart.tooltipBase.seriesTooltipTop + 5);
        }
        return new IChartInternalLocation(chart.userInteractionBase.axisClipRect.x + 5, chart.userInteractionBase.axisClipRect.y + chart.tooltipBase.seriesTooltipTop + 5);
      } else {
        if (chart.tooltipBase.currentPoints.length > 1) {
          return new IChartInternalLocation(chart.tooltipBase.valueX, chart.tooltipBase.valueY);
        } else {
          return this.getSymbolLocation(chart.tooltipBase.currentPoints[0], chart);
        }
      }
    },
    valueToCoefficient: function valueToCoefficient(point, axis) {
      var result = (point - axis.visibleRange.start) / axis.visibleRange.delta;
      return axis.isAxisInverse ? 1 - result : result;
    },
    valueToPolarCoefficient: function valueToPolarCoefficient(value, valueType, axis) {
      var range = axis.visibleRange;
      var delta;
      var length;
      if (valueType !== 'Category') {
        delta = range.end - (valueType === 'DateTime' ? axis.dataTimeInterval : axis.visibleInterval) - range.start;
        length = axis.visibleLabelCount - 1;
        delta = delta === 0 ? 1 : delta;
      } else {
        delta = axis.visibleLabelCount === 1 ? 1 : axis.visibleLabelCount - 1 - 0;
        length = axis.visibleLabelCount;
      }
      return axis.isAxisInverse ? (value - range.start) / delta * (1 - 1 / length) : 1 - (value - range.start) / delta * (1 - 1 / length);
    },
    findMouseValue: function findMouseValue(data, chart) {
      var x_axisRenderer = data.series.x_Axis;
      if (!chart.userInteractionBase.isInverted) {
        if (chart.userInteractionBase.chartAreaType === "PolarAxes") {
          chart.tooltipBase.valueX = this.valueToPolarCoefficient(data.point.xV, data.series.x_Axis.valueType, x_axisRenderer) * x_axisRenderer.rect.w + x_axisRenderer.rect.x;
        } else {
          chart.tooltipBase.valueX = data.series.category === "TrendLine" && chart.tooltipBase.tooltipModule.shared ? chart.tooltipBase.valueX : this.valueToCoefficient(data.point.xV, x_axisRenderer) * x_axisRenderer.rect.w + x_axisRenderer.rect.x;
        }
        chart.tooltipBase.valueY = chart.mouseY;
      } else {
        chart.tooltipBase.valueY = (1 - this.valueToCoefficient(data.point.xV, x_axisRenderer)) * x_axisRenderer.rect.h + x_axisRenderer.rect.y;
        chart.tooltipBase.valueX = chart.mouseX;
      }
    },
    getSymbolLocation: function getSymbolLocation(data, chart) {
      var location = chart.userInteractionBase.isStockChart ? new IChartInternalLocation(0, chart.tooltipBase.seriesTooltipTop) : new IChartInternalLocation(0, 0);
      if (data.series.type !== 'BoxAndWhisker') {
        if (data.point.s.length == 0) {
          return null;
        }
        location = new IChartInternalLocation(data.point.s[0].x, data.point.s[0].y);
      }
      switch (data.series.type) {
        case 'BoxAndWhisker':
          return this.getBoxLocation(data, chart);
        case 'Waterfall':
          return this.getWaterfallRegion(data, location, chart);
        case 'RangeArea':
        case 'SplineRangeArea':
        case 'RangeColumn':
        case 'RangeStepArea':
          return this.getRangeArea(data, location);
        default:
          return location;
      }
    },
    getBoxLocation: function getBoxLocation(data, chart) {
      var location = chart.userInteractionBase.lierIndex > 3 ? data.point.s[chart.userInteractionBase.lierIndex - 4] : {
        x: data.point.r[0].x + data.point.r[0].w / 2,
        y: data.point.r[0].y + data.point.r[0].h / 2
      };
      return location;
    },
    getWaterfallRegion: function getWaterfallRegion(data, location) {
      if (!this.inverted) {
        location.y = Number(data.point.y) < 0 ? location.y - data.point.r[0].h : location.y;
      } else {
        location.x = Number(data.point.y) < 0 ? location.x + data.point.r[0].w : location.x;
      }
      return location;
    },
    getRangeArea: function getRangeArea(data, location) {
      if (data.point.r.length > 0 && data.point.r[0]) {
        if (!this.inverted) {
          location.y = data.point.r[0].y + data.point.r[0].h / 2;
        } else {
          location.x = data.point.r[0].x + data.point.r[0].w / 2;
        }
      }
      return location;
    },
    findPalette: function findPalette(chart) {
      var colors = [];
      for (var _i = 0, _a = chart.tooltipBase.currentPoints; _i < _a.length; _i++) {
        var data = _a[_i];
        colors.push(this.findColor(data, data.series));
      }
      return colors;
    },
    findColor: function findColor(data, series) {
      if (this.isRectSeries(series.seriesType) && (series.seriesType === 'Candle' || series.seriesType === 'Hilo' || series.seriesType === 'HiloOpenClose')) {
        return data.point.i;
      } else {
        return data.point.i != "" ? data.point.i : series.marker.f != "" ? series.marker.f : series.interior;
      }
    },
    renderTooltip: function renderTooltip(tooltipOptions, elementId, chart) {
      var svgElement = document.getElementById(elementId + '_svg');
      var firstRender = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 ? false : true;
      var options = tooltipOptions;
      var currentInstance = chart;
      if (firstRender && !sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.tooltip = new sf.svgbase.Tooltip(options);
        currentInstance.tooltip.enableRTL = options.enableRTL;
        currentInstance.tooltip.appendTo('#' + elementId);
      } else if (!sf.base.isNullOrUndefined(currentInstance.tooltip)) {
        currentInstance.tooltip.location = new sf.svgbase.TooltipLocation(options.location.x, options.location.y);
        currentInstance.tooltip.content = options.content;
        currentInstance.tooltip.header = options.header;
        currentInstance.tooltip.offset = options.offset;
        currentInstance.tooltip.palette = options.palette;
        currentInstance.tooltip.shapes = options.shapes;
        currentInstance.tooltip.data = options.data;
        currentInstance.tooltip.template = options.template;
        currentInstance.tooltip.textStyle.color = options.textStyle.color || currentInstance.tooltip.textStyle.color;
        currentInstance.tooltip.textStyle.fontFamily = options.textStyle.fontFamily || currentInstance.tooltip.textStyle.fontFamily;
        currentInstance.tooltip.textStyle.fontStyle = options.textStyle.fontStyle || currentInstance.tooltip.textStyle.fontStyle;
        currentInstance.tooltip.textStyle.fontWeight = options.textStyle.fontWeight || currentInstance.tooltip.textStyle.fontWeight;
        currentInstance.tooltip.textStyle.opacity = options.textStyle.opacity || currentInstance.tooltip.textStyle.opacity;
        currentInstance.tooltip.textStyle.size = options.textStyle.size || currentInstance.tooltip.textStyle.size;
        currentInstance.tooltip.isNegative = options.isNegative;
        currentInstance.tooltip.clipBounds = new sf.svgbase.TooltipLocation(options.clipBounds.x, options.clipBounds.y);
        currentInstance.tooltip.arrowPadding = options.arrowPadding;
        currentInstance.tooltip.dataBind();
      }
    },
    removeTooltip: function removeTooltip(duration, chart) {
      var _this = this;
      var tooltipElement = this.getElement(chart.element.id + '_tooltip');
      this.stopAnimation(chart.tooltipBase.toolTipInterval);
      if (tooltipElement && chart.tooltipBase.tooltipModule.template == null && chart.tooltipBase.previousPoints.length > 0) {
        chart.tooltipBase.toolTipInterval = +setTimeout(function () {
          if (chart.tooltipBase.tooltipModule) {
            _this.fadeOut(chart.dataId);
          }
        }, duration);
      } else if (tooltipElement && chart.tooltipBase.tooltipModule.template != null && chart.tooltipBase.previousPoints.length > 0) {
        chart.tooltipBase.toolTipInterval = +setTimeout(function () {
          if (chart.tooltipBase.tooltipModule.template != null) {
            chart.dotnetref.invokeMethodAsync('RemoveTemplateTooltip');
            chart.tooltipBase.valueX = 0;
            chart.tooltipBase.valueY = 0;
            chart.tooltipBase.currentPoints = [];
            _this.removeHighlight(chart);
            _this.removeMarker(chart);
            chart.tooltipBase.previousPoints = [];
          }
        }, duration);
      }
    },
    stopAnimation: function stopAnimation(toolTipInterval) {
      this.stopTimer(toolTipInterval);
    },
    stopTimer: function stopTimer(timer) {
      window.clearInterval(timer);
    },
    removeHighlight: function removeHighlight(chart) {
      for (var _i = 0, _a = chart.tooltipBase.previousPoints; _i < _a.length; _i++) {
        var point = _a[_i];
        var type = point.series.type != 'Polar' ? point.series.type : point.series.drawType;
        if (this.isRectSeries(type)) {
          this.highlightPoint(chart, point.series, point.point.iX, false);
        }
      }
    },
    highlightPoint: function highlightPoint(chart, series, pointIndex, highlight) {
      var element = this.getElement(chart.element.id + '_Series_' + series.index + '_Point_' + pointIndex + (series.seriesType == 'BoxPlot' ? '_BoxPath' : ''));
      if (!sf.base.isNullOrUndefined(element)) {
        if (chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
          element.setAttribute('fill', highlight && chart.highlightColor != 'transparent' ? chart.highlightColor : series.interior);
        } else {
          element.setAttribute('opacity', (highlight ? series.opacity / 1.25 : series.opacity).toString());
        }
      }
    },
    highlightPoints: function highlightPoints(chart) {
      for (var _i = 0, _a = chart.tooltipBase.currentPoints; _i < _a.length; _i++) {
        var point = _a[_i];
        var type = point.series.type != 'Polar' ? point.series.type : point.series.drawType;
        if (this.isRectSeries(type) && point.series.category == "Series") {
          this.highlightPoint(chart, point.series, point.point.iX, true);
        }
      }
    },
    updatePreviousPoint: function updatePreviousPoint(chart, extraPoints) {
      if (extraPoints.length > 0) {
        chart.tooltipBase.currentPoints = chart.tooltipBase.currentPoints.concat(extraPoints);
      }
      chart.tooltipBase.previousPoints = [];
      chart.tooltipBase.previousPoints = chart.tooltipBase.previousPoints.concat(chart.tooltipBase.currentPoints);
    },
    fadeOut: function fadeOut(dataId) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      if (sf.base.isNullOrUndefined(chart) || !sf.base.isNullOrUndefined(chart) && sf.base.isNullOrUndefined(chart.tooltip)) {
        return;
      }
      this.removeTooltipCommentElement(chart);
      chart.tooltipBase.valueX = 0;
      chart.tooltipBase.valueY = 0;
      chart.tooltipBase.currentPoints = [];
      this.removeHighlight(chart);
      this.removeMarker(chart);
      chart.tooltipBase.previousPoints = [];
      chart.tooltip.fadeOut();
    },
    removeTooltipCommentElement: function removeTooltipCommentElement(chartInstance) {
      var tooltipElementId = chartInstance.tooltip.element ? chartInstance.tooltip.element.id : null;
      var tooltipDivElement = tooltipElementId ? this.getElement(tooltipElementId) : null;
      if (tooltipDivElement && !chartInstance.isRemoveCommentElement && tooltipDivElement.childNodes.length > 1) {
        var tooltipElements = tooltipDivElement.childNodes;
        var commentElements = [];
        for (var i = 0; i < tooltipElements.length; i++) {
          if (tooltipElements[i].nodeName.match('#comment') || tooltipElements[i].nodeName.match('#text')) {
            commentElements.push(tooltipElements[i]);
          }
        }
        for (var _i = 0, commentElements_1 = commentElements; _i < commentElements_1.length; _i++) {
          var element = commentElements_1[_i];
          sf.base.remove(element);
          chartInstance.isRemoveCommentElement = true;
        }
      }
    },
    isSeriesAxisZoomed: function isSeriesAxisZoomed(series) {
      var isAxisZoomed = false;
      if (series.x_Axis.zoomFactor !== 1 || series.y_Axis.zoomFactor !== 1 || series.y_Axis.zoomPosition !== 0 || series.x_Axis.zoomPosition !== 0) {
        isAxisZoomed = true;
      }
      return isAxisZoomed;
    },
    getParentElementBoundsById: function getParentElementBoundsById(id) {
      var element = document.getElementById(id);
      if (element) {
        var svgElement = document.getElementById(id + "_svg");
        if (svgElement) {
          svgElement.style.display = "none";
        }
        var dataElement = document.getElementById(id + "_tooltip_data");
        if (dataElement) {
          dataElement.style.display = "none";
        }
        element.style.width = '100%';
        element.style.height = '100%';
        var elementRect = element.getBoundingClientRect();
        var avl_Width = elementRect.width || element.clientWidth || element.offsetWidth;
        var avl_Height = elementRect.height || element.clientHeight || element.offsetHeight;
        if (svgElement) {
          svgElement.style.display = "";
        }
        if (dataElement) {
          dataElement.style.display = "block";
        }
        return {
          width: avl_Width,
          height: avl_Height,
          left: elementRect.left,
          top: elementRect.top,
          right: elementRect.right,
          bottom: elementRect.bottom
        };
      }
      return {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
    },
    getElementBoundsById: function getElementBoundsById(id, isSetId) {
      if (isSetId === void 0) {
        isSetId = true;
      }
      if (isSetId) {
        this.id = id;
      }
      var element = document.getElementById(id);
      if (element) {
        var elementRect = element.getBoundingClientRect();
        return {
          width: element.clientWidth || element.offsetWidth,
          height: element.clientHeight || element.offsetHeight,
          left: elementRect.left,
          top: elementRect.top,
          right: elementRect.right,
          bottom: elementRect.bottom
        };
      }
      return {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
    },
    getRefreshElementBoundsById: function getRefreshElementBoundsById(id) {
      var element = document.getElementById(id);
      if (element) {
        var chartCollection = document.getElementsByClassName('e-chart');
        var count = chartCollection.length;
        for (var i = 0; i < count; i++) {
          var chartElement = chartCollection[i];
          if (chartElement.id.indexOf('_stockChart_') < 0) {
            var svgElement = chartElement.querySelector('[id*=_svg]');
            svgElement.style.display = 'none';
          }
        }
        element.style.width = '100%';
        element.style.height = '100%';
        var elementRect = element.getBoundingClientRect();
        for (var i = 0; i < count; i++) {
          var chartElement = chartCollection[i];
          if (chartElement.id.indexOf('_stockChart_') < 0) {
            var svgElement = chartElement.querySelector('[id*=_svg]');
            svgElement.style.display = '';
          }
        }
        return {
          width: elementRect.width || element.clientWidth || element.offsetWidth,
          height: elementRect.height || element.clientHeight || element.offsetHeight,
          left: elementRect.left,
          top: elementRect.top,
          right: elementRect.right,
          bottom: elementRect.bottom
        };
      }
      return {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
    },
    getBrowserDeviceInfo: function getBrowserDeviceInfo() {
      return {
        browserName: sf.base.Browser.info.name,
        isPointer: sf.base.Browser.isPointer,
        isDevice: sf.base.Browser.isDevice,
        isTouch: sf.base.Browser.isTouch,
        isIos: sf.base.Browser.isIos || sf.base.Browser.isIos7
      };
    },
    setZoomingCipPath: function setZoomingCipPath(seriesCollection, indicator, clipUrl) {
      var seriesEle = document.getElementById(seriesCollection);
      var indicatorEle = document.getElementById(indicator);
      if (seriesEle) {
        seriesEle.setAttribute('clip-path', clipUrl);
      }
      if (indicatorEle) {
        seriesEle.setAttribute('clip-path', clipUrl);
      }
    },
    setZoomingElementAttributes: function setZoomingElementAttributes(translate, category, seriesG, errorbarG, symbolG, textG, shapeG, element) {
      if (category === 'Indicator' && seriesG && seriesG.parentElement) {
        seriesG.parentElement.setAttribute('transform', translate);
      }
      if (seriesG) {
        seriesG.setAttribute('transform', translate);
      }
      if (errorbarG) {
        errorbarG.setAttribute('transform', translate);
      }
      if (symbolG) {
        symbolG.setAttribute('transform', translate);
      }
      if (textG) {
        textG.setAttribute('visibility', 'hidden');
      }
      if (shapeG) {
        shapeG.setAttribute('visibility', 'hidden');
      }
      if (element) {
        element.style.visibility = 'hidden';
      }
    },
    measureBreakText: function measureBreakText(text, size, color, fontFamily, fontWeight, fontStyle, opacity) {
      var font = {
        color: color,
        size: size,
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        fontStyle: fontStyle,
        opacity: parseInt(opacity, 10)
      };
      return sf.svgbase.measureText(text, font);
    },
    getAllCharacters: function getAllCharacters() {
      var charCollection = [];
      for (var i = 33; i < 591; i++) {
        charCollection.push(String.fromCharCode(i));
      }
      return charCollection;
    },
    measureText: function measureText(text, fontWeight, fontStyle, fontFamily) {
      var textObject = document.getElementById('sfchartmeasuretext');
      if (textObject === null) {
        textObject = sf.base.createElement('text', {
          id: 'sfchartmeasuretext'
        });
        document.body.appendChild(textObject);
      }
      if (text === ' ') {
        text = '&nbsp;';
      }
      textObject.innerHTML = text;
      textObject.style.position = 'fixed';
      textObject.style.fontSize = '100px';
      textObject.style.fontWeight = fontWeight;
      textObject.style.fontStyle = fontStyle;
      textObject.style.fontFamily = fontFamily;
      textObject.style.visibility = 'hidden';
      textObject.style.top = '-100';
      textObject.style.left = '0';
      textObject.style.whiteSpace = 'nowrap';
      textObject.style.lineHeight = 'normal';
      return {
        Width: textObject.clientWidth,
        Height: textObject.clientHeight
      };
    },
    getCharCollectionSize: function getCharCollectionSize(fontkeys) {
      var tempSizeList = [];
      var charList = this.getAllCharacters();
      var charLength = charList.length;
      var fontKeysLength = fontkeys.length;
      for (var i = 0; i < fontKeysLength; i++) {
        var fontValues = fontkeys[i].split('_');
        var fontWeight = fontValues[0];
        var fontStyle = fontValues[1];
        var fontFamily = fontValues[2];
        for (var j = 0; j < charLength; j++) {
          tempSizeList.push(this.measureText(charList[j], fontWeight, fontStyle, fontFamily).Width + '');
        }
      }
      return JSON.stringify(tempSizeList);
    },
    getCharSizeByFontKeys: function getCharSizeByFontKeys(fontkeys) {
      var charSizeList = {};
      var fontKeysLength = fontkeys.length;
      var fontValues = [];
      var charSize;
      for (var i = 0; i < fontKeysLength; i++) {
        fontValues = fontkeys[i].split('_');
        charSize = this.measureText(fontValues[0], fontValues[1], fontValues[2], fontValues[3]);
        charSizeList[fontkeys[i]] = {
          X: charSize.Width,
          Y: charSize.Height
        };
      }
      var result = JSON.stringify(charSizeList);
      return result;
    },
    getElementRect: function getElementRect(id) {
      var element = document.getElementById(id);
      var rect = element.getBoundingClientRect();
      sf.base.remove(element);
      return {
        Left: rect.left,
        Right: rect.right,
        Top: rect.top,
        Bottom: rect.bottom,
        Width: rect.width,
        Height: rect.height
      };
    },
    getElement: function getElement(id) {
      return document.getElementById(id);
    },
    drawTrackBall: function drawTrackBall(svgId, option, tagName, className, clipPath, transform) {
      var parentElement = this.getElement(svgId);
      if (parentElement) {
        var childElement = document.createElementNS('http://www.w3.org/2000/svg', tagName);
        var keys = Object.keys(option);
        var key = '';
        for (var i = 0; i < keys.length; i++) {
          key = keys[i] === 'strokeWidth' ? 'stroke-width' : keys[i] === 'strokeDashArray' ? 'stroke-dashArray' : keys[i] === 'direction' ? 'd' : keys[i];
          childElement.setAttribute(key, option[keys[i]]);
        }
        childElement.setAttribute('class', className);
        childElement.setAttribute('clip-path', clipPath);
        childElement.setAttribute('transform', transform);
        parentElement.appendChild(childElement);
      }
    },
    removeHighLightedMarker: function removeHighLightedMarker(chart) {
      var elements = document.getElementsByClassName(chart.markerExplodeBase.trackBallClass);
      var i = 0;
      while (i < elements.length) {
        if (elements[i].id.indexOf(chart.id) !== -1) {
          sf.base.remove(elements[i]);
        } else {
          i++;
        }
      }
    },
    setAttribute: function setAttribute(id, attribute, value) {
      var element = this.getElement(id);
      if (element) {
        element.setAttribute(attribute, value);
      }
    },
    createTooltip: function createTooltip(id, text, top, left, fontSize) {
      var tooltip = document.getElementById(id);
      var style = 'top:' + ((window.scrollY || 0) + top).toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'color:black !important; ' + 'background:#FFFFFF !important; ' + 'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:10';
      if (!tooltip) {
        tooltip = sf.base.createElement('div', {
          id: id,
          innerHTML: '&nbsp;' + text + '&nbsp;',
          styles: style
        });
        document.body.appendChild(tooltip);
      } else {
        tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');
        tooltip.setAttribute('styles', style);
      }
    },
    removeElement: function removeElement(id) {
      if (!id) {
        return null;
      }
      var element = this.getElement(id);
      if (element) {
        sf.base.remove(element);
      }
    },
    applySelection: function applySelection(id, color) {
      var elements = document.getElementById(id);
      var childNodes;
      if (elements && elements.childNodes) {
        childNodes = elements.childNodes;
        for (var i = 1, length_4 = childNodes.length; i < length_4; i++) {
          if (childNodes[i] && childNodes[i].tagName !== 'rect' && childNodes[i].setAttribute) {
            childNodes[i].setAttribute('fill', color);
          }
        }
      }
    },
    getAndSetTextContent: function getAndSetTextContent(id, get, value) {
      var element = document.getElementById(id);
      if (element) {
        if (get) {
          return element.textContent;
        } else {
          element.textContent = value;
        }
      }
      return null;
    },
    doProgressiveAnimation: function doProgressiveAnimation(id, clipId, duration, delay, strokeDashArray) {
      var clipElement = this.getElement(clipId);
      var path = this.getElement(id);
      var animation = new sf.base.Animation({});
      var pathLength = path.getTotalLength();
      var currentTime;
      path.setAttribute('visibility', 'hidden');
      animation.animate(path, {
        duration: duration + delay,
        delay: delay,
        progress: function progress(args) {
          clipElement.setAttribute('visibility', 'visible');
          if (args.timeStamp >= args.delay) {
            path.setAttribute('visibility', 'visible');
            currentTime = Math.abs(Math.round((args.timeStamp - args.delay) * pathLength / args.duration));
            path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);
          }
        },
        end: function end() {
          path.setAttribute('stroke-dasharray', strokeDashArray);
        }
      });
    },
    linear: function linear(currentTime, startValue, endValue, duration) {
      return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
    },
    doLinearAnimation: function doLinearAnimation(id, duration, delay, isInverted) {
      var clipRect = this.getElement(id);
      var animation = new sf.base.Animation({});
      var effect = this.linear;
      var elementHeight = +clipRect.getAttribute('height');
      var elementWidth = +clipRect.getAttribute('width');
      var xCenter = +clipRect.getAttribute('x');
      var yCenter = isInverted ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') : +clipRect.getAttribute('y');
      var value;
      animation.animate(clipRect, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          if (args.timeStamp >= args.delay) {
            clipRect.setAttribute('visibility', 'visible');
            if (isInverted) {
              value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
              clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(1,' + value / elementHeight + ') translate(' + -xCenter + ' ' + -yCenter + ')');
            } else {
              value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
              clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(' + value / elementWidth + ', 1) translate(' + -xCenter + ' ' + -yCenter + ')');
            }
          }
        },
        end: function end() {
          clipRect.setAttribute('transform', 'translate(0,0)');
        }
      });
    },
    filterCommentElement: function filterCommentElement(id) {
      var element = this.getElement(id);
      if (!element) {
        return null;
      }
      var groupElement = element.childNodes;
      var pathElement = [];
      for (var i = 0; i < groupElement.length; i++) {
        if (!groupElement[i].nodeName.match('#comment')) {
          pathElement.push(groupElement[i]);
        }
      }
      return pathElement;
    },
    doInitialAnimation: function doInitialAnimation(info) {
      for (var infoIndex = 0; infoIndex < info.length; infoIndex++) {
        switch (info[infoIndex].type) {
          case 'Rect':
            var seriesClipPath = this.getElement(info[infoIndex].clipPathId);
            var seriesPathElement = this.filterCommentElement(info[infoIndex].elementId);
            for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
              this.doRectAnimation(seriesPathElement[info[infoIndex].pointIndex[i]], seriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i], info[infoIndex].pointWidth[i], info[infoIndex].pointHeight[i], info[infoIndex].isInvertedAxis);
            }
            break;
          case 'Progressive':
            this.doProgressiveAnimation(info[infoIndex].elementId, info[infoIndex].clipPathId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].strokeDashArray);
            break;
          case 'Linear':
            this.doLinearAnimation(info[infoIndex].elementId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].isInvertedAxis);
            break;
          case 'Marker':
            var markerClipPath = this.getElement(info[infoIndex].clipPathId);
            var markerElement = this.filterCommentElement(info[infoIndex].elementId);
            for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
              this.doMarkerAnimate(markerElement[info[infoIndex].pointIndex[i]], markerClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i]);
            }
            break;
          case 'PolarRadar':
            var polarseriesClipPath = this.getElement(info[infoIndex].clipPathId);
            var polarseriesPathElement = this.filterCommentElement(info[infoIndex].elementId);
            for (var i = 0; i < polarseriesPathElement.length; i++) {
              this.doPolarRadarAnimation(polarseriesPathElement[i], polarseriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[0], info[infoIndex].pointY[0]);
            }
            break;
        }
        if (!sf.base.isNullOrUndefined(info[infoIndex].markerInfo)) {
          var markerClipPath = this.getElement(info[infoIndex].markerInfo.markerClipPathId);
          var markerElement = this.filterCommentElement(info[infoIndex].markerInfo.markerElementId);
          for (var i = 0; i < info[infoIndex].markerInfo.pointIndex.length; i++) {
            this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.pointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.pointX[i], info[infoIndex].markerInfo.pointY[i]);
            if (info[infoIndex].markerInfo.lowPointIndex.length > 0) {
              this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.lowPointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.lowPointX[i], info[infoIndex].markerInfo.lowPointY[i]);
            }
          }
        }
        if (!sf.base.isNullOrUndefined(info[infoIndex].dataLabelInfo)) {
          if (info[infoIndex].dataLabelInfo.templateId.length === 0) {
            this.doDataLabelAnimation(info[infoIndex].dataLabelInfo.shapeGroupId, info[infoIndex].dataLabelInfo.textGroupId, '', info[infoIndex].clipPathId, 200, info[infoIndex].duration + info[infoIndex].delay);
          } else {
            for (var i = 0; i < info[infoIndex].dataLabelInfo.templateId.length; i++) {
              this.doDataLabelAnimation('', '', info[infoIndex].dataLabelInfo.templateId[i], '', 200, info[infoIndex].duration + info[infoIndex].delay);
            }
          }
        }
        if (!sf.base.isNullOrUndefined(info[infoIndex].errorBarInfo)) {
          this.doErrorBarAnimation(info[infoIndex].errorBarInfo.errorBarElementId, info[infoIndex].errorBarInfo.errorBarClipPathId, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].isInvertedAxis);
        }
      }
    },
    doDynamicAnimation: function doDynamicAnimation(pathInfo, rectInfo, textInfo) {
      for (var pathIndex = 0; pathIndex < pathInfo.length; pathIndex++) {
        if (!sf.base.isNullOrUndefined(pathInfo[pathIndex].previousDir) && pathInfo[pathIndex].previousDir !== '' && !sf.base.isNullOrUndefined(pathInfo[pathIndex].currentDir) && pathInfo[pathIndex].currentDir !== '') {
          this.pathAnimation(pathInfo[pathIndex].id, pathInfo[pathIndex].currentDir, true, pathInfo[pathIndex].previousDir, 300);
        }
      }
      for (var rectIndex = 0; rectIndex < rectInfo.length; rectIndex++) {
        this.animateRectElement(rectInfo[rectIndex].id, 0, 300, rectInfo[rectIndex].currentRect, rectInfo[rectIndex].previousRect);
      }
      for (var textIndex = 0; textIndex < textInfo.length; textIndex++) {
        this.animateRedrawElement(textInfo[textIndex].id, 300, textInfo[textIndex].preLocationX, textInfo[textIndex].preLocationY, textInfo[textIndex].curLocationX, textInfo[textIndex].curLocationY, textInfo[textIndex].x, textInfo[textIndex].y);
      }
    },
    doRectAnimation: function doRectAnimation(element, clipPathElement, duration, delay, centerX, centerY, elementWidth, elementHeight, isInverted) {
      var effect = this.linear;
      var value;
      if (!sf.base.isNullOrUndefined(element)) {
        element.setAttribute('visibility', 'hidden');
        new sf.base.Animation({}).animate(element, {
          duration: duration,
          delay: delay,
          progress: function progress(args) {
            clipPathElement.setAttribute('visibility', 'visible');
            if (args.timeStamp >= args.delay) {
              element.setAttribute('visibility', 'visible');
              if (!isInverted) {
                elementHeight = elementHeight ? elementHeight : 1;
                value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(1,' + value / elementHeight + ') translate(' + -centerX + ' ' + -centerY + ')');
              } else {
                elementWidth = elementWidth ? elementWidth : 1;
                value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + value / elementWidth + ', 1) translate(' + -centerX + ' ' + -centerY + ')');
              }
            }
          },
          end: function end() {
            element.setAttribute('transform', 'translate(0,0)');
          }
        });
      }
    },
    doMarkerAnimate: function doMarkerAnimate(element, clipPathElement, duration, delay, centerX, centerY) {
      var height = 0;
      if (!element) {
        return;
      }
      element.setAttribute('visibility', 'hidden');
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          clipPathElement.setAttribute('visibility', 'visible');
          if (args.timeStamp > args.delay) {
            element.setAttribute('visibility', 'visible');
            height = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + height + ') translate(' + -centerX + ' ' + -centerY + ')');
          }
        },
        end: function end() {
          element.setAttribute('visibility', '');
        }
      });
    },
    doPolarRadarAnimation: function doPolarRadarAnimation(element, clipPathElement, duration, delay, chartcenterX, chartcenterY) {
      var elementHeight = 0;
      element.setAttribute('visibility', 'hidden');
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          clipPathElement.setAttribute('visibility', 'visible');
          if (args.timeStamp > args.delay) {
            element.setAttribute('visibility', 'visible');
            elementHeight = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute('transform', 'translate(' + chartcenterX + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + -chartcenterX + ' ' + -chartcenterY + ')');
          }
        },
        end: function end() {
          element.setAttribute('visibility', 'visible');
          element.removeAttribute('transform');
        }
      });
    },
    templateAnimate: function templateAnimate(element, delay, duration, name, isRemove, clipElement) {
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        name: name,
        progress: function progress(args) {
          if (clipElement) {
            clipElement.setAttribute('visibility', 'visible');
          }
          args.element.style.visibility = 'visible';
        },
        end: function end(args) {
          if (isRemove) {
            sf.base.remove(args.element);
          } else {
            args.element.style.visibility = 'visible';
          }
        }
      });
    },
    doDataLabelAnimation: function doDataLabelAnimation(shapeId, textId, tempId, clipId, duration, delay) {
      var shapeElements = this.filterCommentElement(shapeId);
      var textElements = this.filterCommentElement(textId);
      var clipPathElement = this.getElement(clipId);
      var tempElement = this.getElement(tempId);
      var centerX;
      var centerY;
      var length = tempElement ? 1 : textElements.length;
      var element;
      for (var i = 0; i < length; i++) {
        if (tempElement) {
          tempElement.style.visibility = 'hidden';
          this.templateAnimate(tempElement, delay, duration, 'ZoomIn');
        } else {
          element = textElements[i];
          centerX = +element.getAttribute('x') + +element.getAttribute('width') / 2;
          centerY = +element.getAttribute('y') + +element.getAttribute('height') / 2;
          this.doMarkerAnimate(textElements[i], clipPathElement, duration, delay, centerX, centerY);
          if (shapeElements[i]) {
            element = shapeElements[i];
            centerX = +element.getAttribute('x') + +element.getAttribute('width') / 2;
            centerY = +element.getAttribute('y') + +element.getAttribute('height') / 2;
            this.doMarkerAnimate(shapeElements[i], clipPathElement, duration, delay, centerX, centerY);
          }
        }
      }
    },
    pathAnimation: function pathAnimation(id, direction, redraw, previousDirection, animateDuration) {
      var _this = this;
      var element = this.getElement(id);
      if (!redraw || element == null) {
        return null;
      }
      var duration = 300;
      if (animateDuration) {
        duration = animateDuration;
      }
      var startDirections = previousDirection || element.getAttribute('d');
      var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
      var endDirections = direction.split(/(?=[LMCZAQ])/);
      var currentDireciton;
      var startPath = [];
      var endPath = [];
      var c;
      var end;
      element.setAttribute('d', startDirections);
      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        progress: function progress(args) {
          currentDireciton = '';
          splitDirections.map(function (directions, index) {
            startPath = directions.split(' ');
            endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;
            if (startPath[0] === 'Z') {
              currentDireciton += 'Z' + ' ';
            } else {
              currentDireciton += startPath[0] + ' ' + _this.linear(args.timeStamp, +startPath[1], +endPath[1] - +startPath[1], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[2], +endPath[2] - +startPath[2], args.duration) + ' ';
            }
            if (startPath[0] === 'C' || startPath[0] === 'Q') {
              c = 3;
              end = startPath[0] === 'Q' ? 4 : 6;
              while (c < end) {
                currentDireciton += _this.linear(args.timeStamp, +startPath[c], +endPath[c] - +startPath[c], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[++c], +endPath[c] - +startPath[c], args.duration) + ' ';
                ++c;
              }
            }
            if (startPath[0] === 'A') {
              currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' + _this.linear(args.timeStamp, +startPath[6], +endPath[6] - +startPath[6], args.duration) + ' ' + _this.linear(args.timeStamp, +startPath[7], +endPath[7] - +startPath[7], args.duration) + ' ';
            }
          });
          element.setAttribute('d', currentDireciton);
        },
        end: function end() {
          element.setAttribute('d', direction);
        }
      });
    },
    getPreviousDirection: function getPreviousDirection(id) {
      var element = this.getElement(id);
      var previousDirection = element ? element.getAttribute('d') : null;
      return previousDirection;
    },
    getPreviousLocation: function getPreviousLocation(id, circlePath) {
      var element = this.getElement(id);
      var x = element ? +element.getAttribute(circlePath + 'x') : 0;
      var y = element ? +element.getAttribute(circlePath + 'y') : 0;
      return {
        X: x,
        Y: y
      };
    },
    animateRectElement: function animateRectElement(element, delay, duration, currentRect, previousRect) {
      var _this = this;
      var setStyle = function setStyle(rect) {
        element.setAttribute('x', rect.x + '');
        element.setAttribute('y', rect.y + '');
        element.setAttribute('width', rect.width + '');
        element.setAttribute('height', rect.height + '');
      };
      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          setStyle(new sf.svgbase.Rect(_this.linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), _this.linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), _this.linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), _this.linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
        },
        end: function end() {
          setStyle(currentRect);
        }
      });
    },
    animateRedrawElement: function animateRedrawElement(elementId, duration, startX, startY, endX, endY, x, y) {
      var _this = this;
      if (x === void 0) {
        x = 'x';
      }
      if (y === void 0) {
        y = 'y';
      }
      var element = this.getElement(elementId);
      if (!element) {
        return null;
      }
      var isDiv = element.tagName === 'DIV';
      var setStyle = function setStyle(xValue, yValue) {
        if (isDiv) {
          element.style[x] = xValue + 'px';
          element.style[y] = yValue + 'px';
        } else {
          element.setAttribute(x, xValue + '');
          element.setAttribute(y, yValue + '');
        }
      };
      setStyle(startX, startY);
      new sf.base.Animation({}).animate(sf.base.createElement('div'), {
        duration: duration,
        progress: function progress(args) {
          setStyle(_this.linear(args.timeStamp, startX, endX - startX, args.duration), _this.linear(args.timeStamp, startY, endY - startY, args.duration));
        },
        end: function end() {
          setStyle(endX, endY);
        }
      });
    },
    appendChildElement: function appendChildElement(parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration) {
      if (isAnimate === void 0) {
        isAnimate = false;
      }
      if (x === void 0) {
        x = 'x';
      }
      if (y === void 0) {
        y = 'y';
      }
      if (forceAnimate === void 0) {
        forceAnimate = false;
      }
      if (isRect === void 0) {
        isRect = false;
      }
      if (previousRect === void 0) {
        previousRect = null;
      }
      var existChild = parent.querySelector('#' + childElement.id);
      var element = existChild || this.getElement(childElement.id);
      var child = childElement;
      var duration = animateDuration ? animateDuration : 300;
      if (redraw && isAnimate && element) {
        start = start || (element.tagName === 'DIV' ? new sf.svgbase.TooltipLocation(+element.style[x].split('px')[0], +element.style[y].split('px')[0]) : new sf.svgbase.TooltipLocation(+element.getAttribute(x), +element.getAttribute(y)));
        if (direction !== '' && direction !== null) {
          this.pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);
        } else if (isRect && previousRect) {
          this.animateRectElement(child, 0, duration, new sf.svgbase.Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);
        } else {
          var end = child.tagName === 'DIV' ? new sf.svgbase.TooltipLocation(+child.style[x].split('px')[0], +child.style[y].split('px')[0]) : new sf.svgbase.TooltipLocation(+child.getAttribute(x), +child.getAttribute(y));
          this.animateRedrawElement(child, duration, start, end, x, y);
        }
      } else if (redraw && isAnimate && !element && forceAnimate) {
        this.templateAnimate(child, 0, 600, 'FadeIn');
      }
    },
    processAppendChild: function processAppendChild(parentId, childId, locationX, locationY, rectX, rectY, rectWidth, rectHeight, redraw, isAnimate, x, y, direction, forceAnimate, isRect, animateDuration) {
      if (isAnimate === void 0) {
        isAnimate = false;
      }
      if (x === void 0) {
        x = 'x';
      }
      if (y === void 0) {
        y = 'y';
      }
      if (forceAnimate === void 0) {
        forceAnimate = false;
      }
      if (isRect === void 0) {
        isRect = false;
      }
      var parentElement = this.getElement(parentId);
      var childElement = this.getElement(childId);
      var start = new sf.svgbase.TooltipLocation(locationX, locationY);
      var rect = new sf.svgbase.Rect(rectX, rectY, rectWidth, rectHeight);
      this.appendChildElement(parentElement, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, rect, animateDuration);
    },
    createStyleElement: function createStyleElement(styleId, styleInnerHTML) {
      document.body.appendChild(sf.base.createElement('style', {
        id: styleId,
        innerHTML: styleInnerHTML
      }));
    },
    isLassoId: function isLassoId(x, y) {
      var lassoEle = document.elementFromPoint(x, y);
      return lassoEle ? lassoEle.id : '';
    },
    doErrorBarAnimation: function doErrorBarAnimation(id, clipId, delay, isInverted) {
      var errorBarElements = this.filterCommentElement(id);
      var clipElement = this.getElement(clipId);
      if (!errorBarElements) {
        return null;
      }
      var j = 1;
      while (j < errorBarElements.length) {
        errorBarElements[j].style.visibility = 'hidden';
        this.templateAnimate(errorBarElements[j], delay, 350, isInverted ? 'SlideLeftIn' : 'SlideBottomIn', false, clipElement);
        j++;
      }
    },
    getTemplateSize: function getTemplateSize(id) {
      var element = this.getElement(id);
      if (element) {
        return {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
      }
      return null;
    },
    resizeBound: {},
    resize: {},
    chartResize: function chartResize(dotnetrefCollection, e) {
      var _this = this;
      this.isResized = true;
      if (this.tooltipModule) {
        Chart.removeTooltip(100, this);
        Chart.removeCrosshair(this, 100);
      }
      this.tooltipModule = null;
      this.crosshair = null;
      this.markerExploded = false;
      if (this.resize) {
        clearTimeout(this.resize);
      }
      if (!this.isDisposed) {
        this.resize = setTimeout(function () {
          var count = dotnetrefCollection.length;
          var tempDotnetref;
          var id;
          var element;
          var offsetSizeCollection = {};
          for (var i = 0; i < count; i++) {
            tempDotnetref = dotnetrefCollection[i].dotnetref;
            id = dotnetrefCollection[i].id;
            if (id.indexOf('_stockChart_') < 0 && document.getElementById(id + "_svg")) {
              element = document.getElementById(id + "_svg");
              element.style.display = "none";
            }
          }
          for (var i = 0; i < count; i++) {
            tempDotnetref = dotnetrefCollection[i].dotnetref;
            id = dotnetrefCollection[i].id;
            if (id.indexOf('_stockChart_') < 0 && document.getElementById(id)) {
              element = document.getElementById(id);
              offsetSizeCollection[id] = {
                Dotnetref: tempDotnetref,
                Width: element.clientWidth || element.offsetWidth,
                Height: element.clientHeight || element.offsetHeight
              };
            }
          }
          for (var key in offsetSizeCollection) {
            tempDotnetref = offsetSizeCollection[key].Dotnetref;
            element = document.getElementById(key + "_svg");
            element.style.display = "";
            tempDotnetref.invokeMethodAsync('OnChartResize', JSON.stringify({
              Width: offsetSizeCollection[key].Width,
              Height: offsetSizeCollection[key].Height
            }));
          }
          clearTimeout(_this.resize);
        }, 500);
      }
      return false;
    },
    getDatalabelTemplateSize: function getDatalabelTemplateSize(templateIdCollection) {
      var templateSizeList = [];
      var templateSize;
      var templateIdLength = templateIdCollection.length;
      for (var i = 0; i < templateIdLength; i++) {
        templateSize = this.getElementBoundsById(templateIdCollection[i], false);
        templateSizeList.push({
          X: templateSize.width,
          Y: templateSize.height
        });
      }
      return JSON.stringify(templateSizeList);
    },
    setSvgDimensions: function setSvgDimensions(chartSVG, width, height) {
      chartSVG.setAttribute("width", width);
      chartSVG.setAttribute("height", height);
    },
    findDOMElement: function findDOMElement(id) {
      return document.getElementById(id);
    },
    calculateSelectedElements: function calculateSelectedElements(e, dataId) {
      if (sf.base.isNullOrUndefined(e.target)) {
        return;
      }
      var target = e.target;
      var charts = window.sfBlazor.getCompInstance(dataId);
      target = this.findDOMElement(this.findDOMElementFromDataLabel(target.id, charts));
      if (charts.selectionMode === 'None' && (charts.highlightMode === 'None' || charts.enableHighlight) || !sf.base.isNullOrUndefined(target) && target.id.indexOf(charts.element.id + '_') === -1) {
        return;
      }
      if (e.type === 'mousemove' || e.type === 'pointermove') {
        if (target === null && target.id.indexOf('Trackball') > -1) {
          target = this.findDOMElement(target.id.split('_Trackball')[0]);
        }
        if (target.hasAttribute('class') && (target.getAttribute('class').indexOf('highlight') > -1 || target.getAttribute('class').indexOf('selection') > -1)) {
          return;
        }
      }
      this.isAlreadySelected(e, charts);
      if (!sf.base.isNullOrUndefined(target) && target.id.indexOf('_Series_') > -1) {
        var element = void 0;
        if (target.id.indexOf('_Trackball_1') > -1) {
          element = this.findDOMElement(target.id.split('_Trackball_')[0] + '_Symbol');
          element = sf.base.isNullOrUndefined(element) ? this.findDOMElement(target.id.split('_Trackball_')[0]) : element;
        } else if (target.id.indexOf('_Trackball_0') > -1 || target.id.indexOf('_ErrorBarGroup_') > -1 || target.id.indexOf('_ErrorBarCap_') > -1) {
          return null;
        }
        this.performSelection(this.indexFinder(target.id), charts, element || target);
      }
    },
    generateStyle: function generateStyle(targetId, chart) {
      var dataPoint = !sf.base.isNullOrUndefined(this.findDOMElement(targetId)) ? this.findDOMElement(targetId).getAttribute('data-point') : null;
      var parentElement;
      if (!sf.base.isNullOrUndefined(this.findDOMElement(targetId))) {
        if (targetId.indexOf("SeriesGroup") > -1 || targetId.indexOf("SymbolGroup") > -1) {
          parentElement = document.getElementById(targetId).querySelectorAll("path,ellipse");
          dataPoint = parentElement.length > 0 ? parentElement[0].getAttribute('data-point') : null;
        }
      }
      if (!dataPoint) {
        return 'undefined';
      }
      var dataPointArray = dataPoint.split(",");
      var seriesType = dataPointArray[3];
      if (seriesType) {
        if (chart.styleId.indexOf('selection') > 1 && chart.selectionMode !== 'None') {
          chart.unSelected = dataPointArray[7] || chart.unSelected;
        }
        if (chart.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.enableHighlight)) {
          chart.unSelected = dataPointArray[5] || chart.unSelected;
        }
        return dataPointArray[6] || chart.styleId + '_series' + dataPointArray[4];
      }
      return 'undefined';
    },
    findDOMElementFromDataLabel: function findDOMElementFromDataLabel(id, charts) {
      if (id.indexOf('Text') > -1 && id.indexOf('Series') > -1) {
        var primId = id.split('_Text_')[0];
        if (this.isRectSeries(charts.seriesTypes[id.split("_Series_")[1].split("_")[0]]) || charts.seriesTypes[0] === 'Bubble' || charts.seriesTypes[0] === 'Scatter') {
          return primId;
        } else {
          return primId.slice(0, primId.length) + '_Symbol ';
        }
      }
      return id;
    },
    indexFinder: function indexFinder(id) {
      var ids = ['NaN', 'NaN'];
      if (id.indexOf('_Point_') > -1) {
        ids = id.split('_Series_')[1].split('_Point_');
        if (ids[1].indexOf('Text') > -1) {
          ids[1] = ids[1].split('_Text_')[0];
        }
      } else if (id.indexOf('_shape_') > -1 && !id.indexOf('_legend_')) {
        ids = id.split('_shape_');
        ids[0] = ids[1];
      } else if (id.indexOf('_text_') > -1 && !id.indexOf('_legend_')) {
        ids = id.split("_text_");
        if (id.indexOf("datalabel") > -1) {
          ids[0] = ids[0].split("_Series_")[1];
        } else {
          ids[0] = ids[1];
        }
      } else if (id.indexOf("Series") > -1 && !(id.indexOf("points") > -1)) {
        ids[0] = id.split("_Series_")[1].split("_")[0];
      }
      return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));
    },
    addOrRemoveIndex: function addOrRemoveIndex(indexes, index, charts, isAdd) {
      for (var i = 0; i < indexes.length; i++) {
        if (this.toEquals(indexes[i], index, charts.isSeriesMode, charts)) {
          indexes.splice(i, 1);
          i--;
        }
      }
      if (isAdd) {
        indexes.push(index);
      }
    },
    toEquals: function toEquals(first, second, checkSeriesOnly, chart) {
      return (first.series === second.series || chart.currentMode === 'Cluster' && !checkSeriesOnly) && (checkSeriesOnly || first.point === second.point);
    },
    removeSvgClass: function removeSvgClass(element, className) {
      var elementClassName = !sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.getAttribute('class')) ? element.getAttribute('class') : "";
      if (elementClassName.indexOf(className) > -1) {
        element.setAttribute('class', elementClassName.replace(className, ''));
      }
    },
    getSelectionClass: function getSelectionClass(id, chart) {
      return this.generateStyle(id, chart);
    },
    removeStyles: function removeStyles(elements, chart) {
      for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
        var element = elements_2[_i];
        if (element !== null) {
          var targetElement = element;
          var id = element.id;
          var dataPoint = this.findDOMElement(targetElement.id).getAttribute('data-point');
          var dataPointArray = dataPoint ? dataPoint.split(",") : [];
          if (targetElement.id.indexOf("_chart_legend_shape_") > -1) {
            id = chart.element.id + 'SeriesGroup' + chart.currentSeriesIndex;
          }
          this.removeSvgClass(element, this.getSelectionClass(id, chart));
          if (chart.highlightPattern === 'None' && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
            if (element.id.indexOf('Group') > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute('fill', dataPointArray[2]);
              }
            } else {
              element.setAttribute('fill', dataPointArray[2]);
            }
          }
        }
      }
    },
    findTrackballElements: function findTrackballElements(selectedElements, className, chart) {
      className = className.trim();
      var trackballElements;
      var elements;
      for (var i = 0; i < selectedElements.length; i++) {
        if (!sf.base.isNullOrUndefined(selectedElements[i])) {
          trackballElements = !sf.base.isNullOrUndefined(selectedElements[i].parentNode) ? [].slice.call(selectedElements[0].parentNode.querySelectorAll('.' + className)) : [];
          if (trackballElements.length > 0) {
            elements = [];
            for (var i_1 = 0; i_1 < trackballElements.length; i_1++) {
              if (trackballElements[i_1].id.indexOf('Trackball') > -1) {
                elements.push(trackballElements[i_1]);
              }
            }
            this.removeStyles(elements, chart);
          }
        }
      }
    },
    blurEffect: function blurEffect(chartId, charts, legendClick) {
      if (legendClick === void 0) {
        legendClick = false;
      }
      var visibility = this.checkVisibility(charts.highlightDataIndexes, charts) || this.checkVisibility(charts.selectedDataIndexes, charts);
      var seriesCollection = document.getElementById(charts.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");
      for (var i = 0; i < seriesCollection.length; i++) {
        var index = parseInt(seriesCollection[i].id.split('SeriesGroup')[1]);
        this.checkSelectionElements(this.findDOMElement(charts.element.id + 'SeriesGroup' + index), this.generateStyle(charts.element.id + 'SeriesGroup' + index, charts), visibility, legendClick, index, charts);
        if (!sf.base.isNullOrUndefined(this.findDOMElement(charts.element.id + 'SymbolGroup' + index))) {
          this.checkSelectionElements(this.findDOMElement(charts.element.id + 'SymbolGroup' + index), this.generateStyle(charts.element.id + 'SymbolGroup' + index, charts), visibility, legendClick, index, charts);
        }
      }
    },
    checkVisibility: function checkVisibility(selectedIndexes, chart) {
      if (!selectedIndexes) {
        return false;
      }
      var visible = false;
      var uniqueSeries = [];
      for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
        var index = selectedIndexes_1[_i];
        if (uniqueSeries.indexOf(index.series) === -1) {
          uniqueSeries.push(index.series);
        }
      }
      for (var _a = 0, uniqueSeries_1 = uniqueSeries; _a < uniqueSeries_1.length; _a++) {
        var index = uniqueSeries_1[_a];
        if (document.getElementById(chart.element.id + 'SeriesGroup' + index)) {
          visible = true;
          break;
        }
      }
      return visible;
    },
    findElements: function findElements(chart, series, index, suffix, marker) {
      if (suffix === void 0) {
        suffix = '';
      }
      if (chart.isSeriesMode) {
        return this.getSeriesElements(index.series.toString(), chart);
      } else if (chart.currentMode === 'Cluster') {
        return this.getClusterElements(chart, index);
      } else {
        return this.findDOMElementByIndex(chart, index, suffix, marker);
      }
    },
    removeMultiSelectElements: function removeMultiSelectElements(chart, index, currentIndex) {
      var series;
      var marker = this.getSeriesElements(currentIndex.series.toString(), chart);
      for (var i = 0; i < index.length; i++) {
        series = chart.seriesTypes[index[i].series];
        if (chart.isSeriesMode && !this.toEquals(index[i], currentIndex, chart.isSeriesMode, chart) || chart.currentMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false, chart) || !chart.isSeriesMode && this.toEquals(index[i], currentIndex, true, chart) && !this.toEquals(index[i], currentIndex, false, chart)) {
          this.removeStyles(this.findElements(chart, series, index[i], '', false), chart);
          if (chart.element.id + "SymbolGroup" + index[i].series) {
            this.removeStyles(this.findElements(chart, series, index[i], '', true), chart);
          }
          index.splice(i, 1);
          i--;
        }
      }
    },
    checkSelectionElements: function checkSelectionElements(element, className, visibility, legendClick, series, chart, Elements) {
      var children = [];
      className = className.trim();
      if (element.id.indexOf('Series') > -1) {
        if (this.pointIdRequired(chart.seriesTypes[series])) {
          children = chart.isSeriesMode ? [element] : element.querySelectorAll("[id*='_Series']");
          if (chart.seriesTypes[series] === 'Histogram') {
            children.push(this.findDOMElement(chart.element.id + '_Series_' + series + '_NDLine'));
          }
          if (chart.seriesTypes[series] === 'Waterfall') {
            children.push(this.findDOMElement(chart.element.id + '_Series_' + series + '_Connector'));
          }
          if (chart.seriesTypes[series] === 'BoxAndWhisker') {
            children = this.findDOMElement(chart.element.id + 'SymbolGroup' + series).querySelectorAll("path,ellipse");
          }
        } else {
          children = chart.isSeriesMode ? [element] : element.querySelectorAll("[id*='_Series']");
        }
      }
      if (chart.selectionMode !== 'None' || chart.highlightMode !== 'None' || chart.enableHighlight) {
        children = element.querySelectorAll("[id*='_Series']");
      }
      var elementClassName;
      var parentClassName;
      var legendShape;
      var selectElement = element;
      var parentElement = !this.isRectSeries(chart.seriesTypes[series]) ? this.findDOMElement(chart.element.id + "_Series_" + series) : null;
      for (var i = 0; i < children.length; i++) {
        elementClassName = children[i].getAttribute('class') || '';
        parentClassName = !sf.base.isNullOrUndefined(parentElement) ? parentElement.getAttribute('class') : '';
        if (chart.selectionMode !== 'None' || chart.highlightMode !== 'None' || chart.enableHighlight) {
          className = !sf.base.isNullOrUndefined(elementClassName) && (elementClassName.indexOf('selection') > 0 || elementClassName.indexOf('highlight') > 0) ? elementClassName : className;
          className = !sf.base.isNullOrUndefined(elementClassName) && (parentClassName.indexOf('selection') > 0 || parentClassName.indexOf('highlight') > 0) ? parentClassName : className;
        }
        if (!sf.base.isNullOrUndefined(elementClassName) && !sf.base.isNullOrUndefined(parentClassName) && elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(children[i], chart.unSelected);
        } else {
          selectElement = children[i];
          this.removeSvgClass(children[i], chart.unSelected);
          this.removeSvgClass(parentElement, chart.unSelected);
        }
        if (children[i].id.indexOf('Trackball') > 0 && selectElement.classList[0] === className) {
          this.removeSvgClass(children[i], chart.unSelected);
          this.removeSvgClass(parentElement, chart.unSelected);
          this.addSvgClass(children[i], className);
        }
      }
      if (element.id.indexOf('Symbol') > -1) {
        if (element.querySelectorAll('.' + className)[0] && element.querySelectorAll('.' + className)[0].getAttribute('class') === className) {
          var symbolEle = this.findDOMElement(element.id + '_Series_' + element.id[element.id.length - 1]);
          var seriesClassName = symbolEle && symbolEle.hasAttribute('class') ? symbolEle.getAttribute('class') : '';
          if (seriesClassName.indexOf(chart.unSelected) > -1) {
            this.removeSvgClass(symbolEle, chart.unSelected);
          }
        }
      }
      var dataPoint = this.findDOMElement(element.id).getAttribute('data-point');
      var parentElementDp;
      if (element.id.indexOf("SeriesGroup") > -1 || element.id.indexOf("SymbolGroup") > -1) {
        parentElementDp = document.getElementById(element.id).querySelectorAll("path,ellipse");
        dataPoint = parentElementDp.length > 0 ? parentElementDp[0].getAttribute('data-point') : null;
      }
      if (!dataPoint) {
        return;
      }
      var dataPointArray = dataPoint.split(",");
      legendShape = this.findDOMElement(chart.id + '_chart_legend_shape_' + series);
      if (legendShape) {
        if (legendShape.hasAttribute('class')) {
          this.removeSvgClass(legendShape, legendShape.getAttribute('class'));
          if (!sf.base.isNullOrUndefined(chart.highlightColor && chart.highlightColor !== '')) {
            legendShape.setAttribute('stroke', dataPointArray[2]);
            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', dataPointArray[2]);
            }
          }
        }
        elementClassName = selectElement.getAttribute('class') || '';
        parentClassName = selectElement.parentNode.getAttribute('class') || '';
        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {
          this.addSvgClass(legendShape, chart.unSelected);
          this.removeSvgClass(legendShape, className);
          if (chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
            legendShape.setAttribute('stroke', dataPointArray[2]);
            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', dataPointArray[2]);
            }
          }
        } else {
          this.removeSvgClass(legendShape, chart.unSelected);
          if (!sf.base.isNullOrUndefined(chart.highlightColor) && chart.highlightColor !== '') {
            legendShape.setAttribute('stroke', dataPointArray[2]);
            if (chart.highlightPattern === 'None') {
              legendShape.setAttribute('fill', dataPointArray[2]);
            }
          }
          if (elementClassName.trim() == "e-chart-focused") {
            elementClassName = '';
          }
          if (elementClassName === '' && parentClassName === '' || elementClassName.trim() === 'EJ2-Trackball') {
            this.removeSvgClass(legendShape, className);
          } else {
            this.addSvgClass(legendShape, className);
            if (className.indexOf('highlight') > 0 && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor)) {
              legendShape.setAttribute('stroke', chart.highlightColor);
              if (chart.styleId.indexOf('highlight') > 0 && chart.highlightPattern === 'None') {
                legendShape.setAttribute('fill', chart.highlightColor);
              }
            }
          }
        }
        if (legendClick && parentClassName.indexOf(className) > -1) {
          this.addSvgClass(legendShape, className);
        }
      }
    },
    addSvgClass: function addSvgClass(element, className) {
      var elementClassName = element.getAttribute('class') || '';
      elementClassName += elementClassName !== '' ? ' ' : '';
      if (elementClassName.indexOf(className) === -1) {
        element.setAttribute('class', elementClassName + className);
      }
    },
    isRectSeries: function isRectSeries(seriesType) {
      if (seriesType === 'Column' || seriesType === 'StackingColumn' || seriesType === 'StackingColumn100' || seriesType === 'Bar' || seriesType === 'StackingBar' || seriesType === 'StackingBar100' || seriesType === 'RangeColumn' || seriesType === 'Histogram' || seriesType === 'BoxAndWhisker' || seriesType === 'Waterfall' || seriesType === "Pareto" || seriesType === 'RangeArea' || seriesType === 'SplineRangeArea' || seriesType === 'RangeStepArea' || seriesType === "Hilo" || seriesType === "HiloOpenClose" || seriesType === "Candle") {
        return true;
      } else {
        return false;
      }
    },
    pointIdRequired: function pointIdRequired(seriesType) {
      if (this.isRectSeries(seriesType) || seriesType === 'Bubble' || seriesType === 'Scatter') {
        return true;
      } else {
        return false;
      }
    },
    getSeriesElements: function getSeriesElements(index, chart) {
      var seriesElements;
      var seriesElementsArray = [];
      var isMarker = !sf.base.isNullOrUndefined(document.getElementById(chart.element.id + 'SymbolGroup' + index)) && chart.seriesTypes[index] !== 'Scatter' && chart.seriesTypes[index] !== 'Bubble' && !this.isRectSeries(chart.seriesTypes[index]);
      if (isMarker) {
        seriesElements = this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' path');
        seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' ellipse'))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SymbolGroup' + index).querySelectorAll('#' + chart.element.id + 'SymbolGroup' + index + ' ellipse');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      } else if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index))) {
        seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
        seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse'))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      }
      if (chart.seriesTypes[index].indexOf('Area') > -1 || chart.seriesTypes[index].toLowerCase().indexOf('line') > -1) {
        if (isMarker) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
          seriesElementsArray.push.apply(seriesElementsArray, this.addSeriesElements(seriesElementsArray, seriesElements));
        } else if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      }
      if (chart.seriesTypes[index] === 'Histogram') {
        var seriesElement = this.findDOMElement(chart.element.id + '_Series_' + index + '_NDLine');
        seriesElementsArray.push(seriesElement);
      }
      if ((chart.seriesTypes[index] === 'Polar' || chart.seriesTypes[index] === 'Radar') && chart.drawType[index] === 'Scatter' && !sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index))) {
        seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' path');
        seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        if (!sf.base.isNullOrUndefined(this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse'))) {
          seriesElements = this.findDOMElement(chart.element.id + 'SeriesGroup' + index).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + index + ' ellipse');
          seriesElementsArray = this.addSeriesElements(seriesElementsArray, seriesElements);
        }
      }
      return seriesElementsArray;
    },
    addSeriesElements: function addSeriesElements(seriesElements, markerElements) {
      for (var i = 0; i < markerElements.length; i++) {
        var element = document.getElementById(markerElements[i].id);
        if (element != null) {
          seriesElements.push(element);
        }
        seriesElements = seriesElements.filter(function (elem, index, self) {
          return index === self.indexOf(elem);
        });
      }
      return seriesElements;
    },
    findDOMElementByIndex: function findDOMElementByIndex(chart, index, suffix, marker) {
      if (suffix === void 0) {
        suffix = '';
      }
      var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;
      var series = chart.seriesTypes[index.series];
      elementId = !this.isRectSeries(series) && series !== 'Scatter' && series !== 'Bubble' && marker ? elementId + '_Symbol' + suffix : elementId;
      if (series === 'BoxAndWhisker') {
        elementId = elementId + "_BoxPath";
      }
      return [this.findDOMElement(elementId), (series === 'RangeArea' || series === 'SplineRangeArea') && marker ? this.findDOMElement(elementId + '1') : null];
    },
    applyStyles: function applyStyles(elements, chart) {
      for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
        var element = elements_3[_i];
        if (element) {
          this.removeSvgClass(element, chart.unSelected);
          this.addSvgClass(element, this.getSelectionClass(element.id, chart));
          if (chart.styleId.indexOf('highlight') > 0 && chart.highlightColor !== '' && !sf.base.isNullOrUndefined(chart.highlightColor) && chart.highlightPattern === 'None') {
            if (element.id.indexOf('Group') > 0) {
              for (var i = 0; i < element.children.length; i++) {
                element.children[i].setAttribute('fill', chart.highlightColor);
              }
            } else {
              element.setAttribute('fill', chart.highlightColor);
            }
          }
        }
      }
    },
    getClusterElements: function getClusterElements(chart, index) {
      var clusters = [];
      var seriesStyle;
      var selectedElements;
      var seriesCollection = document.getElementById(chart.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");
      var seriesMarkerCollection = document.getElementById(chart.element.id + "SeriesCollection").querySelectorAll("[id*='SymbolGroup']");
      var seriesElements;
      var seriesElementsArray;
      for (var seriesG = 0; seriesG < seriesCollection.length; seriesG++) {
        seriesElements = seriesCollection[seriesG].querySelectorAll('#' + seriesCollection[seriesG].id + ' path');
        seriesElementsArray = Array.prototype.slice.call(seriesElements);
        for (var series = 0; series < seriesElementsArray.length; series++) {
          var seriesData = seriesElementsArray[series].getAttribute('data-point').split(',');
          index = new Index(+seriesData[4], index.point);
          if (this.isRectSeries(seriesData[3])) {
            clusters.push(this.findDOMElementByIndex(chart, index)[0]);
          }
          clusters.push(this.findDOMElementByIndex(chart, index, '', seriesData[9] === 'True')[0]);
          seriesStyle = this.generateStyle(seriesElementsArray[series].id, chart);
          selectedElements = document.querySelectorAll('.' + seriesStyle);
          this.findTrackballElements(selectedElements, seriesStyle);
          var clusterIndex = seriesData[9] === 'True' && this.isRectSeries(seriesData[3]) ? 2 : 1;
          if (!chart.allowMultiSelection && selectedElements.length > 0 && selectedElements[0].id !== clusters[clusters.length - clusterIndex].id) {
            this.removeSelection(chart, index.series, selectedElements, seriesStyle, true);
          }
        }
      }
      return clusters;
    },
    clusterSelection: function clusterSelection(chart, index) {
      this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));
    },
    removeSelection: function removeSelection(chart, series, selectedElements, seriesStyle, isBlurEffectNeeded) {
      var elementId;
      var seriesElements = document.getElementById(chart.element.id + 'SeriesGroup' + series).querySelectorAll('#' + chart.element.id + 'SeriesGroup' + series + ' path');
      var seriesElementsArray = Array.prototype.slice.call(seriesElements);
      if (selectedElements.length > 0) {
        var elements = [];
        for (var i = 0; i < selectedElements.length; i++) {
          elements.push(selectedElements[i]);
        }
        this.removeStyles(elements, chart);
        chart.isSeriesMode = true;
        this.addOrRemoveIndex(chart.selectedDataIndexes, new Index(series, NaN), chart);
        for (var value = 0; value < selectedElements.length; value++) {
          elementId = selectedElements[value].id;
          seriesStyle = this.generateStyle(elementId, chart);
          if (document.querySelectorAll('.' + seriesStyle).length > 0) {
            for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
              var element = elements_4[_i];
              this.checkSelectionElements(element, seriesStyle, true, true, series, chart);
            }
            isBlurEffectNeeded = false;
            break;
          }
        }
        if (isBlurEffectNeeded) {
          chart.isSeriesMode = chart.selectionMode === 'Series';
          this.blurEffect(elementId, chart);
        }
      }
    },
    isAlreadySelected: function isAlreadySelected(event, charts) {
      var targetElement = event.target;
      if (event.type === 'click') {
        charts.currentMode = charts.selectionMode;
        charts.styleId = charts.element.id + '_ej2_chart_selection';
      } else if (event.type === 'mousemove' || event.type === 'pointermove') {
        charts.currentMode = charts.highlightMode;
        charts.highlightDataIndexes = [];
        charts.styleId = charts.element.id + '_ej2_chart_highlight';
      }
      if ((charts.highlightMode !== 'None' || charts.enableHighlight) && charts.selectionMode === 'None') {
        if (event.type === 'click') {
          return false;
        }
      }
      if ((charts.highlightMode !== 'None' || charts.enableHighlight) && charts.previousSelectedEle.length !== 0 && charts.previousSelectedEle[0] !== null) {
        charts.previousSelectedEle.filter(function (element) {
          return element !== null;
        });
        var parentNodeId = targetElement.parentNode.id;
        var isElement = void 0;
        if (targetElement.parentNode) {
          isElement = parentNodeId.indexOf('Point') > 0 || parentNodeId.indexOf('Symbol') > 0 ? true : false;
        }
        for (var i = 0; i < charts.previousSelectedEle.length; i++) {
          if (charts.previousSelectedEle[i].hasAttribute('class')) {
            if (charts.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1 && (isElement || event.type === 'click')) {
              charts.previousSelectedEle[i].removeAttribute('class');
              if (charts.highlightColor !== '' && !sf.base.isNullOrUndefined(charts.highlightColor) && charts.highlightPattern === 'None') {
                if (charts.previousSelectedEle[i].id.indexOf('Group') > 0) {
                  for (var j = 0; j < charts.previousSelectedEle[i].children.length; j++) {
                    var child = charts.previousSelectedEle[i].children[j];
                    child.setAttribute('fill', child.getAttribute('data-point').split(',')[2]);
                  }
                } else {
                  charts.previousSelectedEle[i].setAttribute('fill', charts.previousSelectedEle[i].getAttribute('data-point').split(',')[2]);
                }
              }
              this.addOrRemoveIndex(charts.highlightDataIndexes, this.indexFinder(charts.previousSelectedEle[i].id), charts);
            } else if (!isElement && charts.previousSelectedEle[i].getAttribute('class').indexOf('highlight') > -1) {
              this.performSelection(this.indexFinder(charts.previousSelectedEle[i].id), charts, charts.previousSelectedEle[i]);
            }
          }
        }
      }
      return true;
    },
    performSelection: function performSelection(index, chart, element) {
      chart.isSeriesMode = chart.currentMode === "Series";
      if (chart.seriesTypes[index.series] === 'BoxAndWhisker' && element && element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {
        element = element.parentNode;
      }
      if (chart.seriesTypes[index.series] === 'Area' && (chart.currentMode === 'Point' || chart.currentMode === 'Cluster') && element && element.id === chart.element.id + '_Series_' + index.series) {
        var className = this.generateStyle(element.id, chart);
        var selectionEle = document.querySelectorAll('.' + className);
        if (!sf.base.isNullOrUndefined(selectionEle)) {
          this.findTrackballElements(selectionEle, className);
          this.blurEffect(element.id, chart, element.getAttribute('data-point').split(',')[8] === 'True');
        }
      }
      switch (chart.currentMode) {
        case 'Series':
          this.selection(chart, index, this.getSeriesElements(index.series.toString(), chart));
          this.selectionComplete(chart, index, chart.selectionMode);
          this.blurEffect(element.id, chart);
          break;
        case 'Point':
          if (!isNaN(index.point) && element) {
            var pointElements = [];
            pointElements.push(element);
            this.selection(chart, index, pointElements);
            this.selectionComplete(chart, index, chart.selectionMode);
            this.blurEffect(element.id, chart);
          }
          break;
        case 'Cluster':
          if (!isNaN(index.point)) {
            this.clusterSelection(chart, index);
            this.selectionComplete(chart, index, chart.selectionMode);
            this.blurEffect(element.id, chart);
          }
          break;
      }
    },
    selection: function selection(chart, index, selectedElements) {
      selectedElements = selectedElements.filter(function (element) {
        return element !== null;
      });
      if (!(chart.currentMode === 'Lasso')) {
        if (!chart.allowMultiSelection && chart.currentMode.indexOf('Drag') === -1 && chart.styleId.indexOf('highlight') === -1 && chart.selectionMode !== 'None') {
          this.removeMultiSelectElements(chart, chart.selectedDataIndexes, index, selectedElements);
        }
      }
      if (!sf.base.isNullOrUndefined(selectedElements[0])) {
        if (this.isRectSeries(chart.seriesTypes[index.series]) && chart.seriesTypes[index.series] !== 'Histogram') {
          if (selectedElements[0].id) {
            if (document.getElementById(selectedElements[0].id + '_Symbol')) {
              selectedElements.push(this.findDOMElement(selectedElements[0].id + '_Symbol'));
            } else if (selectedElements[0].id.indexOf('SeriesGroup') !== -1) {
              if (document.getElementById(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup'))) {
                selectedElements.push(this.findDOMElement(selectedElements[0].id.replace('SeriesGroup', 'SymbolGroup')));
              }
            }
          }
        }
        var isAdd = void 0;
        var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');
        var pClassName = selectedElements[0].parentNode && (selectedElements[0].parentNode.getAttribute('class') || '');
        if (className !== '' && chart.currentMode !== 'Cluster') {
          this.findTrackballElements(selectedElements, className);
        }
        if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id, chart)) > -1) {
          this.removeStyles(selectedElements, chart);
        } else if (selectedElements[0].parentNode && pClassName.indexOf(this.getSelectionClass(selectedElements[0].id, chart)) > -1) {
          this.removeStyles([selectedElements[0].parentNode], chart);
        } else {
          chart.previousSelectedEle = chart.highlightMode !== 'None' || chart.enableHighlight ? selectedElements : [];
          this.applyStyles(selectedElements, chart);
          isAdd = true;
        }
        if (chart.styleId.indexOf('highlight') > 0 && (chart.highlightMode !== 'None' || chart.enableHighlight)) {
          this.addOrRemoveIndex(chart.highlightDataIndexes, index, chart, isAdd);
        } else {
          this.addOrRemoveIndex(chart.selectedDataIndexes, index, chart, isAdd);
        }
      }
    },
    resetPreviousHighlightIndex: function resetPreviousHighlightIndex(chart) {
      chart.previousHighlightedIndex = -1;
    },
    isTargetChanged: function isTargetChanged(currentSeriesIndex, chart) {
      var isStart = false;
      var isEquals = false;
      if (chart.previousHighlightedIndex == -1) {
        isStart = true;
      }
      if (chart.previousHighlightedIndex == currentSeriesIndex) {
        isEquals = true;
      }
      chart.previousHighlightedIndex = currentSeriesIndex;
      return !isEquals || isStart;
    },
    legendSelection: function legendSelection(e, dataId) {
      var targetId = e.target['id'];
      var charts = window.sfBlazor.getCompInstance(dataId);
      var values = [this.id + "_chart_legend_text_", this.id + "_chart_legend_shape_marker_", this.id + "_chart_legend_shape_", this.id + "_chart_legend_g_"];
      var currentMode = 'None';
      var selectedElements;
      var currentIndex;
      var targetElement;
      if (targetId.indexOf("legend") != -1 && !charts.isTouch) {
        for (var i = 0; i < values.length; i++) {
          if (!targetId.indexOf(values[i])) {
            currentIndex = parseInt(targetId.split(values[i])[1]);
            break;
          }
        }
        charts.currentSeriesIndex = currentIndex;
        if (targetId.indexOf("text") <= 0) {
          targetElement = Chart.findDOMElement(targetId);
        } else {
          targetElement = null;
        }
        if (e.type === "mousemove") {
          if (targetId.indexOf('text')) {
            targetElement = Chart.findDOMElement(targetId.replace('text', 'shape'));
          }
          if (targetElement.hasAttribute('class') && !charts.enableHighlight) {
            if (charts.styleId.indexOf('highlight') > 0 && (charts.highlightMode !== 'None' || charts.enableHighlight) && charts.styleId.indexOf('selection') > 1 && charts.selectionMode !== 'None') {
              return;
            }
          }
          currentMode = charts.highlightMode;
          if (currentMode == 'None' && charts.enableHighlight) {
            currentMode = 'Series';
          }
        }
        var isPreSelected = this.isAlreadySelected(e, charts);
        if (isPreSelected && !sf.base.isNullOrUndefined(this.findDOMElement(charts.element.id + 'SeriesGroup' + currentIndex))) {
          this.seriesStyle = this.generateStyle(charts.element.id + 'SeriesGroup' + currentIndex, charts);
          selectedElements = document.querySelectorAll('.' + this.seriesStyle);
          this.isSeriesMode = currentMode == 'Series';
          this.isBlurEffectNeeded = true;
          if (selectedElements.length > 0) {
            this.removeSelection(charts, currentIndex, selectedElements, this.seriesStyle, this.isBlurEffectNeeded);
          } else {
            var seriesCollection = document.getElementById(charts.element.id + "SeriesCollection").querySelectorAll("[id*='SeriesGroup']");
            for (var seriesG = 0; seriesG < seriesCollection.length; seriesG++) {
              if (!charts.allowMultiSelection && seriesG != currentIndex) {
                this.seriesStyle = this.generateStyle(seriesCollection[seriesG].id, charts);
                selectedElements = document.querySelectorAll('.' + this.seriesStyle);
                this.removeSelection(charts, currentIndex, selectedElements, this.seriesStyle, this.isBlurEffectNeeded);
              }
            }
            var seriesElements = this.getSeriesElements(currentIndex.toString(), charts);
            for (var i = 0; i < seriesElements.length; i++) {
              this.checkSelectionElements(seriesElements[i], this.seriesStyle, false, true, currentIndex, charts, seriesElements);
            }
            charts.isSeriesMode = true;
            var indexAndPoint = new Index(currentIndex, 0);
            this.selection(charts, indexAndPoint, seriesElements);
            this.isSeriesMode = this.selectionMode == 'Series';
            this.blurEffect(charts.element.id, charts, true);
          }
        }
      }
    },
    selectionComplete: function selectionComplete(chart, index, selectionMode) {
      var pointX;
      var pointY;
      var regionY;
      var pointIndex;
      var seriesIndex;
      var pointId;
      var selectedPointValues = [];
      var yValue;
      var selectedPointX;
      var seriesType;
      var SeriesCategory;
      var seriesArray = this.getSeriesElements(index.series.toString(), chart);
      if (selectionMode === 'Cluster') {
        for (var i = 0; i < seriesArray.length; i++) {
          seriesType = this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[3];
          SeriesCategory = this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[11];
          regionY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[10];
          if (this.findDOMElement(seriesArray[i].id).getAttribute('visibility') === 'visible') {
            for (var j = 0; j < chart.selectedDataIndexes.length; j++) {
              pointIndex = chart.allowMultiSelection ? chart.selectedDataIndexes[j].point : index.point;
              seriesIndex = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[4];
              pointX = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[0];
              pointY = +this.findDOMElement(seriesArray[i].id).getAttribute('data-point').split(',')[1];
              if (!isNaN(pointIndex)) {
                yValue = seriesType !== 'RangeArea' || 'SplineRangeArea' ? pointY : regionY;
                selectedPointX = pointX;
              }
              if (chart.primaryXAxis === 'Category') {
                selectedPointX = pointX.toLocaleString();
              } else if (chart.primaryXAxis === 'DateTime') {
                selectedPointX = new Date(pointX);
              }
              if (SeriesCategory !== 'Indicator') {
                selectedPointValues.push({
                  x: selectedPointX,
                  y: yValue,
                  seriesIndex: seriesIndex,
                  pointIndex: pointIndex
                });
              }
              if (seriesType === 'RangeArea' || seriesType === 'SplineRangeArea') {
                selectedPointValues.push({
                  x: selectedPointX,
                  y: regionY,
                  seriesIndex: seriesIndex,
                  pointIndex: pointIndex
                });
              }
            }
          }
        }
      } else if (selectionMode === 'Series') {
        if (chart.allowMultiSelection) {
          for (var i = 0; i < chart.selectedDataIndexes.length; i++) {
            seriesIndex = chart.selectedDataIndexes[i].series;
            selectedPointValues.push({
              seriesIndex: seriesIndex
            });
          }
        } else {
          seriesIndex = chart.selectedDataIndexes.length > 0 ? chart.selectedDataIndexes[0].series : 0;
          selectedPointValues.push({
            seriesIndex: seriesIndex
          });
        }
      } else if (selectionMode === 'Point') {
        for (var i = 0; i < chart.selectedDataIndexes.length; i++) {
          pointIndex = chart.selectedDataIndexes[i].point;
          seriesIndex = chart.selectedDataIndexes[i].series;
          pointId = chart.element.id + "_Series_" + seriesIndex + "_Point_" + pointIndex;
          pointX = +this.findDOMElement(pointId).getAttribute('data-point').split(',')[0];
          pointY = +this.findDOMElement(pointId).getAttribute('data-point').split(',')[1];
          regionY = +this.findDOMElement(pointId).getAttribute('data-point').split(',')[10];
          if (!isNaN(pointIndex)) {
            selectedPointX = pointX;
            yValue = seriesType !== 'RangeArea' || 'SplineRangeArea' ? pointY : regionY;
            if (chart.primaryXAxis === 'Category') {
              selectedPointX = pointX.toLocaleString();
            } else if (chart.primaryXAxis === 'DateTime') {
              selectedPointX = new Date(pointX);
            }
            selectedPointValues.push({
              x: selectedPointX,
              y: yValue,
              seriesIndex: seriesIndex,
              pointIndex: pointIndex
            });
          }
        }
      }
      chart.dotnetref.invokeMethodAsync("OnSelectionChange", selectedPointValues);
    },
    addTouchPointer: function addTouchPointer(touchList, e, touches) {
      if (touches.length > 0) {
        touchList = touches;
      } else {
        touchList = touchList.length > 0 ? touchList : [];
        if (touchList.length == 0) {
          touchList.push({
            pageX: e.mouseX,
            pageY: e.mouseY,
            pointerId: e.pointerId
          });
        } else {
          for (var i = 0; i < touchList.length; i++) {
            if (touchList[i].pointerId == e.pointerId) {
              touchList[i] = {
                pageX: e.mouseX,
                pageY: e.mouseY,
                pointerId: e.pointerId
              };
            } else {
              touchList.push({
                pageX: e.mouseX,
                pageY: e.mouseY,
                pointerId: e.pointerId
              });
            }
          }
        }
      }
      return touchList;
    },
    onZoomingMouseMove: function onZoomingMouseMove(e, chart) {
      var touches = [];
      if (e.type === 'touchmove') {
        touches = e.touches;
      }
      if (chart.zoomBase.isChartDrag) {
        if (chart.zoomBase.zoomSettings.isOnZoomStartCalled) {
          chart.dotnetref.invokeMethodAsync('TriggerZoomingEvents', 'OnZoomStart', !chart.zoomBase.zoomingModule.isZoomStart);
          chart.zoomBase.zoomingModule.isZoomStart = false;
        }
        if (chart.isTouch) {
          chart.zoomBase.zoomingModule.touchMoveList = this.addTouchPointer(chart.zoomBase.zoomingModule.touchMoveList, e, touches);
          if (chart.zoomBase.zoomSettings.enablePinchZooming && chart.zoomBase.zoomingModule.touchMoveList.length > 1 && chart.zoomBase.zoomingModule.touchStartList.length > 1) {
            this.performPinchZooming(chart);
          }
        }
        this.renderZooming(e, chart, chart.isTouch);
      }
    },
    onZoomingMouseEnd: function onZoomingMouseEnd(e, chart) {
      chart.zoomBase.isChartDrag = false;
      var performZoomRedraw = !(e.target.indexOf(chart.element.id + '_ZoomOut') > -1) || e.target.indexOf(chart.element.id + '_ZoomIn') > -1;
      if (chart.zoomBase.isChartDrag || performZoomRedraw) {
        this.clearSelectionRect(chart.element.id + '_ZoomArea');
        this.performZoomRedraw(chart);
        if (chart.zoomBase.zoomSettings.isOnZoomEndCalled && !chart.zoomToolkitBase.isReset && chart.zoomBase.zoomingModule.zoomAxes.length > 0) {
          chart.dotnetref.invokeMethodAsync('TriggerZoomingEvents', 'OnZoomEnd', false);
        }
        chart.zoomBase.zoomingModule.isZoomStart = true;
      }
      if (chart.isTouch) {
        if (chart.zoomBase.isDoubleTap && sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect) && chart.zoomBase.zoomingModule.touchStartList.length == 1 && chart.zoomBase.zoomingModule.isZoomed) {
          this.zoomToolkitReset(chart);
          chart.zoomBase.zoomingModule.isZoomStart = true;
        }
        chart.zoomBase.zoomingModule.touchStartList = [];
        chart.zoomBase.isDoubleTap = false;
      }
      chart.zoomToolkitBase.isReset = false;
      chart.zoomBase.zoomingModule.zoomAxes = [];
    },
    onZoomingMouseDown: function onZoomingMouseDown(e, chart) {
      var offset = sf.base.Browser.isDevice ? 20 : 30;
      chart.zoomBase.mouseDownX = chart.zoomBase.previousMouseMoveX = e.mouseX;
      chart.zoomBase.mouseDownY = chart.zoomBase.previousMouseMoveY = e.mouseY;
      if (chart.isTouch) {
        chart.zoomBase.isDoubleTap = new Date().getTime() < chart.zoomBase.threshold && !(e.target.indexOf(chart.element.id + '_Zooming') > -1) && (chart.zoomBase.mouseDownX - offset >= chart.mouseX || chart.zoomBase.mouseDownX + offset >= chart.mouseX) && (chart.zoomBase.mouseDownY - offset >= chart.mouseY || chart.zoomBase.mouseDownY + offset >= chart.mouseY) && (chart.mouseX - offset >= chart.zoomBase.mouseDownX || chart.mouseX + offset >= chart.zoomBase.mouseDownX) && (chart.mouseY - offset >= chart.zoomBase.mouseDownY || chart.mouseY + offset >= chart.zoomBase.mouseDownY);
      }
      this.zoomingMouseDownHandler(e, chart);
    },
    zoomingMouseDownHandler: function zoomingMouseDownHandler(args, chart) {
      if (!(args.target.indexOf(chart.element.id + '_Zooming') > -1 || args.target.indexOf(chart.element.id + '_scrollBar') > -1) && sf.svgbase.withInAreaBounds(chart.zoomBase.previousMouseMoveX, chart.zoomBase.previousMouseMoveY, chart.userInteractionBase.axisClipRect)) {
        chart.zoomBase.isChartDrag = true;
      }
      if (chart.isTouch) {
        chart.zoomBase.zoomingModule.touchStartList = this.addTouchPointer(chart.zoomBase.zoomingModule.touchStartList, args, args.touches);
      }
    },
    zoomingMouseWheelHandler: function zoomingMouseWheelHandler(e, chart) {
      var target = e.target;
      if (chart.zoomBase.zoomSettings && chart.zoomBase.zoomSettings.enableMouseWheelZooming && sf.svgbase.withInAreaBounds(chart.mouseX, chart.mouseY, chart.userInteractionBase.axisClipRect) && !(target.id.indexOf('scrollbar') > -1)) {
        this.performMouseWheelZooming(e, chart.mouseX, chart.mouseY, chart, chart.userInteractionBase.axes);
      }
      if (this.isMouseWheelScroll(target.id)) {
        chart.scrollbarBase.isScrollWheel = chart.scrollbarBase.isScrollWheel ? chart.scrollbarBase.isScrollWheel : true;
        this.performMouseWheelScrolling(e, chart.mouseX, chart.mouseY, chart, chart.userInteractionBase.axes);
      }
    },
    renderZooming: function renderZooming(e, chart, isTouch) {
      this.calculateZoomAxesRange(chart);
      if (chart.zoomBase.zoomSettings.enableSelectionZooming && !chart.zoomBase.zoomSettings.enablePan && (!isTouch || chart.zoomBase.isDoubleTap && chart.zoomBase.zoomingModule.touchStartList.length == 1) && (!chart.zoomBase.zoomingModule.isPanning || chart.zoomBase.isDoubleTap)) {
        chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.zoomingModule.isDevice ? true : chart.zoomBase.zoomingModule.isPanning;
        chart.zoomBase.zoomingModule.performedUI = true;
        this.drawZoomingRectangle(chart);
      } else if (chart.zoomBase.zoomingModule.isPanning && chart.zoomBase.isChartDrag && (!isTouch || isTouch && chart.zoomBase.zoomingModule.touchStartList.length == 1)) {
        chart.zoomBase.zoomingModule.pinchTarget = isTouch ? e.target : null;
        this.doPan(chart, chart.zoomBase.axisCollections);
      }
    },
    calculateZoomAxesRange: function calculateZoomAxesRange(chart) {
      var range;
      var axisRange;
      for (var index = 0; index < chart.zoomBase.axisCollections.length; index++) {
        var axis = chart.zoomBase.axisCollections[index];
        axisRange = axis.visibleRange;
        if (chart.zoomBase.zoomingModule.zoomAxes.length > index && chart.zoomBase.zoomingModule.zoomAxes[index] && !chart.zoomBase.delayRedraw) {
          chart.zoomBase.zoomingModule.zoomAxes[index].min = axisRange.start;
          chart.zoomBase.zoomingModule.zoomAxes[index].delta = axisRange.delta;
        } else {
          range = {
            actualMin: axis.actualRange.start,
            actualDelta: axis.actualRange.delta,
            min: axisRange.start,
            delta: axisRange.delta
          };
          chart.zoomBase.zoomingModule.zoomAxes[index] = range;
        }
      }
    },
    drawZoomingRectangle: function drawZoomingRectangle(chart) {
      var areaBounds = chart.userInteractionBase.axisClipRect;
      var startLocation = new IChartInternalLocation(chart.zoomBase.previousMouseMoveX, chart.zoomBase.previousMouseMoveY);
      var endLocation = new IChartInternalLocation(chart.mouseX, chart.mouseY);
      var svgElement = this.getElement(chart.element.id + '_svg');
      var rect = chart.zoomBase.zoomingModule.zoomingRect = this.getRectLocation(startLocation, endLocation, areaBounds);
      if (rect.width > 0 && rect.height > 0) {
        chart.zoomBase.zoomingModule.isZoomed = true;
        chart.userInteractionBase.disableTrackTooltip = chart.isChartZoom = true;
        this.setAttribute(chart.userInteractionBase.isStockChart ? chart.element.id : svgElement.id, 'cursor', 'crosshair');
        if (chart.zoomBase.zoomingModule.zooming.mode == 'X') {
          rect.height = areaBounds.height;
          rect.y = areaBounds.y;
        } else if (chart.zoomBase.zoomingModule.zooming.mode == 'Y') {
          rect.width = areaBounds.width;
          rect.x = areaBounds.x;
        }
        var zoomKitElement = this.getElement(chart.element.id + chart.zoomBase.zoomToolkitId);
        if (zoomKitElement) {
          zoomKitElement.style.visibility = 'hidden';
        }
        if (svgElement) {
          svgElement.appendChild(chart.userInteractionBase.svgRenderer.drawRectangle(new RectOption(chart.element.id + '_ZoomArea', chart.zoomBase.zoomingModule.zooming.themeStyleSelectionRectFill, {
            color: chart.zoomBase.zoomingModule.zooming.themeStyleSelectionRectStroke,
            width: 1
          }, 1, rect, 0, 0, '', '3')));
        } else {
          var chartElement = document.getElementById(chart.element.id);
          chartElement.appendChild(chart.userInteractionBase.svgRenderer.drawRectangle(new RectOption(chart.element.id + '_ZoomArea', chart.zoomBase.zoomingModule.zooming.themeStyleSelectionRectFill, {
            color: chart.zoomBase.zoomingModule.zooming.themeStyleSelectionRectStroke,
            width: 1
          }, 1, rect, 0, 0, '', '3')));
        }
      }
    },
    getRectLocation: function getRectLocation(startLocation, endLocation, outerRect) {
      var x = endLocation.x < outerRect.x ? outerRect.x : endLocation.x > outerRect.x + outerRect.width ? outerRect.x + outerRect.width : endLocation.x;
      var y = endLocation.y < outerRect.y ? outerRect.y : endLocation.y > outerRect.y + outerRect.height ? outerRect.y + outerRect.height : endLocation.y;
      return new sf.svgbase.Rect(x > startLocation.x ? startLocation.x : x, y > startLocation.y ? startLocation.y : y, Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));
    },
    getVisibleRangeModel: function getVisibleRangeModel(doubleRange, interval) {
      return {
        min: doubleRange.start,
        max: doubleRange.end,
        interval: interval,
        delta: doubleRange.delta
      };
    },
    minMax: function minMax(factor, min, max) {
      return isFinite(factor) ? factor > max ? max : factor < min ? min : factor : 0;
    },
    doPan: function doPan(chart, axes, xDiff, yDiff, isKeyboardFocus) {
      if (xDiff === void 0) {
        xDiff = 0;
      }
      if (yDiff === void 0) {
        yDiff = 0;
      }
      if (isKeyboardFocus === void 0) {
        isKeyboardFocus = false;
      }
      if (chart.userInteractionBase.startMove && chart.crosshairBase.crosshair.enable) {
        return;
      }
      chart.isChartPanning = true;
      chart.zoomBase.zoomingModule.isZoomed = true;
      chart.zoomBase.zoomingModule.offset = !chart.zoomBase.delayRedraw ? chart.userInteractionBase.axisClipRect : chart.zoomBase.zoomingModule.offset;
      chart.zoomBase.delayRedraw = chart.userInteractionBase.disableTrackTooltip = chart.isChartZoom = true;
      var zoomedAxisCollection = [];
      var zoomFactor, zoomPosition, currentScale;
      var axisNames = [],
        zoomFactors = [],
        zoomPositions = [];
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        zoomFactor = axis.zoomFactor;
        zoomPosition = axis.zoomPosition;
        currentScale = Math.max(1 / this.minMax(zoomFactor, 0, 1), 1);
        if (axis.orientation == 'Horizontal') {
          zoomPosition = this.minMax(axis.zoomPosition + (xDiff != 0 ? xDiff : chart.zoomBase.previousMouseMoveX - chart.mouseX) / axis.rect.w / currentScale, 0, 1 - axis.zoomFactor);
        } else {
          zoomPosition = this.minMax(axis.zoomPosition - (yDiff != 0 ? yDiff : chart.zoomBase.previousMouseMoveY - chart.mouseY) / axis.rect.h / currentScale, 0, 1 - axis.zoomFactor);
        }
        if (axis.isZoomingScrollBar) {
          axis.isScrollUI = false; //need to be passed to server for line 518 in zoom.cs
        }
        zoomedAxisCollection.push({
          axisName: axis.name,
          zoomFactor: zoomFactor,
          zoomPosition: zoomPosition,
          axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
        });
      }
      var zoomingEventArgs = {
        name: 'OnZooming',
        axisCollection: zoomedAxisCollection
      };
      chart.zoomBase.zoomingEventArgs = zoomingEventArgs;
      if (!zoomingEventArgs.cancel) {
        var _loop_2 = function _loop_2(axisData) {
          axes.filter(function (axis) {
            if (axis.name == axisData.axisName) {
              axisNames.push(axis.name);
              zoomFactors.push(axisData.zoomFactor);
              zoomPositions.push(axisData.zoomPosition);
              axis.zoomFactor = axisData.zoomFactor;
              axis.zoomPosition = axisData.zoomPosition;
            }
          });
        };
        for (var _b = 0, _c = zoomedAxisCollection; _b < _c.length; _b++) {
          var axisData = _c[_b];
          _loop_2(axisData);
        }
        this.performDeferredZoom(chart, axisNames, zoomFactors, zoomPositions, isKeyboardFocus);
      }
    },
    doZoom: function doZoom(chart, axes, bounds) {
      var zoomRect = chart.zoomBase.zoomingModule.zoomingRect;
      chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.zoomSettings.enablePan || chart.zoomBase.zoomingModule.isPanning;
      var zoomedAxisCollection = [];
      var zoomFactor, zoomPosition;
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        zoomFactor = axis.zoomFactor;
        zoomPosition = axis.zoomPosition;
        if (axis.orientation == 'Horizontal' && chart.zoomBase.zoomingModule.zooming.mode != 'Y') {
          zoomPosition += Math.abs((zoomRect.x - bounds.x) / bounds.width) * axis.zoomFactor;
          zoomFactor *= zoomRect.width / bounds.width;
        } else if (axis.orientation == 'Vertical' && chart.zoomBase.zoomingModule.zooming.mode != 'X') {
          zoomPosition += (1 - Math.abs((zoomRect.height + (zoomRect.y - bounds.y)) / bounds.height)) * axis.zoomFactor;
          zoomFactor *= zoomRect.height / bounds.height;
        }
        zoomedAxisCollection.push({
          axisName: axis.name,
          zoomFactor: zoomFactor < 0.001 ? axis.zoomFactor : zoomFactor,
          zoomPosition: zoomFactor < 0.001 ? axis.zoomPosition : zoomPosition,
          axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
        });
      }
      var onZoomingEventArgs = {
        name: 'OnZooming',
        axisCollection: zoomedAxisCollection
      };
      chart.zoomBase.zoomingEventArgs = onZoomingEventArgs;
      if (!onZoomingEventArgs.cancel) {
        var _loop_3 = function _loop_3(axisData) {
          axes.filter(function (axis) {
            if (axis.name == axisData.axisName) {
              axis.zoomFactor = axisData.zoomFactor;
              axis.zoomPosition = axisData.zoomPosition;
            }
          });
        };
        for (var _b = 0, _c = zoomedAxisCollection; _b < _c.length; _b++) {
          var axisData = _c[_b];
          _loop_3(axisData);
        }
        chart.zoomBase.zoomingModule.zoomingRect = new sf.svgbase.Rect(0, 0, 0, 0);
        this.performZoomRedraw(chart);
      }
    },
    performZoomRedraw: function performZoomRedraw(chart, isKeyboardFocus) {
      if (isKeyboardFocus === void 0) {
        isKeyboardFocus = false;
      }
      if (chart.zoomBase.zoomingModule.isZoomed) {
        if (chart.zoomBase.zoomingModule.zoomingRect.width > 0 && chart.zoomBase.zoomingModule.zoomingRect.height > 0) {
          chart.zoomBase.zoomingModule.performedUI = true;
          this.doZoom(chart, chart.userInteractionBase.axes, chart.userInteractionBase.axisClipRect);
          chart.zoomBase.isDoubleTap = false;
          this.setAttribute(chart.element.id + '_svg', 'cursor', 'auto');
        } else if (chart.userInteractionBase.disableTrackTooltip) {
          chart.userInteractionBase.disableTrackTooltip = chart.zoomBase.delayRedraw = false;
          var zoomingStates = {
            isZoomed: chart.zoomBase.zoomingModule.isZoomed,
            isPanning: chart.zoomBase.zoomingModule.isPanning,
            isDoubleTap: chart.zoomBase.isDoubleTap,
            isWheelZoom: chart.zoomBase.zoomingModule.isWheelZoom,
            performedUI: chart.zoomBase.zoomingModule.performedUI,
            delayRedraw: chart.zoomBase.delayRedraw,
            isChartDrag: chart.zoomBase.isChartDrag,
            isChartPanning: chart.isChartPanning
          };
          //need to invoke processlayoutchange.
          chart.dotnetref.invokeMethodAsync('ZoomingComplete', chart.zoomBase.zoomingEventArgs, zoomingStates);
          //this.renderScrollbar(chart.dataId, chart.userInteractionBase.axes);
          if (isKeyboardFocus) {
            this.focusTarget(chart.element.id);
          }
        }
        chart.isChartPanning = chart.isChartZoom = false;
      }
    },
    clearSelectionRect: function clearSelectionRect(id) {
      var selectionRect = document.getElementById(id);
      if (selectionRect) {
        selectionRect.setAttribute('x', '0');
        selectionRect.setAttribute('y', '0');
        selectionRect.setAttribute('width', '0');
        selectionRect.setAttribute('height', '0');
      }
    },
    isMouseWheelScroll: function isMouseWheelScroll(targetId) {
      if (targetId.indexOf("scrollBarThumb_") != -1 || targetId.indexOf("scrollBarBackRect_") != -1 || targetId.indexOf("scrollBar_leftCircle_") != -1 || targetId.indexOf("scrollBar_rightCircle_") != -1 || targetId.indexOf("scrollBar_gripCircle_") != -1 || targetId.indexOf("scrollBar_leftArrow_") != -1 || targetId.indexOf("scrollBar_rightArrow_") != -1 || targetId.indexOf("scrollBar_gripCircle") != -1) {
        return true;
      } else {
        return false;
      }
    },
    getAxisName: function getAxisName(targetId) {
      var axisName = "";
      var splitId = [];
      if (!Chart.isExist(targetId, "_scrollBar_svg")) {
        splitId = targetId.split("_");
        axisName = splitId[splitId.length - 1];
      } else {
        splitId = targetId.split("_scrollBar_svg");
        axisName = splitId[splitId.length - 1];
      }
      return axisName;
    },
    calculateDelta: function calculateDelta(scrollbarAxis, scrollbar, chart, e) {
      for (var i = 0; i < scrollbar.axes.length; i++) {
        if (scrollbarAxis.name == scrollbar.axes[i].name) scrollbar.axis = scrollbar.axes[i];
      }
      var scrollbarOptions = scrollbar.scrollbarOptions[scrollbarAxis.name];
      scrollbarOptions.isVertical = scrollbarAxis.orientation === 'Vertical';
      var isInverse = scrollbarAxis.isAxisInverse;
      if (sf.base.isNullOrUndefined(scrollbarOptions) || scrollbarOptions && !document.getElementById(scrollbarOptions.svgObject.id)) {
        return null;
      }
      var eventArgs = Chart.getScrollEventArgs(e, [chart.id, chart.id + '_scrollBar_svg' + scrollbarAxis.name]);
      this.mouseX = eventArgs['mouseX'];
      this.mouseY = eventArgs['mouseY'];
      scrollbar.previousXY = scrollbarOptions.isVertical && isInverse ? this.mouseY : scrollbarOptions.isVertical ? scrollbarOptions.width - this.mouseY : isInverse ? scrollbarOptions.width - this.mouseX : this.mouseX;
      var defaultDelta = 5;
      this.delta = Math.max(-1, Math.min(1, e['wheelDelta'] || -e.detail));
      if (this.delta > 0) scrollbar.previousXY = scrollbar.previousXY + defaultDelta;else scrollbar.previousXY = scrollbar.previousXY - defaultDelta;
      return scrollbarOptions;
    },
    lazyLoadScrollChanged: function lazyLoadScrollChanged(scrollbarAxis, scrollbar, scrollbarOptions, chart) {
      var isInverse = scrollbarAxis.isAxisInverse;
      var mouseXY = scrollbarOptions.isVertical && isInverse ? scrollbarOptions.width - this.mouseY : scrollbarOptions.isVertical ? this.mouseY : this.mouseX;
      var zoomPosition = scrollbarOptions.zoomPosition;
      var zoomFactor = scrollbarOptions.zoomFactor;
      var circleRadius = 8;
      var args;
      if (scrollbarOptions.isLazyLoad && scrollbar.isScrollWheel) {
        if (scrollbarOptions.thumbRectX != circleRadius && scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth + circleRadius < scrollbarOptions.width && this.delta != 0) {
          args = Chart.calculateLazyRange(scrollbar, null, this.delta);
        }
      }
      var currentRange = args ? args.currentRange : null;
      if (scrollbar.isScrollWheel) {
        mouseXY = scrollbarOptions.isVertical || isInverse ? scrollbarOptions.width - mouseXY : mouseXY;
        var currentX = scrollbarOptions.thumbRectX + (mouseXY - scrollbar.previousXY);
        scrollbarOptions.svgObject.style.cursor = 'default';
        if (mouseXY >= 0 || mouseXY <= currentX + scrollbarOptions.thumbRectWidth) {
          scrollbarOptions.thumbRectX = Chart.isWithIn(currentX, scrollbar) ? currentX : scrollbarOptions.thumbRectX;
          Chart.positionThumb(scrollbarOptions.thumbRectX, scrollbarOptions.thumbRectWidth, scrollbar);
          scrollbar.previousXY = mouseXY;
          Chart.setZoomFactorPosition(scrollbar, currentX, scrollbarOptions.thumbRectWidth, false);
        }
        if (args) {
          chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollChanged', scrollbarAxis.name, zoomPosition, zoomFactor, currentRange));
        }
      }
    },
    lazyLoadScrollEnd: function lazyLoadScrollEnd(scrollbarAxis, scrollbar, scrollbarOptions, chart) {
      var args;
      scrollbarOptions.startX = scrollbarOptions.thumbRectX;
      var circleRadius = 8;
      var circleWidth = 1;
      var currentScrollWidth = scrollbarOptions.startX + scrollbarOptions.thumbRectWidth + circleRadius + circleWidth;
      var currentZPWidth = circleRadius + circleWidth / 2;
      if (!scrollbarOptions.isLazyLoad) {
        scrollbarAxis.zoomFactor = currentScrollWidth >= scrollbarOptions.width - 1 && scrollbarOptions.startX - currentZPWidth <= 0 ? 1 : scrollbarOptions.zoomFactor;
      }
      if (scrollbarOptions.isLazyLoad) {
        if (scrollbarOptions.thumbRectX != circleRadius && scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth + circleRadius < scrollbarOptions.width && this.delta != 0) {
          args = Chart.calculateLazyRange(scrollbar, null, this.delta);
        }
        if (args) {
          chart.dotnetref.invokeMethodAsync('TriggerScrollEvents', Chart.getArgs('OnScrollEnd', scrollbarAxis.name, scrollbarAxis.zoomPosition, scrollbarAxis.zoomFactor, args.currentRange));
        }
        scrollbar.isScrollWheel = false;
      }
    },
    performMouseWheelScrolling: function performMouseWheelScrolling(e, mouseX, mouseY, chart, axes) {
      chart.isWheelScrolling = true;
      var scrollbar = chart.scrollbarBase;
      var targetId = e.target.id;
      var axisName = this.getAxisName(targetId);
      var scrollbarAxis = axes.filter(function (axis) {
        return axis.name === axisName;
      })[0];
      var scrollbarOptions = this.calculateDelta(scrollbarAxis, scrollbar, chart, e);
      this.lazyLoadScrollChanged(scrollbarAxis, scrollbar, scrollbarOptions, chart);
      this.lazyLoadScrollEnd(scrollbarAxis, scrollbar, scrollbarOptions, chart);
    },
    performMouseWheelZooming: function performMouseWheelZooming(e, mouseX, mouseY, chart, axes) {
      var direction = chart.zoomBase.zoomingModule.browser.browserName === 'mozilla' && !chart.zoomBase.zoomingModule.browser.isPointer ? -e.detail / 3 > 0 ? 1 : -1 : e['wheelDelta'] > 0 ? 1 : -1;
      chart.zoomBase.zoomingModule.isZoomed = true;
      this.calculateZoomAxesRange(chart);
      chart.userInteractionBase.disableTrackTooltip = true;
      chart.zoomBase.zoomingModule.performedUI = true;
      chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.zoomSettings.enablePan || chart.zoomBase.zoomingModule.isPanning;
      var zoomedAxisCollection = [];
      var origin, cumulative;
      chart.zoomBase.zoomingModule.isWheelZoom = true;
      var zoomFactor, zoomPosition;
      for (var _i = 0, _a = axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        zoomFactor = axis.zoomFactor;
        zoomPosition = axis.zoomPosition;
        if (axis.orientation == 'Vertical' && chart.zoomBase.zoomingModule.zooming.mode != 'X' || axis.orientation == 'Horizontal' && chart.zoomBase.zoomingModule.zooming.mode != 'Y') {
          cumulative = Math.max(Math.max(1 / this.minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * direction, 1);
          if (cumulative >= 1) {
            origin = axis.orientation == 'Horizontal' ? mouseX / axis.rect.w : 1 - mouseY / axis.rect.h;
            origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
            zoomFactor = cumulative == 1 ? 1 : this.minMax(1 / cumulative, 0, 1);
            zoomPosition = cumulative == 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - zoomFactor) * origin;
            if (axis.zoomPosition != zoomPosition || axis.zoomFactor != zoomFactor) {
              zoomFactor = zoomPosition + zoomFactor > 1 ? 1 - zoomPosition : zoomFactor;
            }
          }
        }
        zoomedAxisCollection.push({
          axisName: axis.name,
          zoomFactor: zoomFactor < 0.001 ? axis.zoomFactor : zoomFactor,
          zoomPosition: zoomFactor < 0.001 ? axis.zoomPosition : zoomPosition,
          axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
        });
      }
      var onZoomingEventArgs = {
        name: 'OnZooming',
        axisCollection: zoomedAxisCollection
      };
      chart.zoomBase.zoomingEventArgs = onZoomingEventArgs;
      if (!onZoomingEventArgs.cancel) {
        var _loop_4 = function _loop_4(axisData) {
          axes.filter(function (axis) {
            if (axis.name == axisData.axisName) {
              axis.zoomFactor = axisData.zoomFactor;
              axis.zoomPosition = axisData.zoomPosition;
            }
          });
        };
        for (var _b = 0, _c = zoomedAxisCollection; _b < _c.length; _b++) {
          var axisData = _c[_b];
          _loop_4(axisData);
        }
        this.performZoomRedraw(chart);
      }
      chart.zoomBase.zoomingModule.isWheelZoom = false;
    },
    performPinchZooming: function performPinchZooming(chart) {
      if (chart.zoomBase.zoomingModule.zoomingRect.width > 0 && chart.zoomBase.zoomingModule.zoomingRect.height > 0 || chart.userInteractionBase.startMove && chart.crosshairBase.crosshair.enable) {
        return false;
      }
      this.calculateZoomAxesRange(chart);
      chart.zoomBase.zoomingModule.isZoomed = chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.zoomingModule.performedUI = true;
      chart.zoomBase.zoomingModule.offset = !chart.zoomBase.delayRedraw ? chart.userInteractionBase.axisClipRect : chart.zoomBase.zoomingModule.offset;
      chart.zoomBase.delayRedraw = chart.userInteractionBase.disableTrackTooltip = true;
      var elementOffset = chart.element.getBoundingClientRect();
      var touchDown = chart.zoomBase.zoomingModule.touchStartList;
      var touchMove = chart.zoomBase.zoomingModule.touchMoveList;
      var touch0StartX = touchDown[0].pageX - elementOffset.left;
      var touch0StartY = touchDown[0].pageY - elementOffset.top;
      var touch0EndX = touchMove[0].pageX - elementOffset.left;
      var touch0EndY = touchMove[0].pageY - elementOffset.top;
      var touch1StartX = touchDown[1].pageX - elementOffset.left;
      var touch1StartY = touchDown[1].pageY - elementOffset.top;
      var touch1EndX = touchMove[1].pageX - elementOffset.left;
      var touch1EndY = touchMove[1].pageY - elementOffset.top;
      var scaleX = Math.abs(touch0EndX - touch1EndX) / Math.abs(touch0StartX - touch1StartX);
      var scaleY = Math.abs(touch0EndY - touch1EndY) / Math.abs(touch0StartY - touch1StartY);
      var clipX = (chart.zoomBase.zoomingModule.offset.x - touch0EndX) / scaleX + touch0StartX;
      var clipY = (chart.zoomBase.zoomingModule.offset.y - touch0EndY) / scaleY + touch0StartY;
      var translateXValue = touch0EndX - scaleX * touch0StartX;
      var translateYValue = touch0EndY - scaleY * touch0StartY;
      var pinchRect = new sf.svgbase.Rect(clipX, clipY, chart.zoomBase.zoomingModule.offset.width / scaleX, chart.zoomBase.zoomingModule.offset.height / scaleY);
      if (!isNaN(scaleX - scaleX) && !isNaN(scaleY - scaleY)) {
        switch (chart.zoomBase.zoomSettings.mode) {
          case 'XY':
            this.setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, true);
            break;
          case 'X':
            this.setTransform(translateXValue, 0, scaleX, 1, chart, true);
            break;
          case 'Y':
            this.setTransform(0, translateYValue, 1, scaleY, chart, true);
            break;
        }
      }
      this.calculatePinchZoomFactor(chart, pinchRect);
      return true;
    },
    setTransform: function setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, isPinch) {
      var seriesCollection = document.getElementById(chart.element.id + 'SeriesCollection');
      var indicatorCollection = document.getElementById(chart.element.id + 'IndicatorCollection');
      if (seriesCollection) {
        seriesCollection.setAttribute('clip-path', 'url(#' + chart.element.id + '_ChartAreaClipRect_)');
      }
      if (indicatorCollection) {
        indicatorCollection.setAttribute('clip-path', 'url(#' + chart.element.id + '_ChartAreaClipRect_)');
      }
      var translate;
      if (translateXValue !== null && translateYValue !== null) {
        for (var i = 0; i < chart.userInteractionBase.visibleSeries.length; i++) {
          var seriesVal = chart.userInteractionBase.visibleSeries[i];
          var xAxisLoc = chart.userInteractionBase.isInverted ? seriesVal.y_Axis.rect.x : seriesVal.x_Axis.rect.x;
          var yAxisLoc = chart.userInteractionBase.isInverted ? seriesVal.x_Axis.rect.y : seriesVal.y_Axis.rect.y;
          translate = 'translate(' + (translateXValue + (isPinch ? scaleX * xAxisLoc : xAxisLoc)) + ',' + (translateYValue + (isPinch ? scaleY * yAxisLoc : yAxisLoc)) + ')';
          translate = scaleX || scaleY ? translate + ' scale(' + scaleX + ' ' + scaleY + ')' : translate;
          if (seriesVal.visible) {
            var seriesElement = this.getElement(chart.element.id + 'SeriesGroup' + seriesVal.index);
            var indicatorElement = this.getElement(chart.element.id + 'IndicatorGroup' + seriesVal.index);
            var errorBarElement = this.getElement(chart.element.id + 'ErrorBarGroup' + seriesVal.index);
            var symbolElement = this.getElement(chart.element.id + 'SymbolGroup' + seriesVal.index);
            var textElement_1 = this.getElement(chart.element.id + 'TextGroup' + seriesVal.index);
            var shapeElement = this.getElement(chart.element.id + 'ShapeGroup' + seriesVal.index);
            if (seriesVal.category === 'Indicator' && indicatorElement) {
              indicatorElement.setAttribute('transform', translate);
            } else if (seriesElement) {
              seriesElement.setAttribute('transform', translate);
            }
            var element = this.getElement(chart.element.id + '_Series_' + seriesVal.index + '_DataLabelCollections');
            if (errorBarElement) {
              errorBarElement.setAttribute('transform', translate);
            }
            if (symbolElement) {
              symbolElement.setAttribute('transform', translate);
            }
            if (textElement_1) {
              textElement_1.setAttribute('visibility', 'hidden');
              shapeElement.setAttribute('visibility', 'hidden');
            }
            if (element) {
              element.style.visibility = 'hidden';
            }
          }
        }
      }
    },
    performDeferredZoom: function performDeferredZoom(chart, axisNames, zoomFactors, zoomPositions, isKeyboardFocus) {
      if (isKeyboardFocus === void 0) {
        isKeyboardFocus = false;
      }
      var translateX, translateY;
      if (chart.zoomBase.zoomSettings.enableDeferredZooming) {
        translateX = chart.mouseX - chart.zoomBase.mouseDownX;
        translateY = chart.mouseY - chart.zoomBase.mouseDownY;
        switch (chart.zoomBase.zoomSettings.mode) {
          case 'X':
            translateY = 0;
            break;
          case 'Y':
            translateX = 0;
            break;
        }
        this.setTransform(translateX, translateY, 0, 0, chart, false);
      } else {
        chart.dotnetref.invokeMethodAsync('ChartPan', axisNames, zoomFactors, zoomPositions);
      }
      chart.zoomBase.previousMouseMoveX = chart.mouseX;
      chart.zoomBase.previousMouseMoveY = chart.mouseY;
    },
    calculatePinchZoomFactor: function calculatePinchZoomFactor(chart, pinchRect) {
      var zoomMode = chart.zoomBase.zoomingModule.zooming.mode;
      var rangeMin, rangeMax, pinchValue, axisTrans;
      var zoomedAxisCollection = [];
      var zoomFactor, zoomPosition;
      for (var i = 0; i < chart.userInteractionBase.axes.length; i++) {
        var axis = chart.userInteractionBase.axes[i];
        zoomFactor = axis.zoomFactor;
        zoomPosition = axis.zoomPosition;
        if (axis.orientation === 'Horizontal' && zoomMode !== 'Y' || axis.orientation === 'Vertical' && zoomMode !== 'X') {
          if (axis.orientation === 'Horizontal') {
            pinchValue = pinchRect.x - chart.zoomBase.zoomingModule.offset.x;
            axisTrans = axis.rect.w / chart.zoomBase.zoomingModule.zoomAxes[i].delta;
            rangeMin = pinchValue / axisTrans + chart.zoomBase.zoomingModule.zoomAxes[i].min;
            pinchValue = pinchRect.x + pinchRect.width - chart.zoomBase.zoomingModule.offset.x;
            rangeMax = pinchValue / axisTrans + chart.zoomBase.zoomingModule.zoomAxes[i].min;
          } else {
            pinchValue = pinchRect.y - chart.zoomBase.zoomingModule.offset.y;
            axisTrans = axis.rect.h / chart.zoomBase.zoomingModule.zoomAxes[i].delta;
            rangeMin = (pinchValue * -1 + axis.rect.h) / axisTrans + chart.zoomBase.zoomingModule.zoomAxes[i].min;
            pinchValue = pinchRect.y + pinchRect.height - chart.zoomBase.zoomingModule.offset.y;
            rangeMax = (pinchValue * -1 + axis.rect.h) / axisTrans + chart.zoomBase.zoomingModule.zoomAxes[i].min;
          }
          var selectionMin = Math.min(rangeMin, rangeMax),
            selectionMax = Math.max(rangeMin, rangeMax),
            currentZP = (selectionMin - chart.zoomBase.zoomingModule.zoomAxes[i].actualMin) / chart.zoomBase.zoomingModule.zoomAxes[i].delta,
            currentZF = (selectionMax - selectionMin) / chart.zoomBase.zoomingModule.zoomAxes[i].delta;
          zoomPosition = currentZP < 0 ? 0 : currentZP;
          zoomFactor = currentZF > 1 ? 1 : currentZF < 0.03 ? 0.03 : currentZF;
        }
        zoomedAxisCollection.push({
          axisName: axis.name,
          zoomFactor: zoomFactor,
          zoomPosition: zoomPosition,
          axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
        });
      }
      var onZoomingEventArgs = {
        name: 'OnZooming',
        axisCollection: zoomedAxisCollection
      };
      chart.zoomBase.zoomingEventArgs = onZoomingEventArgs;
      if (!onZoomingEventArgs.cancel) {
        var _loop_5 = function _loop_5(axisData) {
          chart.userInteractionBase.axes.filter(function (axis) {
            if (axis.name == axisData.axisName) {
              axis.zoomFactor = axisData.zoomFactor;
              axis.zoomPosition = axisData.zoomPosition;
            }
          });
        };
        for (var _i = 0, _a = zoomedAxisCollection; _i < _a.length; _i++) {
          var axisData = _a[_i];
          _loop_5(axisData);
        }
      }
    },
    mouseCancelHandler: function mouseCancelHandler(chart) {
      if (chart.zoomBase.zoomingModule && chart.zoomBase.zoomingModule.isZoomed) {
        this.clearSelectionRect(chart.element.id + '_ZoomArea');
        this.performZoomRedraw(chart);
        chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.isChartDrag = false;
      }
      chart.zoomBase.zoomingModule.pinchTarget = null;
      chart.zoomBase.zoomingModule.touchStartList = [];
      chart.zoomBase.zoomingModule.touchMoveList = [];
    },
    createClipRect: function createClipRect(chart) {
      var options = {
        'id': chart.element.id + '_ChartAreaClipRect_',
        'x': chart.userInteractionBase.axisClipRect.x,
        'y': chart.userInteractionBase.axisClipRect.y,
        'width': chart.userInteractionBase.axisClipRect.width,
        'height': chart.userInteractionBase.axisClipRect.height,
        'fill': 'transparent',
        'stroke-width': 1,
        'stroke': 'Gray'
      };
      var clipPath = chart.userInteractionBase.svgRenderer.drawClipPath(options);
      var seriesElement = this.getElement(chart.element.id + 'SeriesCollection');
      if (seriesElement) {
        seriesElement.appendChild(clipPath);
      }
    },
    updateClipRect: function updateClipRect(clipRect, chart) {
      if (chart.userInteractionBase.visibleSeries.length > 0) {
        for (var i = 0; i < chart.userInteractionBase.visibleSeries.length; i++) {
          var seriesVal = chart.userInteractionBase.visibleSeries[i];
          if (seriesVal.visible && seriesVal.category === 'Indicator') {
            var indicatorElement = this.getElement(chart.element.id + 'IndicatorGroup' + seriesVal.index);
            var translate = 'translate(' + seriesVal.clipRect.x.toString() + ',' + seriesVal.clipRect.y.toString() + ')';
            if (indicatorElement) {
              indicatorElement.setAttribute('transform', translate);
            }
          }
        }
      }
      if (clipRect) {
        var axisClipRect = chart.userInteractionBase.axisClipRect;
        clipRect.setAttribute('x', axisClipRect.x.toString());
        clipRect.setAttribute('y', axisClipRect.y.toString());
        clipRect.setAttribute('width', axisClipRect.width.toString());
        clipRect.setAttribute('height', axisClipRect.height.toString());
      }
    },
    isAxisZoomed: function isAxisZoomed(axes) {
      var isAxisZoomed = false;
      for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {
        var axis = axes_1[_i];
        if (axis.zoomFactor !== 1 || axis.zoomPosition !== 0) {
          isAxisZoomed = true;
        }
      }
      return isAxisZoomed;
    },
    applyZoomingToolkit: function applyZoomingToolkit(chart) {
      if (this.getElement(chart.element.id + chart.zoomBase.zoomToolkitId)) {
        if (this.isAxisZoomed(chart.userInteractionBase.axes)) {
          chart.zoomBase.zoomingModule.isZoomed = true;
          if (chart.zoomBase.zoomingModule.isPanning) {
            this.zoomToolkitPan(chart);
          }
        } else {
          chart.zoomBase.zoomingModule.isZoomed = chart.zoomBase.zoomingModule.isPanning = false;
          this.setAttribute(chart.element.id + '_svg', 'cursor', 'auto');
        }
      }
    },
    zoomToolkitZoom: function zoomToolkitZoom(chart) {
      chart.zoomBase.zoomingModule.isPanning = false;
      var elementOpacity = "1";
      this.setAttribute(chart.element.id + '_svg', 'cursor', 'auto');
      this.setAttribute(chart.element.id + chart.zoomBase.zoomToolkitZoomIn, 'opacity', elementOpacity);
      this.setAttribute(chart.element.id + chart.zoomBase.zoomToolkitZoomOut, 'opacity', chart.zoomBase.zoomSettings.toolbarDisplayMode === 'Always' && !chart.zoomBase.zoomingModule.isZoomed ? '0.2' : elementOpacity);
      this.applySelection(chart.element.id + chart.zoomBase.zoomToolkitZoom, chart.zoomToolkitBase.selectionColor);
      this.applySelection(chart.element.id + chart.zoomBase.zoomToolkitPan, '#737373');
      if (chart.zoomToolkitBase.selectedId) {
        this.setAttribute(chart.zoomToolkitBase.selectedId, 'fill', 'transparent');
      }
      chart.zoomToolkitBase.selectedId = chart.element.id + chart.zoomBase.zoomToolkitZoom + '_1';
      this.setAttribute(chart.zoomToolkitBase.selectedId, 'fill', chart.zoomToolkitBase.iconRectSelectionFill);
    },
    zoomToolkitPan: function zoomToolkitPan(chart) {
      if (chart.zoomBase.zoomingModule.isZoomed) {
        chart.zoomBase.zoomingModule.isPanning = !(chart.zoomBase.zoomSettings.toolbarDisplayMode == 'Always') || chart.zoomBase.zoomingModule.isZoomed;
        this.setAttribute(chart.element.id + '_svg', 'cursor', 'pointer');
        var elementOpacity = "0.2";
        this.setAttribute(chart.element.id + chart.zoomBase.zoomToolkitZoomIn, 'opacity', chart.zoomBase.zoomSettings.toolbarDisplayMode == 'Always' && !chart.zoomBase.zoomingModule.isZoomed ? "1" : elementOpacity);
        this.setAttribute(chart.element.id + chart.zoomBase.zoomToolkitZoomOut, 'opacity', elementOpacity);
        this.applySelection(chart.element.id + chart.zoomBase.zoomToolkitZoom, '#737373');
        this.applySelection(chart.element.id + chart.zoomBase.zoomToolkitPan, chart.zoomToolkitBase.selectionColor);
        if (chart.zoomToolkitBase.selectedId) {
          this.setAttribute(chart.zoomToolkitBase.selectedId, 'fill', 'transparent');
        }
        chart.zoomToolkitBase.selectedId = chart.element.id + chart.zoomBase.zoomToolkitPan + '_1';
        this.setAttribute(chart.zoomToolkitBase.selectedId, 'fill', chart.zoomToolkitBase.iconRectSelectionFill);
      }
    },
    zoomToolkitZoomIn: function zoomToolkitZoomIn(chart, elementOpacity) {
      chart.zoomBase.zoomingModule.isZoomed = true;
      this.zoomInOutCalculation(1, chart, elementOpacity);
    },
    zoomToolkitZoomOut: function zoomToolkitZoomOut(chart, elementOpacity) {
      this.zoomInOutCalculation(-1, chart, elementOpacity);
    },
    zoomToolkitReset: function zoomToolkitReset(chart) {
      if (!chart.zoomBase.zoomingModule.isDevice && !(chart.zoomBase.zoomSettings.toolbarDisplayMode === 'Always')) {
        var zoomKitElement = this.getElement(chart.element.id + chart.zoomBase.zoomToolkitId);
        if (zoomKitElement) {
          zoomKitElement.style.visibility = 'hidden';
        }
      }
      this.zoomToolkitRemoveTooltip(chart);
      var zoomedAxisCollection = [];
      for (var _i = 0, _a = chart.userInteractionBase.axes; _i < _a.length; _i++) {
        var axis = _a[_i];
        axis.zoomFactor = 1;
        axis.zoomPosition = 0;
        zoomedAxisCollection.push({
          axisName: axis.name,
          zoomFactor: axis.zoomFactor,
          zoomPosition: axis.zoomPosition,
          axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
        });
      }
      var onZoomingEventArgs = {
        name: 'OnZoomEnd',
        axisCollection: zoomedAxisCollection
      };
      if (!onZoomingEventArgs.cancel) {
        chart.zoomToolkitBase.isReset = true;
        this.zoomToolkitSetDeferredZoom(chart, onZoomingEventArgs);
      }
    },
    zoomInOutCalculation: function zoomInOutCalculation(scale, chart, elementOpacity) {
      if (!chart.zoomBase.zoomingModule.isPanning && (elementOpacity != '0.2' || chart.zoomBase.zoomSettings.toolbarDisplayMode === 'Always')) {
        if (chart.zoomBase.zoomSettings.isOnZoomStartCalled) {
          chart.dotnetref.invokeMethodAsync('TriggerZoomingEvents', 'OnZoomStart', false);
          chart.zoomBase.zoomingModule.isZoomStart = false;
        }
        var mode = chart.zoomBase.zoomingModule.zooming.mode;
        var cumulative = void 0,
          zoomFactor = void 0,
          zoomPosition = void 0;
        chart.userInteractionBase.disableTrackTooltip = chart.zoomBase.delayRedraw = true;
        var zoomedAxisCollection = [];
        for (var _i = 0, _a = chart.userInteractionBase.axes; _i < _a.length; _i++) {
          var axis = _a[_i];
          if (axis.orientation == 'Horizontal' && mode != 'Y' || axis.orientation == 'Vertical' && mode != 'X') {
            cumulative = Math.max(Math.max(1 / this.minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * scale, 1);
            zoomFactor = cumulative == 1 ? 1 : this.minMax(1 / cumulative, 0, 1);
            zoomPosition = cumulative == 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - zoomFactor) * 0.5;
            if (axis.zoomPosition != zoomPosition || axis.zoomFactor != zoomFactor) {
              zoomFactor = zoomPosition + zoomFactor > 1 ? 1 - zoomPosition : zoomFactor;
            }
            zoomedAxisCollection.push({
              axisName: axis.name,
              zoomFactor: zoomFactor,
              zoomPosition: zoomPosition,
              axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
            });
          } else {
            zoomedAxisCollection.push({
              axisName: axis.name,
              zoomFactor: axis.zoomFactor,
              zoomPosition: axis.zoomPosition,
              axisRange: this.getVisibleRangeModel(axis.visibleRange, axis.visibleInterval)
            });
          }
        }
        var onZoomingEventArgs = {
          name: 'OnZooming',
          axisCollection: zoomedAxisCollection
        };
        chart.zoomBase.zoomingEventArgs = onZoomingEventArgs;
        if (!onZoomingEventArgs.cancel) {
          var _loop_6 = function _loop_6(axisData) {
            chart.userInteractionBase.axes.filter(function (axis) {
              if (axis.name == axisData.axisName) {
                axis.zoomFactor = axisData.zoomFactor;
                axis.zoomPosition = axisData.zoomPosition;
              }
            });
          };
          for (var _b = 0, _c = zoomedAxisCollection; _b < _c.length; _b++) {
            var axisData = _c[_b];
            _loop_6(axisData);
          }
        }
      }
    },
    zoomToolkitRemoveTooltip: function zoomToolkitRemoveTooltip(chart) {
      var hoverId = chart.zoomToolkitBase.hoverId;
      if (hoverId) {
        this.setAttribute(hoverId, 'fill', chart.zoomBase.zoomingModule.isPanning ? hoverId.indexOf('_Pan_') > -1 ? chart.zoomToolkitBase.iconRectSelectionFill : 'transparent' : hoverId.indexOf('_Zoom_') > -1 ? chart.zoomToolkitBase.iconRectSelectionFill : 'transparent');
        this.setAttribute(hoverId.replace('_1', '_2'), 'fill', chart.zoomBase.zoomingModule.isPanning ? hoverId.indexOf('_Pan_') > -1 ? chart.zoomToolkitBase.selectionColor : chart.zoomToolkitBase.fillColor : hoverId.indexOf('_Zoom_') > -1 ? chart.zoomToolkitBase.selectionColor : chart.zoomToolkitBase.fillColor);
        this.setAttribute(hoverId.replace('_1', '_3'), 'fill', chart.zoomBase.zoomingModule.isPanning ? chart.zoomToolkitBase.fillColor : hoverId.indexOf('_Zoom_') > -1 ? chart.zoomToolkitBase.selectionColor : chart.zoomToolkitBase.fillColor);
        chart.dotnetref.invokeMethodAsync('SetSelectedIcon', hoverId, false);
      }
      this.removeElement(chart.zoomBase.chartZoomTip);
    },
    zoomToolkitShowTooltip: function zoomToolkitShowTooltip(chart, currentTarget, text, args) {
      this.zoomToolkitRemoveTooltip(chart);
      var textStyle = {
        size: '10px',
        fontWeight: 'Normal',
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
      };
      var left = args.clientX - (sf.svgbase.measureText(text, textStyle).width + 5);
      var rect = currentTarget + '_1';
      chart.zoomToolkitBase.hoverId = rect;
      this.setAttribute(rect, 'fill', chart.zoomToolkitBase.iconRectOverFill);
      this.setAttribute(currentTarget + '_2', 'fill', chart.zoomToolkitBase.selectionColor);
      this.setAttribute(currentTarget + '_3', 'fill', chart.zoomToolkitBase.selectionColor);
      if (currentTarget && document.getElementById(currentTarget).getAttribute('opacity') === '1') {
        document.getElementById(currentTarget).setAttribute('cursor', 'pointer');
      } else {
        document.getElementById(currentTarget).setAttribute('cursor', 'auto');
      }
      if (!chart.isTouch) {
        this.createTooltip(chart.zoomBase.chartZoomTip, text, args.clientY + 10, left, '10px');
      }
      chart.dotnetref.invokeMethodAsync('SetSelectedIcon', currentTarget, true);
    },
    zoomToolkitSetDeferredZoom: function zoomToolkitSetDeferredZoom(chart, onZoomingEventArgs) {
      chart.userInteractionBase.disableTrackTooltip = false;
      chart.zoomBase.zoomingModule.isZoomed = chart.zoomBase.zoomingModule.isPanning = chart.zoomBase.isChartDrag = chart.zoomBase.delayRedraw = false;
      chart.zoomBase.zoomingModule.touchMoveList = chart.zoomBase.zoomingModule.touchStartList = [];
      chart.zoomBase.zoomingModule.pinchTarget = null;
      chart.dotnetref.invokeMethodAsync('ZoomToolkitSetDeferredZoom', onZoomingEventArgs);
    },
    zoomToolkitTooltip: function zoomToolkitTooltip(chart, targetId, e) {
      var currentTarget;
      var zoomBase = chart.zoomBase;
      if (targetId.indexOf(zoomBase.zoomToolkitZoom) > -1 && !(targetId.indexOf(zoomBase.zoomToolkitZoomIn) > -1 || targetId.indexOf(zoomBase.zoomToolkitZoomOut) > -1)) {
        currentTarget = chart.element.id + zoomBase.zoomToolkitZoom;
      } else if (targetId.indexOf(zoomBase.zoomToolkitZoomIn) > -1) {
        currentTarget = chart.element.id + zoomBase.zoomToolkitZoomIn;
      } else if (targetId.indexOf(zoomBase.zoomToolkitZoomOut) > -1) {
        currentTarget = chart.element.id + zoomBase.zoomToolkitZoomOut;
      } else if (targetId.indexOf(zoomBase.zoomToolkitPan) > -1) {
        currentTarget = chart.element.id + zoomBase.zoomToolkitPan;
      } else if (targetId.indexOf(zoomBase.zoomToolkitReset) > -1) {
        currentTarget = chart.element.id + zoomBase.zoomToolkitReset;
      } else {
        return;
      }
      if (currentTarget) {
        Chart.zoomToolkitShowTooltip(chart, currentTarget, this.getElement(currentTarget).getAttribute('aria-label'), e);
      }
    },
    zoomToolkitMouseDown: function zoomToolkitMouseDown(chart, target) {
      var zoomBase = chart.zoomBase;
      if (target.id.indexOf(zoomBase.zoomToolkitZoom) > -1 && !(target.id.indexOf(zoomBase.zoomToolkitZoomIn) > -1 || target.id.indexOf(zoomBase.zoomToolkitZoomOut) > -1)) {
        this.zoomToolkitZoom(chart);
      } else if (target.id.indexOf(zoomBase.zoomToolkitZoomIn) > -1) {
        this.zoomToolkitZoomIn(chart, target.getAttribute('opacity'));
      } else if (target.id.indexOf(zoomBase.zoomToolkitZoomOut) > -1) {
        this.zoomToolkitZoomOut(chart, target.getAttribute('opacity'));
      } else if (target.id.indexOf(zoomBase.zoomToolkitPan) > -1) {
        this.zoomToolkitPan(chart);
      } else if (target.id.indexOf(zoomBase.zoomToolkitReset) > -1) {
        this.zoomToolkitReset(chart);
      } else {
        return;
      }
    },
    setScrollbarOptions: function setScrollbarOptions(dataId, scrollbarOptions) {
      var currentInstance = window.sfBlazor.getCompInstance(dataId);
      if (!sf.base.isNullOrUndefined(currentInstance)) {
        currentInstance.scrollbarBase = currentInstance.scrollbarBase ? currentInstance.scrollbarBase : {};
        currentInstance.scrollbarBase.isResize = scrollbarOptions.isResize;
        currentInstance.scrollbarBase.axes = scrollbarOptions.axes;
        currentInstance.scrollbarBase.scrollbarThemeStyle = scrollbarOptions.scrollbarThemeStyle;
        currentInstance.scrollbarBase.chartAreaType = scrollbarOptions.chartAreaType;
        currentInstance.scrollbarBase.isScrollExist = scrollbarOptions.isScrollExist;
        // Initialize scrollbar axis based values
        currentInstance.scrollbarBase.scrollbarOptions = currentInstance.scrollbarBase.scrollbarOptions ? currentInstance.scrollbarBase.scrollbarOptions : {};
      }
    },
    renderScrollbar: function renderScrollbar(dataId, axes) {
      var chart = window.sfBlazor.getCompInstance(dataId);
      chart.axes = chart.scrollbarBase.axes = axes;
      chart.calculateSecondaryOffset(chart.element.id);
      var axis;
      var zoomModule;
      var isZoomed;
      if (sf.base.isNullOrUndefined(chart.zoomBase.zoomingModule)) {
        zoomModule = false;
      } else {
        zoomModule = chart.zoomBase.zoomingModule;
        isZoomed = zoomModule.isZoomed ? zoomModule.isZoomed : this.isAxisZoomed(chart.userInteractionBase.axes);
      }
      chart.scrollbarBase.chartId = chart.id;
      for (var i = 0; i < chart.axes.length; i++) {
        axis = chart.axes[i];
        chart.scrollbarBase.axis = axis;
        if (chart.scrollbarBase.chartAreaType != "PolarAxes" && (isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) {
          if (!chart.scrollElement && chart.scrollbarBase.chartAreaType != "PolarAxes" && axis.visible) {
            chart.scrollElement = document.getElementById(chart.id + "_scrollElement");
          }
          if (zoomModule || chart.scrollbarBase.isScrollExist && axis.scrollbarSettings.enable) {
            this.getDefaults(chart, axis);
          }
          this.getTheme(chart);
          this.removeScrollSvg(chart, axis);
          this.createScrollSvg(axis, chart, chart.userInteractionBase.svgRenderer);
          chart.scrollbarBase.scrollbarOptions[axis.name].svgObject.appendChild(this.renderElements(chart, axis));
          chart.scrollElement.appendChild(chart.scrollbarBase.scrollbarOptions[axis.name].svgObject);
        } else {
          var scrollEle = this.getElement(chart.id + '_scrollElement');
          if (scrollEle.childNodes.length > 0) var scrollSvg = document.getElementById(chart.id + '_scrollBar_svg' + axis.name);
          if (scrollSvg) {
            scrollSvg.style.display = "none";
          }
        }
      }
    },
    renderElements: function renderElements(chart, axis) {
      var isInverse = axis.isAxisInverse;
      var scrollbar = chart.scrollbarBase;
      var scrollbarOptions = scrollbar.scrollbarOptions[axis.name];
      var renderer = chart.userInteractionBase.svgRenderer;
      var scrollGroup = renderer.createGroup({
        id: chart.id + 'scrollBar_' + axis.name,
        transform: 'translate(' + (scrollbarOptions.isVertical && isInverse ? scrollbarOptions.height : isInverse ? scrollbarOptions.width : '0') + ',' + (scrollbarOptions.isVertical && isInverse ? '0' : isInverse ? scrollbarOptions.height : scrollbarOptions.isVertical ? scrollbarOptions.width : '0') + ') rotate(' + (scrollbarOptions.isVertical && isInverse ? '90' : scrollbarOptions.isVertical ? '270' : isInverse ? '180' : '0') + ')'
      });
      var backRectGroup = renderer.createGroup({
        id: chart.id + 'scrollBar_backRect_' + axis.name
      });
      var thumbGroup = renderer.createGroup({
        id: chart.id + 'scrollBar_thumb_' + axis.name,
        transform: 'translate(0,0)'
      });
      this.backRect(scrollbar, renderer, backRectGroup);
      this.thumb(scrollbar, renderer, thumbGroup);
      this.renderCircle(scrollbar, renderer, thumbGroup);
      this.arrows(scrollbar, renderer, thumbGroup);
      this.thumbGrip(scrollbar, renderer, thumbGroup);
      scrollGroup.appendChild(backRectGroup);
      scrollGroup.appendChild(thumbGroup);
      return scrollGroup;
    },
    backRect: function backRect(scroll, renderer, parent) {
      var style = scroll.scrollbarThemeStyle;
      var backRectEle = renderer.drawRectangle(new RectOption(scroll.chartId + 'scrollBarBackRect_' + scroll.axis.name, style.backRect, {
        width: 1,
        color: style.backRect
      }, 1, new sf.svgbase.Rect(0, 0, scroll.scrollbarOptions[scroll.axis.name].width, scroll.scrollbarOptions[scroll.axis.name].height), 0, 0));
      parent.appendChild(backRectEle);
    },
    thumb: function thumb(scroll, renderer, parent) {
      scroll.scrollbarOptions[scroll.axis.name].startX = scroll.scrollbarOptions[scroll.axis.name].thumbRectX;
      var style = scroll.scrollbarThemeStyle;
      scroll.scrollbarOptions[scroll.axis.name].slider = renderer.drawRectangle(new RectOption(scroll.chartId + 'scrollBarThumb_' + scroll.axis.name, style.thumb, {
        width: 1,
        color: ''
      }, 1, new sf.svgbase.Rect(scroll.scrollbarOptions[scroll.axis.name].thumbRectX, 0, scroll.scrollbarOptions[scroll.axis.name].thumbRectWidth, scroll.scrollbarOptions[scroll.axis.name].height)));
      parent.appendChild(scroll.scrollbarOptions[scroll.axis.name].slider);
    },
    renderCircle: function renderCircle(scroll, renderer, parent) {
      var style = scroll.scrollbarThemeStyle;
      var option = new CircleOption(scroll.chartId + 'scrollBar_leftCircle_' + scroll.axis.name, style.circle, {
        width: 1,
        color: style.circle
      }, 1, scroll.scrollbarOptions[scroll.axis.name].thumbRectX, scroll.scrollbarOptions[scroll.axis.name].height / 2, 8);
      var scrollShadowEle = '<filter x="-25.0%" y="-20.0%" width="150.0%" height="150.0%" filterUnits="objectBoundingBox"' + 'id="scrollbar_shadow"><feOffset dx="0" dy="1" in="SourceAlpha" result="shadowOffsetOuter1"></feOffset>' + '<feGaussianBlur stdDeviation="1.5" in="shadowOffsetOuter1" result="shadowBlurOuter1"></feGaussianBlur>' + '<feComposite in="shadowBlurOuter1" in2="SourceAlpha" operator="out" result="shadowBlurOuter1"></feComposite>' + '<feColorMatrix values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.16 0" type="matrix" in="shadowBlurOuter1">' + '</feColorMatrix></filter>';
      var defElement = renderer.createDefs();
      var shadowGroup = renderer.createGroup({
        id: scroll.chartId + scroll.axis.name + '_thumb_shadow'
      });
      defElement.innerText = scrollShadowEle;
      shadowGroup.innerText = '<use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' + scroll.chartId + 'scrollBar_leftCircle_' + scroll.axis.name + '"></use><use fill="black" fill-opacity="1" filter="url(#scrollbar_shadow)" xlink:href="#' + scroll.chartId + 'scrollBar_rightCircle_' + scroll.axis.name + '"></use>';
      scroll.scrollbarOptions[scroll.axis.name].leftCircleEle = renderer.drawCircle(option);
      option.id = scroll.chartId + 'scrollBar_rightCircle_' + scroll.axis.name;
      option.cx = scroll.scrollbarOptions[scroll.axis.name].thumbRectX + scroll.scrollbarOptions[scroll.axis.name].thumbRectWidth;
      scroll.scrollbarOptions[scroll.axis.name].rightCircleEle = renderer.drawCircle(option);
      parent.appendChild(defElement);
      parent.appendChild(scroll.scrollbarOptions[scroll.axis.name].leftCircleEle);
      parent.appendChild(scroll.scrollbarOptions[scroll.axis.name].rightCircleEle);
      parent.appendChild(shadowGroup);
    },
    arrows: function arrows(scroll, renderer, parent) {
      var style = scroll.scrollbarThemeStyle;
      var option = new sf.svgbase.PathOption(scroll.chartId + 'scrollBar_leftArrow_' + scroll.axis.name, style.arrow, 1, style.arrow, 1, '', '');
      var scrollbarOptions = scroll.scrollbarOptions[scroll.axis.name];
      scrollbarOptions.leftArrowEle = renderer.drawPath(option);
      option.id = scroll.chartId + 'scrollBar_rightArrow_' + scroll.axis.name;
      scrollbarOptions.rightArrowEle = renderer.drawPath(option);
      this.setArrowDirection(scroll);
      var circleRadius = 8;
      var leftDirection = 'M ' + (scrollbarOptions.thumbRectX - circleRadius / 2 + 1) + ' ' + scrollbarOptions.height / 2 + ' ' + 'L ' + (scrollbarOptions.thumbRectX - circleRadius / 2 + 6) + ' ' + 11 + ' ' + 'L ' + (scrollbarOptions.thumbRectX - circleRadius / 2 + 6) + ' ' + 5 + ' Z';
      var rightDirection = 'M ' + (scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth + circleRadius / 2 - 0.5) + ' ' + scrollbarOptions.height / 2 + ' ' + 'L ' + (scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth + circleRadius / 2 - 6) + ' ' + 11.5 + ' ' + 'L ' + (scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth + circleRadius / 2 - 6) + ' ' + 4.5 + ' Z';
      scrollbarOptions.leftArrowEle.setAttribute('d', leftDirection);
      scrollbarOptions.rightArrowEle.setAttribute('d', rightDirection);
      parent.appendChild(scrollbarOptions.leftArrowEle);
      parent.appendChild(scrollbarOptions.rightArrowEle);
    },
    setArrowDirection: function setArrowDirection(scroll) {
      var scrollbarOptions = scroll.scrollbarOptions[scroll.axis.name];
      var thumbRectX = scrollbarOptions.thumbRectX;
      var thumbRectWidth = scrollbarOptions.thumbRectWidth;
      var height = scrollbarOptions.height;
      var circleRadius = 8;
      var leftDirection = 'M ' + (thumbRectX - circleRadius / 2 + 1) + ' ' + height / 2 + ' ' + 'L ' + (thumbRectX - circleRadius / 2 + 6) + ' ' + 11 + ' ' + 'L ' + (thumbRectX - circleRadius / 2 + 6) + ' ' + 5 + ' Z';
      var rightDirection = 'M ' + (thumbRectX + thumbRectWidth + circleRadius / 2 - 0.5) + ' ' + height / 2 + ' ' + 'L ' + (thumbRectX + thumbRectWidth + circleRadius / 2 - 6) + ' ' + 11.5 + ' ' + 'L ' + (thumbRectX + thumbRectWidth + circleRadius / 2 - 6) + ' ' + 4.5 + ' Z';
      scrollbarOptions.leftArrowEle.setAttribute('d', leftDirection);
      scrollbarOptions.rightArrowEle.setAttribute('d', rightDirection);
    },
    thumbGrip: function thumbGrip(scroll, renderer, parent) {
      var sidePadding = 0;
      var topPadding = 0;
      var gripWidth = 14;
      var gripCircleDiameter = 2;
      var padding = gripWidth / 2 - gripCircleDiameter;
      var style = scroll.scrollbarThemeStyle;
      var option = new CircleOption(scroll.chartId + 'scrollBar_gripCircle0' + '_' + scroll.axis.name, style.grip, {
        width: 1,
        color: style.grip
      }, 1, 0, 0, 1);
      var scrollbarOptions = scroll.scrollbarOptions[scroll.axis.name];
      scrollbarOptions.gripCircle = renderer.createGroup({
        id: scroll.chartId + 'scrollBar_gripCircle_' + scroll.axis.name,
        transform: 'translate(' + (scrollbarOptions.thumbRectX + scrollbarOptions.thumbRectWidth / 2 + (scrollbarOptions.isVertical ? 1 : -1) * padding) + ',' + (scrollbarOptions.isVertical ? '10' : '5') + ') rotate(' + (scrollbarOptions.isVertical ? '180' : '0') + ')'
      });
      for (var i = 1; i <= 6; i++) {
        option.id = scroll.chartId + 'scrollBar_gripCircle' + i + '_' + scroll.axis.name;
        option.cx = sidePadding;
        option.cy = topPadding;
        scrollbarOptions.gripCircle.appendChild(renderer.drawCircle(option));
        sidePadding = i === 3 ? 0 : sidePadding + 5;
        topPadding = i >= 3 ? 5 : 0;
      }
      parent.appendChild(scrollbarOptions.gripCircle);
    },
    getTheme: function getTheme(chart) {
      //chart.scrollbarBase.scrollbarThemeStyle = this.scrollbarOptions.theme;
    },
    getDefaults: function getDefaults(chart, axis) {
      var circleRadius = 8;
      var padding = 5;
      var gripWidth = 14;
      var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
      if (!chart.scrollbarBase.scrollbarOptions[axis.name]) {
        chart.scrollbarBase.scrollbarOptions[axis.name] = {};
      }
      var currentScrollbarOptions = chart.scrollbarBase.scrollbarOptions[axis.name];
      if (axis.scrollbarSettings.enable) {
        currentScrollbarOptions.isLazyLoad = true;
        this.getLazyDefaults(chart, axis);
      }
      currentScrollbarOptions.isVertical = axis.orientation === 'Vertical';
      currentScrollbarOptions.zoomFactor = currentScrollbarOptions.isLazyLoad ? currentScrollbarOptions.zoomFactor : axis.zoomFactor;
      currentScrollbarOptions.zoomPosition = currentScrollbarOptions.isLazyLoad ? currentScrollbarOptions.zoomPosition : axis.zoomPosition;
      var currentWidth = currentScrollbarOptions.zoomFactor * (currentScrollbarOptions.isVertical ? axis.rect.h : axis.rect.w);
      currentWidth = currentWidth > minThumbWidth ? currentWidth : minThumbWidth;
      currentScrollbarOptions.scrollX = axis.rect.x;
      currentScrollbarOptions.scrollY = axis.rect.y;
      currentScrollbarOptions.width = currentScrollbarOptions.isVertical ? axis.rect.h : axis.rect.w;
      currentScrollbarOptions.height = 16;
      var currentX = currentScrollbarOptions.zoomPosition * (currentScrollbarOptions.isVertical ? axis.rect.h : currentScrollbarOptions.width);
      currentX = currentScrollbarOptions.isLazyLoad && currentX == 0 && currentScrollbarOptions.startX ? currentScrollbarOptions.startX : currentX;
      var minThumbX = currentScrollbarOptions.width - minThumbWidth - circleRadius;
      currentScrollbarOptions.thumbRectX = currentX > minThumbX ? minThumbX : currentX < circleRadius ? circleRadius : currentX;
      currentScrollbarOptions.thumbRectWidth = chart.scrollbarBase.isThumbDrag || chart.isWheelScrolling ? currentScrollbarOptions.thumbRectWidth : currentWidth + currentScrollbarOptions.thumbRectX < currentScrollbarOptions.width - circleRadius * 2 ? currentWidth : currentScrollbarOptions.width - currentScrollbarOptions.thumbRectX - circleRadius;
    },
    getLazyDefaults: function getLazyDefaults(chart, axis) {
      var start;
      var end;
      var valueType = axis.valueType;
      var scrollbarSettings = axis.scrollbarSettings;
      var range = axis.scrollbarSettings.range;
      var visibleRange = axis.visibleRange;
      var pointsLength = axis.scrollbarSettings.pointsLength;
      var currentScrollbarOptions = chart.scrollbarBase.scrollbarOptions[axis.name];
      currentScrollbarOptions.valueType = valueType = (!sf.base.isNullOrUndefined(scrollbarSettings.range.minimum) || !sf.base.isNullOrUndefined(scrollbarSettings.range.maximum)) && scrollbarSettings.pointsLength ? 'Double' : valueType;
      switch (valueType) {
        case 'Double':
        case 'Category':
        case 'Logarithmic':
          start = range.minimum ? range.minimum : pointsLength ? 0 : visibleRange.start;
          end = range.maximum ? range.maximum : pointsLength ? pointsLength - 1 : visibleRange.end;
          break;
        case 'DateTime':
        case 'DateTimeCategory':
          start = range.minimum ? Date.parse(range.minimum) : visibleRange.start;
          end = range.maximum ? Date.parse(range.maximum) : visibleRange.end;
          break;
      }
      if (axis.valueType !== 'Category') {
        start = Math.min(start, visibleRange.start);
        end = Math.max(end, visibleRange.end);
      }
      var zoomFactor = (visibleRange.end - visibleRange.start) / (end - start);
      var zoomPosition = (visibleRange.start - start) / (end - start);
      currentScrollbarOptions.zoomFactor = range.minimum || range.maximum ? zoomFactor : currentScrollbarOptions.zoomFactor ? currentScrollbarOptions.zoomFactor : axis.maxPointLength / axis.scrollbarSettings.pointsLength;
      currentScrollbarOptions.zoomPosition = range.minimum || range.maximum ? zoomPosition : currentScrollbarOptions.zoomPosition ? currentScrollbarOptions.zoomPosition : axis.zoomPosition;
      currentScrollbarOptions.scrollRange = {
        start: start,
        end: end,
        delta: axis.valueType == 'Category' && !range.maximum ? pointsLength : end - start
      };
      currentScrollbarOptions.previousStart = visibleRange.start;
      currentScrollbarOptions.previousEnd = visibleRange.end;
    },
    createScrollSvg: function createScrollSvg(axis, chart, renderer) {
      var rect = axis.rect;
      var isHorizontalAxis = axis.orientation === 'Horizontal';
      var enablePadding = false;
      var currentScrollbarOptions = chart.scrollbarBase.scrollbarOptions[axis.name];
      var cursorType = chart.scrollbarBase.isThumbDrag && currentScrollbarOptions.isLazyLoad ? '-webkit-grabbing' : 'auto';
      currentScrollbarOptions.svgObject = renderer.createSvg({
        id: chart.element.id + '_' + 'scrollBar_svg' + axis.name,
        width: currentScrollbarOptions.isVertical ? currentScrollbarOptions.height : currentScrollbarOptions.width,
        height: currentScrollbarOptions.isVertical ? currentScrollbarOptions.width : currentScrollbarOptions.height,
        style: 'position: absolute;top: ' + ((axis.isAxisOppositePosition && isHorizontalAxis ? -16 : enablePadding ? 5 : 0) + rect.y + chart.userInteractionBase.secondaryElementOffset.top) + 'px;left: ' + ((axis.isAxisOppositePosition && !isHorizontalAxis ? 16 : 0) + rect.x - (currentScrollbarOptions.isVertical ? currentScrollbarOptions.height : 0) + chart.userInteractionBase.secondaryElementOffset.left) + 'px;cursor:' + cursorType + ';'
      });
    },
    removeScrollSvg: function removeScrollSvg(component, axis) {
      if (document.getElementById(component.element.id + '_scrollBar_svg' + axis.name)) {
        sf.base.remove(document.getElementById(component.element.id + '_scrollBar_svg' + axis.name));
      }
    },
    removeTooltipCrosshair: function removeTooltipCrosshair() {
      for (var key in window.sfBlazor.instances) {
        if (window.sfBlazor.instances.hasOwnProperty(key)) {
          var chartInstance = window.sfBlazor.instances[key];
          if (!sf.base.isNullOrUndefined(chartInstance) && !sf.base.isNullOrUndefined(document.getElementById(chartInstance.id)) && chartInstance.dataId.indexOf("sfChart-") !== -1 && chartInstance.tooltipBase.tooltipModule && chartInstance.crosshairBase.crosshair) {
            this.removeTooltip(10, chartInstance);
            this.removeCrosshair(chartInstance, 10);
          }
        }
      }
    }
  };
  return Chart;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfchart');})})();