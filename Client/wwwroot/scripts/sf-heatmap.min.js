(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-heatmap"],{

/***/ "./bundles/sf-heatmap.js":
/*!*******************************!*\
  !*** ./bundles/sf-heatmap.js ***!
  \*******************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_heatmap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-heatmap.js */ "./modules/sf-heatmap.js");
/* harmony import */ var _modules_sf_heatmap_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_heatmap_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-heatmap.js":
/*!*******************************!*\
  !*** ./modules/sf-heatmap.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.HeatMap = function () {
  'use strict';

  var SfHeatMap = /** @class */function () {
    function SfHeatMap(element, dotnetRef) {
      this.tapCount = 0;
      this.isDoubleClick = false;
      this.previousTargetID = '';
      this.isSelectionRectCreated = false;
      this.mouseClick = false;
      this.checkCtrlKey = false;
      this.tooltipRender = true;
      this.isCellTapHold = false;
      this.rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      this.resizeTimer = 0;
      this.previousCellID = "";
      window.sfBlazor = window.sfBlazor;
      this.element = element;
      this.dataId = element.id;
      window.sfBlazor.setCompInstance(this);
      this.dotnetRef = dotnetRef;
    }
    SfHeatMap.prototype.initialize = function (property) {
      var _this = this;
      this.enableMultiSelect = property.EnableMultiSelect;
      this.allowSelection = property.AllowSelection;
      this.isRectType = property.IsRectType;
      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      sf.base.EventHandler.add(this.element, 'click touchend', this.heatMapMouseClick, this);
      sf.base.EventHandler.add(this.element, 'dblclick touchend', this.heatMapDoubleMouseClick, this);
      sf.base.EventHandler.add(this.element, 'mousedown touchstart', this.heatMapMouseDown, this);
      sf.base.EventHandler.add(this.element, 'mouseup touchend', this.heatMapMouseUp, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchStartEvent, this.heatMapMouseMove, this);
      sf.base.EventHandler.add(this.element, cancelEvent, this.heatMapMouseLeave, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchMoveEvent, this.heatMapMouseMove, this);
      var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sf.base.EventHandler.add(window, resize, this.resizeBound.bind(this), this);
      // Variables that hold the client rect values of the X Axis, Y Axis, Legend, Title and Heatmap element.
      var availableSize = this.getElementBounds(this.element);
      // eslint-disable-next-line
      this.touchInstance = new sf.base.Touch(this.element, {
        tapHold: function tapHold(e) {
          _this.isCellTapHold = true;
          _this.isSelectionRectCreated = true;
          _this.cellTap(e);
        }
      });
      return "width:" + availableSize.width + ", height:" + availableSize.height + ", parentHeight:" + availableSize.parentHeight;
    };
    SfHeatMap.prototype.cellTap = function (e) {
      if (this.allowSelection) {
        this.dotnetRef.invokeMethodAsync('HeatMapMouseClick', this.getEventArgs(e.originalEvent), this.getElementBounds(this.element), this.isCellTapHold, this.isSelectionRectCreated, false);
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.heatMapMouseClick = function (e) {
      var _this = this;
      this.singleClickTimeout = setTimeout(function () {
        if (!_this.isDoubleClick) {
          _this.dotnetRef.invokeMethodAsync('HeatMapMouseClick', _this.getEventArgs(e), _this.getElementBounds(_this.element), _this.isCellTapHold, _this.isSelectionRectCreated, false);
        }
      }, 200);
      this.isSelectionRectCreated = false;
    };
    SfHeatMap.prototype.heatMapDoubleMouseClick = function (e) {
      var _this = this;
      if (e.type === "touchend") {
        this.tapCount = this.tapCount > 1 ? 0 : this.tapCount + 1;
        var proxy_1 = this;
        if (sf.base.isNullOrUndefined(this.tapCountTimer)) {
          this.tapCountTimer = setTimeout(function () {
            window.clearTimeout(proxy_1.tapCountTimer);
            proxy_1.tapCountTimer = null;
            proxy_1.tapCount = 0;
          }, 1000);
        }
      }
      if (this.tapCount > 1 && this.previousTargetID === e.target.id || e.type === "dblclick") {
        this.isDoubleClick = true;
        setTimeout(function () {
          _this.isDoubleClick = false;
        }, 1000);
        this.dotnetRef.invokeMethodAsync('HeatMapMouseClick', this.getEventArgs(e), this.getElementBounds(this.element), this.isCellTapHold, this.isSelectionRectCreated, true);
        this.isSelectionRectCreated = false;
        this.previousTargetID = '';
        clearTimeout(this.singleClickTimeout);
      }
      this.previousTargetID = e.target.id;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.heatMapMouseUp = function (e) {
      var _this = this;
      this.startRectValue = null;
      var rectElement = document.getElementById(this.element.id + '_selectedCells');
      var selectionBounds = null;
      if (rectElement) {
        this.mouseClick = false;
        selectionBounds = rectElement.getBoundingClientRect();
        rectElement.remove();
        if (this.isSelectionRectCreated && !e.ctrlKey && e.type === "touchend") {
          this.isCellTapHold = true;
        }
      }
      if (e.type === "touchend") {
        this.tooltipfadeOut(e);
      }
      this.tooltipRender = true;
      if (this.initialX != (e.changedTouches ? e.changedTouches[0].clientX : e.clientX) && selectionBounds == null || e.type == "touchend" && this.isCellTapHold) {
        this.isCellTapHold = true;
      } else {
        this.isCellTapHold = false;
      }
      if (this.allowSelection && this.isRectType) {
        if (e.type === "touchend") {
          setTimeout(function () {
            _this.dotnetRef.invokeMethodAsync('HeatMapMouseUp', _this.getEventArgs(e), selectionBounds, _this.getElementBounds(_this.element), _this.isCellTapHold, _this.checkCtrlKey);
          }, 200);
        } else {
          this.dotnetRef.invokeMethodAsync('HeatMapMouseUp', this.getEventArgs(e), selectionBounds, this.getElementBounds(this.element), this.isCellTapHold, this.checkCtrlKey);
        }
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.heatMapMouseDown = function (e) {
      if (this.allowSelection && this.isRectType && (e.target.id.indexOf(this.element.id + '_HeatMapRect_') != -1 || e.target.id.indexOf(this.element.id + '_HeatMapRectLabels_') != -1)) {
        if (this.previousCellID != "" && e.type != "touchstart" && e.type != "touchmove") {
          this.selectionHighLight(e.target.id);
        }
        this.mouseClick = true;
        this.initialX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        this.initialY = e.changedTouches ? e.changedTouches[0].clientY : e.clientX;
        var style = void 0;
        if (document.querySelector('#selectedCellStyles') != null && document.querySelector('#selectedCellStyles')['length'] != 0) {
          style = document.getElementById('selectedCellStyles');
          style.innerHTML = '.selectedCell {opacity: 0.3;}';
        } else {
          style = document.createElement('style');
          style.id = "selectedCellStyles";
          style.innerHTML = '.selectedCell {opacity: 0.3;}';
        }
        document.body.appendChild(style);
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.heatMapMouseLeave = function (e) {
      var rectElement = document.getElementById(this.element.id + '_selectedCells');
      var selectionBounds = null;
      if (this.mouseClick) {
        this.previousCellID = '';
      }
      if (rectElement) {
        selectionBounds = rectElement.getBoundingClientRect();
        rectElement.remove();
        this.startRectValue = null;
        this.mouseClick = false;
      }
      this.tooltipRender = true;
      this.initialX = null;
      this.initialY = null;
      this.dotnetRef.invokeMethodAsync('HeatMapMouseLeave', this.getEventArgs(e), selectionBounds, this.getElementBounds(this.element), this.isCellTapHold, this.checkCtrlKey);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.heatMapMouseMove = function (e) {
      var isTemplateRendered = true;
      if (e.type == "touchstart" || e.type == "touchmove") {
        e.preventDefault();
      }
      if (this.allowSelection && this.enableMultiSelect && this.isRectType && !sf.base.isNullOrUndefined(this.initialX) && !sf.base.isNullOrUndefined(this.initialY) && this.mouseClick) {
        var mousePosition = this.getEventArgs(e);
        var rectHeight = 0;
        var rectWidth = 0;
        var mouseX = void 0;
        var mouseY = void 0;
        if (mousePosition.type === "touchstart" || mousePosition.type === "touchmove") {
          mouseX = mousePosition.changedTouches.clientX;
          mouseY = mousePosition.changedTouches.clientY;
        } else {
          mouseX = mousePosition.clientX;
          mouseY = mousePosition.clientY;
        }
        var containerRect = this.getElementBounds(document.getElementById(this.element.id + '_Container_RectGroup'));
        if (this.initialX > containerRect['left'] && this.initialY > containerRect['top']) {
          var bounds = document.getElementById(this.element.id + '_svg').getBoundingClientRect();
          if (sf.base.isNullOrUndefined(this.startRectValue)) {
            this.startRectValue = this.svgPoint(this.svg, mouseX, mouseY);
            this.checkCtrlKey = e.ctrlKey;
          }
          var position = this.svgPoint(this.svg, mouseX, mouseY);
          if (position.x < containerRect['right'] && position.x > containerRect['left'] && position.y < containerRect['bottom'] && position.y > containerRect['top']) {
            rectWidth = Math.abs((position.x < containerRect['right'] ? position.x : containerRect['right']) - this.startRectValue.x);
            rectHeight = Math.abs((position.y < containerRect['bottom'] ? position.y : containerRect['bottom']) - this.startRectValue.y);
            position.x = position.x > this.startRectValue.x ? this.startRectValue.x : position.x;
            position.y = position.y > this.startRectValue.y ? this.startRectValue.y : position.y;
            if (mousePosition.type === "touchstart" || mousePosition.type === "touchmove") {
              this.tooltipRender = true;
              this.tooltipfadeOut(e);
            }
            if (this.enableMultiSelect) {
              position.x = position.x - bounds['x'];
              position.y = position.y - bounds['y'];
              this.rect.setAttributeNS(null, 'x', position.x.toString());
              this.rect.setAttributeNS(null, 'y', position.y.toString());
              this.rect.setAttributeNS(null, 'id', this.element.id + '_selectedCells');
              this.rect.setAttributeNS(null, 'width', rectWidth.toString());
              this.rect.setAttributeNS(null, 'height', rectHeight.toString());
              this.rect.setAttributeNS(null, 'fill', '#87ceeb');
              this.rect.setAttributeNS(null, 'stroke-dasharray', '0');
              this.rect.setAttributeNS(null, 'opacity', '0.5');
              this.rect.setAttributeNS(null, 'stroke', '#0000ff');
              document.getElementById(this.element.id + '_Container_RectGroup').appendChild(this.rect);
              if (rectWidth > 0 || rectHeight > 0) {
                this.isSelectionRectCreated = true;
                this.tooltipRender = false;
                var tooltipElement = document.getElementById(this.element.id + '_tooltip_svg');
                if (tooltipElement) {
                  tooltipElement.remove();
                }
                isTemplateRendered = false;
                if (!e.ctrlKey && (e.target.id.indexOf(this.element.id + '_HeatMapRect_') != -1 || e.target.id.indexOf(this.element.id + '_HeatMapRectLabels_') != -1)) {
                  if (this.previousCellID != "") {
                    this.selectionHighLight(e.target.id);
                  }
                  var containerRectElement = document.getElementById(this.element.id + '_Container_RectGroup');
                  var containerTextElement = document.getElementById(this.element.id + '_Container_TextGroup');
                  for (var i = 0; i < containerRectElement.childNodes.length; i++) {
                    var childElement = containerRectElement.childNodes[i];
                    if (!sf.base.isNullOrUndefined(childElement.id) && childElement.id.indexOf('HeatMapRect') > -1) {
                      childElement.classList.add('selectedCell');
                    }
                  }
                  for (var i = 0; i < containerTextElement.childNodes.length; i++) {
                    var childElement = containerTextElement.childNodes[i];
                    if (!sf.base.isNullOrUndefined(childElement.id) && childElement.id.indexOf('_HeatMapRectLabels_') > -1) {
                      childElement.removeAttribute('opacity');
                      childElement.setAttribute('style', 'opacity:0.3');
                      childElement.classList.add('selectedCell');
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (this.allowSelection && !this.enableMultiSelect && this.mouseClick && (e.type == "touchmove" || e.type == "mousemove")) {
        if (this.previousCellID != "" && document.getElementById(this.previousCellID).getAttribute('opacity') == "0.3") {
          this.previousCellID = '';
        }
      }
      this.dotnetRef.invokeMethodAsync('HeatMapMouseMove', this.getEventArgs(e), this.getElementBounds(this.element), isTemplateRendered, sf.base.Browser.isDevice);
    };
    SfHeatMap.prototype.svgPoint = function (elem, x, y) {
      var p = this.svg.createSVGPoint();
      p.x = x;
      p.y = y;
      if (elem.getScreenCTM()) {
        return p.matrixTransform(elem.getScreenCTM().inverse());
      } else {
        return p;
      }
    };
    SfHeatMap.prototype.selectionHighLight = function (cellID) {
      if (cellID.indexOf(this.element.id + '_HeatMapRectLabels_') != -1) {
        var label = cellID.replace(this.element.id + '_HeatMapRectLabels_', this.element.id + '_HeatMapRect_');
        var number = parseInt(label.split('_')[2]);
        number++;
        var updatedID = label.slice(0, label.lastIndexOf("_") + 1) + number.toString();
        this.previousCellID = updatedID;
        if (document.getElementById(this.previousCellID)) {
          this.setOpacity(document.getElementById(this.previousCellID), '1');
        }
      } else {
        if (document.getElementById(this.previousCellID)) {
          this.setOpacity(document.getElementById(this.previousCellID), '1');
        }
        this.previousCellID = cellID;
      }
    };
    SfHeatMap.prototype.tooltipfadeOut = function (e) {
      var _this = this;
      if (this.tooltipTimer) {
        window.clearTimeout(this.tooltipTimer);
        this.tooltipTimer = null;
      }
      if (e.type === "touchstart" || e.type === "touchend") {
        var instance_1 = window.sfBlazor.getCompInstance(this.element.id);
        this.tooltipTimer = setTimeout(function () {
          if (!sf.base.isNullOrUndefined(instance_1.tooltip) && !sf.base.isNullOrUndefined(instance_1.tooltip.element) && !sf.base.isNullOrUndefined(instance_1.tooltip.element.firstElementChild)) {
            instance_1.tooltip.fadeOut();
          }
          _this.dotnetRef.invokeMethodAsync('RemoveTooltip', true, e.target.id);
          if (_this.previousCellID != "") {
            _this.previousCellID = '';
          }
          _this.selectionHighLight(e.target.id);
          window.clearTimeout(_this.tooltipTimer);
          _this.tooltipTimer = null;
        }, 1500);
        if (e) {
          if (e.type === 'touchmove') {
            e.preventDefault();
          }
        }
      }
    };
    SfHeatMap.prototype.resizeBound = function () {
      var _this = this;
      var width;
      var height;
      if (!sf.base.isNullOrUndefined(this.element) && !sf.base.isNullOrUndefined(document.getElementById(this.element.id + '_svg'))) {
        var svgElement = document.getElementById(this.element.id + '_svg');
        svgElement.style.display = 'none';
        var elementRect = this.getElementBounds(this.element);
        width = elementRect.width;
        height = elementRect.height;
        svgElement.style.removeProperty('display');
      }
      if (this.previousHeight !== height || this.previousWidth !== width) {
        this.previousHeight = height;
        this.previousWidth = width;
        if (this.resizeTimer) {
          clearTimeout(this.resizeTimer);
        }
        if (this.element) {
          this.resizeTimer = setTimeout(function () {
            return _this.dotnetRef.invokeMethodAsync('ResizeBound', height, width);
          }, 500);
        }
      }
    };
    SfHeatMap.prototype.setMouseXY = function (pageX, pageY, id) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var svgRect = document.getElementById(id).getBoundingClientRect();
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var rect = document.getElementById(id).getBoundingClientRect();
      this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);
      this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.renderTooltip = function (id, elementId, tooltipOptions, args, cellHighlighting, isSingleCellSelected, isCellSelected, textStyle, fillColor, border, theme, header, isHorizontal) {
      if (this.tooltipRender) {
        var svgElement = document.getElementById(elementId + '_svg');
        var firstRender = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 ? false : true;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var options = typeof tooltipOptions == 'string' ? JSON.parse(tooltipOptions) : tooltipOptions;
        if (!isCellSelected && !isSingleCellSelected) {
          this.updateCellHighlight(tooltipOptions.id, cellHighlighting);
        }
        if (!sf.base.isNullOrUndefined(isHorizontal)) {
          options.inverted = !isHorizontal ? true : false;
          options.enableAnimation = false;
        }
        if (theme && theme == "TailwindDark") {
          options.fill = "#F9FAFB";
        }
        if (theme && theme == "Bootstrap5Dark") {
          options.fill = "#E9ECEF";
        }
        var instance = window.sfBlazor.getCompInstance(id);
        var currentInstance = instance;
        options.content = options.xLabel + options.yLabel + options.value;
        if (firstRender && !sf.base.isNullOrUndefined(currentInstance)) {
          options.content = options.displayText;
          options.location = {
            x: options.x + options.width / 2,
            y: options.y + options.height / 2
          };
          options.areaBounds = {
            height: args.height + args.y,
            width: args.width,
            x: args.x
          };
          options.opacity = theme == 'Tailwind' || theme === 'TailwindDark' || theme === 'Bootstrap5' || theme === 'Bootstrap5Dark' ? 1 : 0.75;
          options.theme = theme;
          options.fill = fillColor;
          options.header = header;
          currentInstance.tooltip = new sf.svgbase.Tooltip(options);
          currentInstance.tooltip.enableAnimation = false;
          currentInstance.tooltip.border.width = sf.base.isNullOrUndefined(border) ? currentInstance.tooltip.border.width : border.width;
          currentInstance.tooltip.border.color = sf.base.isNullOrUndefined(border) ? currentInstance.tooltip.border.color : border.color;
          currentInstance.tooltip.appendTo('#' + elementId);
        }
        if (!sf.base.isNullOrUndefined(currentInstance.tooltip)) {
          if (!sf.base.isNullOrUndefined(textStyle)) {
            currentInstance.tooltip.textStyle.color = textStyle.color || currentInstance.tooltip.textStyle.color;
            currentInstance.tooltip.textStyle.fontFamily = textStyle.fontFamily || currentInstance.tooltip.textStyle.fontFamily;
            currentInstance.tooltip.textStyle.fontStyle = textStyle.fontStyle || currentInstance.tooltip.textStyle.fontStyle;
            currentInstance.tooltip.textStyle.fontWeight = textStyle.fontWeight || currentInstance.tooltip.textStyle.fontWeight;
            currentInstance.tooltip.textStyle.size = textStyle.size || currentInstance.tooltip.textStyle.size;
          }
          if (theme && theme == "Tailwind") {
            currentInstance.tooltip.textStyle.color = "#FFFFFF";
            currentInstance.tooltip.textStyle.fontWeight = "500";
            currentInstance.tooltip.textStyle.size = "12px";
            currentInstance.tooltip.textStyle.fontFamily = "Inter";
          }
          if (theme && theme == "TailwindDark") {
            currentInstance.tooltip.textStyle.color = "#1F2937";
            currentInstance.tooltip.textStyle.fontWeight = "500";
            currentInstance.tooltip.textStyle.size = "12px";
            currentInstance.tooltip.textStyle.fontFamily = "Inter";
          }
          if (theme && theme == "Bootstrap5") {
            currentInstance.tooltip.border.width = 0;
            currentInstance.tooltip.border.color = "";
            currentInstance.tooltip.fill = "";
            currentInstance.tooltip.opacity = 0.75;
            currentInstance.tooltip.textStyle.opacity = 1;
            currentInstance.tooltip.textStyle.color = null;
            currentInstance.tooltip.textStyle.fontWeight = "Normal";
            currentInstance.tooltip.textStyle.size = "13px";
            currentInstance.tooltip.textStyle.fontFamily = "Segoe UI";
          }
          if (theme && theme == "Bootstrap5Dark") {
            currentInstance.tooltip.textStyle.color = "#212529";
            currentInstance.tooltip.textStyle.fontWeight = "500";
            currentInstance.tooltip.textStyle.size = "14px";
            currentInstance.tooltip.textStyle.fontFamily = "system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'";
          }
          if (theme && theme == "Material3") {
            currentInstance.tooltip.textStyle.color = "#F4EFF4";
            currentInstance.tooltip.textStyle.fontWeight = "400";
            currentInstance.tooltip.textStyle.size = "14px";
            currentInstance.tooltip.textStyle.fontFamily = "Roboto";
          }
          if (theme && theme == "Material3Dark") {
            currentInstance.tooltip.textStyle.color = "#313033";
            currentInstance.tooltip.textStyle.fontWeight = "400";
            currentInstance.tooltip.textStyle.size = "14px";
            currentInstance.tooltip.textStyle.fontFamily = "Roboto";
          }
          options.toolTipX = options.x + options.width / 2;
          options.toolTipY = options.y + options.height / 2;
          options.content = options.displayText;
          currentInstance.tooltip.location = new sf.svgbase.TooltipLocation(options.toolTipX, options.toolTipY);
          currentInstance.tooltip.content = [options.content];
          currentInstance.tooltip.dataBind();
        }
      }
    };
    SfHeatMap.prototype.removeOpacity = function (id, selectedCells) {
      for (var i = 0; i < selectedCells.length; i++) {
        var selectedItem = selectedCells[i];
        if (!sf.base.isNullOrUndefined(selectedItem.id) && selectedItem.id.indexOf('HeatMapRect') > -1) {
          document.getElementById(selectedItem.id).classList.remove('selectedCell');
          var index = parseInt(selectedItem.id.replace(id + '_HeatMapRect_', ''), 10);
          var labelElement = document.getElementById(id + '_HeatMapRectLabels_' + (index - 1));
          labelElement.classList.remove('selectedCell');
          labelElement.setAttribute('style', 'opacity: 1');
        }
      }
    };
    SfHeatMap.prototype.setSelectionProperty = function (allowSelection, enableMultiSelect, isRectType) {
      this.allowSelection = allowSelection;
      this.enableMultiSelect = enableMultiSelect;
      this.isRectType = isRectType;
    };
    SfHeatMap.prototype.updateCellHighlight = function (cellID, cellHighlighting) {
      if (this.previousCellID !== cellID) {
        if (this.previousCellID != "") {
          this.setOpacity(document.getElementById(this.previousCellID), '1');
        }
        if (cellHighlighting) {
          this.setOpacity(document.getElementById(cellID), '0.65');
          this.previousCellID = cellID;
        }
      }
    };
    SfHeatMap.prototype.setOpacity = function (element, value) {
      element.setAttribute('opacity', value);
    };
    SfHeatMap.prototype.getElementBounds = function (element) {
      var elementWidth;
      var elementHeight;
      var elementTop;
      var elementBottom;
      var elementRight;
      var elementLeft;
      var elementParentHeight;
      if (element != null) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width, elementHeight = elementRect.height, elementParentHeight = element.parentElement ? element.parentElement.offsetHeight : elementRect.height, elementLeft = elementRect.left, elementTop = elementRect.top, elementRight = elementRect.right, elementBottom = elementRect.bottom;
      }
      return {
        width: Math.ceil(elementWidth),
        height: Math.ceil(elementHeight),
        parentHeight: Math.ceil(elementParentHeight),
        left: Math.ceil(elementLeft),
        top: Math.ceil(elementTop),
        right: Math.ceil(elementRight),
        bottom: Math.ceil(elementBottom)
      };
    };
    SfHeatMap.prototype.stringToNumber = function (value, containerSize) {
      if (!sf.base.isNullOrUndefined(value)) {
        return value.indexOf('%') !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);
      }
      return null;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfHeatMap.prototype.getEventArgs = function (e) {
      var clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      var clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
      var id = !sf.base.isNullOrUndefined(e.currentTarget) ? e.currentTarget.id : e.target.id;
      this.setMouseXY(clientX, clientY, id);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var touches = e.touches;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var touchList = [];
      if (e.type.indexOf('touch') > -1) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        for (var i = 0, length1 = touches.length; i < length1; i++) {
          touchList.push({
            pageX: touches[i].clientX,
            pageY: touches[i].clientY,
            pointerId: e.pointerId || 0
          });
        }
      }
      var targetId = e.type.indexOf('touchend') > -1 && !sf.base.isNullOrUndefined(document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY)) ? document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY).id : e.target.id;
      return {
        type: e.type,
        clientX: e.clientX,
        clientY: e.clientY,
        mouseX: this.mouseX,
        mouseY: this.mouseY,
        pointerType: e.pointerType,
        target: targetId,
        changedTouches: {
          clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
          clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
        },
        touches: touchList,
        pointerId: e.pointerId,
        ctrlKey: e.ctrlKey
      };
    };
    SfHeatMap.prototype.destroy = function () {
      var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
      sf.base.EventHandler.remove(this.element, 'click', this.heatMapMouseClick);
      sf.base.EventHandler.remove(this.element, 'dblclick touchend', this.heatMapDoubleMouseClick);
      sf.base.EventHandler.remove(this.element, 'mousedown touchstart', this.heatMapMouseDown);
      sf.base.EventHandler.remove(this.element, 'mouseup touchend', this.heatMapMouseUp);
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchStartEvent, this.heatMapMouseMove);
      sf.base.EventHandler.remove(this.element, cancelEvent, this.heatMapMouseLeave);
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchMoveEvent, this.heatMapMouseMove);
      var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sf.base.EventHandler.remove(window, resize, this.resizeBound.bind(this));
      this.element = null;
      this.svg = null;
      this.startRectValue = null;
      this.touchInstance.destroy();
      this.touchInstance = null;
      this.svg = null;
    };
    return SfHeatMap;
  }();
  // tslint:disable-next-line
  var HeatMap = {
    initialize: function initialize(element, dotnetRef, property) {
      new SfHeatMap(element, dotnetRef);
      var instance = window.sfBlazor.getCompInstance(element.id);
      return instance ? instance.initialize(property) : null;
    },
    removeOpacity: function removeOpacity(id, selectedCells) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.removeOpacity(id, selectedCells);
      }
    },
    getElementSize: function getElementSize(element, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        var availableSize = instance.getElementBounds(element);
        return "width:" + availableSize.width + ", height:" + availableSize.height + ", parentHeight:" + availableSize.parentHeight;
      }
      return null;
    },
    setSelectionProperty: function removeOpacity(id, allowSelection, enableMultiSelect, isRectType) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.setSelectionProperty(allowSelection, enableMultiSelect, isRectType);
      }
    },
    renderTooltipTemplate: function renderTooltipTemplate(id, mouseX, mouseY) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        var tooltipElement = document.getElementById(id + '_Tooltip');
        var treemapBorder = document.getElementById(id + '_HeatmapBorder');
        if (tooltipElement && treemapBorder) {
          var x = Number(treemapBorder.getAttribute('x'));
          var y = Number(treemapBorder.getAttribute('y'));
          var width = Number(treemapBorder.getAttribute('width'));
          var tooltipRect = tooltipElement.getBoundingClientRect();
          var left = void 0;
          var top_1;
          if (mouseY - tooltipRect.height < y) {
            if (mouseX + tooltipRect.width / 2 > width) {
              left = (width - tooltipRect.width).toString() + 'px';
            } else if (mouseX - tooltipRect.width / 2 < x) {
              left = tooltipElement.style.left = x.toString() + 'px';
            } else {
              left = (mouseX - tooltipRect.width / 2).toString() + 'px';
            }
            top_1 = mouseY.toString() + 'px';
          } else if (mouseX + tooltipRect.width / 2 > width) {
            left = (width - tooltipRect.width).toString() + 'px';
            top_1 = (mouseY - tooltipRect.height).toString() + 'px';
          } else if (mouseX - tooltipRect.width / 2 < x) {
            left = x.toString() + 'px';
            top_1 = (mouseY - tooltipRect.height).toString() + 'px';
          } else {
            left = (mouseX - tooltipRect.width / 2).toString() + 'px';
            top_1 = (mouseY - tooltipRect.height).toString() + 'px';
          }
          tooltipElement.style.left = left ? left : '0';
          tooltipElement.style.top = top_1 ? top_1 : '0';
          tooltipElement.style.visibility = 'visible';
        }
      }
    },
    renderTooltip: function renderTooltip(id, elementId,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    tooltipModule, tooltipOptions, args, cellHighlighting, isSingleCellSelected, isCellSelected, textStyle, fillColor, border, theme, header, isHorizontal) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.renderTooltip(id, elementId, tooltipOptions, args, cellHighlighting, isSingleCellSelected, isCellSelected, textStyle, fillColor, border, theme, header, isHorizontal);
      }
    },
    fadeOut: function fadeOut(id, isSingleCellSelected, tooltipTemplate) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (sf.base.isNullOrUndefined(instance) || !sf.base.isNullOrUndefined(instance) && sf.base.isNullOrUndefined(instance.tooltip)) {
          return;
        }
        var tooltipElement = document.getElementById(instance.dataId + '_tooltip_svg');
        if (instance.previousCellID != "" && !isSingleCellSelected) {
          if (document.getElementById(instance.previousCellID)) {
            instance.setOpacity(document.getElementById(instance.previousCellID), '1');
          }
          instance.previousCellID = "";
          if (!tooltipTemplate) {
            if (tooltipElement) {
              instance.tooltip.fadeOut();
            }
          }
        } else {
          if (!tooltipTemplate) {
            if (tooltipElement) {
              instance.tooltip.fadeOut();
            }
          }
        }
      }
    },
    destroy: function destroy(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance.element && instance) {
        instance.destroy();
      }
    }
  };
  return HeatMap;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfheatmap');})})();