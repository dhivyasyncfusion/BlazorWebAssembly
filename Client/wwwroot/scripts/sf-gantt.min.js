(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-gantt"],{

/***/ "./bundles/sf-gantt.js":
/*!*****************************!*\
  !*** ./bundles/sf-gantt.js ***!
  \*****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-gantt.js */ "./modules/sf-gantt.js");
/* harmony import */ var _modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_gantt_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-gantt.js":
/*!*****************************!*\
  !*** ./modules/sf-gantt.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Gantt = function () {
  'use strict';

  /**
   * Splitter module is used to define the splitter position in Gantt layout.
   */
  var ChartScroll = /** @class */function () {
    function ChartScroll(ganttParent, element) {
      this.previousCount = -1;
      this.timelineScrollLeft = 0;
      this.parent = ganttParent;
      this.chartRootElement = element.querySelector('.e-chart-root-container');
      this.chartElement = element.querySelector('.e-gantt-chart-pane');
      this.element = element.querySelector('.e-chart-scroll-container');
      this.timelineHeaderElement = element.querySelector('.e-timeline-header-container');
      this.chartVirtualTable = this.element.querySelector('.e-virtualtable');
      this.timelineVirtualTrack = this.timelineHeaderElement.querySelector('.e-virtualtrack');
      this.dependencyViewContainer = element.querySelector('.e-gantt-dependency-view-container');
      this.holidayContainer = element.querySelector('.e-holiday-container');
      this.addEventListeners();
      this.ChartHeight(element, this.chartRootElement);
    }
    ChartScroll.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.element, 'scroll', this.onScroll, this);
      sf.base.EventHandler.add(this.chartElement, sf.base.Browser.touchStartEvent, this.mouseDownHandler, this);
    };
    ChartScroll.prototype.removeEventListeners = function (ganttParent) {
      var chartElement = ganttParent.element.querySelector('.e-gantt-chart-pane');
      var chartPane = ganttParent.element.querySelector('.e-chart-scroll-container');
      sf.base.EventHandler.remove(chartPane, 'scroll', this.onScroll);
      sf.base.EventHandler.remove(chartElement, sf.base.Browser.touchStartEvent, this.mouseDownHandler);
    };
    ChartScroll.prototype.gridScrollHandler = function (top) {
      this.element.scrollTop = top;
      this.parent.isFromTreeGrid = true;
    };
    ChartScroll.prototype.showHideSpinner = function (isShow) {
      var parent = this.parent;
      if (isShow && !this.parent.spinnerShown) {
        this.parent.dotNetRef.invokeMethodAsync('ShowSpinner');
        this.parent.spinnerShown = true;
      } else if (!isShow && this.parent.spinnerShown) {
        parent.dotNetRef.invokeMethodAsync("HideSpinner");
        parent.spinnerShown = false;
      }
    };
    ChartScroll.prototype.getTimelineLeft = function () {
      var tLeft;
      var ganttElement = this.parent.element;
      var resultantWidth = this.timelineVirtualTrack.offsetWidth - ganttElement.offsetWidth * 3;
      if (this.timelineScrollLeft == (this.parent.enableRTL ? -resultantWidth : resultantWidth)) {
        tLeft = this.timelineScrollLeft;
      } else {
        tLeft = this.parent.enableRTL ? this.timelineScrollLeft + ganttElement.offsetWidth : this.timelineScrollLeft > ganttElement.offsetWidth ? this.timelineScrollLeft - ganttElement.offsetWidth : 0;
      }
      return tLeft;
    };
    ChartScroll.prototype.updateSpinner = function (isHorizontal) {
      var chartScroll = this;
      var tLeft;
      this.showHideSpinner(true);
      window.clearTimeout(this.isScrolling);
      this.isScrolling = setTimeout(function () {
        if (isHorizontal) {
          tLeft = chartScroll.getTimelineLeft();
          chartScroll.parent.dotNetRef.invokeMethodAsync('VirtualRefresh', tLeft, chartScroll.parent.element.offsetWidth).then(function () {
            chartScroll.updateChartElementStyle();
          });
        }
        chartScroll.element.querySelector('.e-chart-rows-container').style.visibility = 'visible';
        chartScroll.showHideSpinner(false);
        window.clearTimeout(this.isScrolling);
      }, 1000);
    };
    ChartScroll.prototype.getTopPosition = function () {
      var virtualTable = this.element.querySelector('.e-virtualtable');
      var transforms = virtualTable.style.transform.split(',');
      var top = transforms.length > 1 ? transforms[1].trim().split(')')[0] : virtualTable.style.transform.substring(virtualTable.style.transform.lastIndexOf('(') + 1, virtualTable.style.transform.lastIndexOf(')'));
      return parseFloat(top);
    };
    ChartScroll.prototype.getContentHeight = function () {
      var scrollHeight = this.element.scrollHeight;
      var contentHeight = this.chartElement.offsetHeight;
      var height = contentHeight < scrollHeight ? contentHeight : scrollHeight;
      return height;
    };
    ChartScroll.prototype.updateTopPosition = function () {
      var content = this.parent.treeGrid.element.querySelector('.e-content');
      var scrollHeight = this.parent.chartScrollModule.getContentHeight();
      var contentScrollTop = content.scrollTop;
      var scrollTop;
      if (this.parent.chartScrollModule && this.parent.options.enableRowVirtualization) {
        var top_1 = this.parent.chartScrollModule.getTopPosition();
        scrollTop = contentScrollTop - top_1;
      } else {
        scrollTop = contentScrollTop;
      }
      if (!sf.base.isNullOrUndefined(this.holidayContainer)) {
        this.holidayContainer.style.height = scrollHeight + "px";
        this.holidayContainer.style.top = scrollTop + "px";
      }
    };
    ChartScroll.prototype.updateScrollTopPosition = function () {
      var treegridContentElement = this.parent.treeGrid.element.querySelector('.e-content');
      if (!sf.base.isNullOrUndefined(treegridContentElement) && this.element.scrollTop != treegridContentElement.scrollTop) {
        this.element.scrollTop = treegridContentElement.scrollTop;
      }
    };
    ChartScroll.prototype.onScroll = function () {
      var parent = this.parent;
      parent.scrollbarUpdate = true;
      if (this.element.scrollLeft !== this.parent.chartPreviousScroll.left) {
        if (!sf.base.isNullOrUndefined(this.parent.taskbarEditModule)) {
          this.parent.taskbarEditModule.LongPress = false;
        }
      }
      if (this.element.scrollTop !== parent.chartPreviousScroll.top && this.parent.options.enableRowVirtualization) {
        if (this.element.scrollTop - parent.chartPreviousScroll.top > 40) {
          this.updateSpinner(false);
        } else if (parent.chartPreviousScroll.top - this.element.scrollTop > 40) {
          this.updateSpinner(false);
        }
      }
      if (this.element.scrollLeft !== this.parent.chartPreviousScroll.left) {
        this.timelineHeaderElement.scrollLeft = this.element.scrollLeft;
        if (parent.options.enableTimelineVirtualization) {
          var tempPreviousScrollLeft = this.parent.chartPreviousScroll.left;
          var tempScrollLeft = this.element.scrollLeft;
          if (!this.parent.enableRTL && (this.element.scrollLeft - this.parent.chartPreviousScroll.left > 50 || this.parent.chartPreviousScroll.left - this.element.scrollLeft > 50)) {
            this.appendDummyTable();
            this.updateSpinner(true);
          } else if (this.parent.enableRTL && (Math.abs(tempScrollLeft) - Math.abs(tempPreviousScrollLeft) > 50 || Math.abs(tempPreviousScrollLeft) - Math.abs(tempScrollLeft) > 50)) {
            this.appendDummyTable();
            this.updateSpinner(true);
          } else {
            this.updateVirtualContent();
          }
        }
        this.parent.chartPreviousScroll.left = this.element.scrollLeft;
      }
      if (this.element.scrollTop !== this.parent.chartPreviousScroll.top) {
        if (!this.parent.isFromTreeGrid) {
          this.parent.treeGridModule.updateScrollTop(this.element.scrollTop);
        }
        this.parent.chartPreviousScroll.top = this.element.scrollTop;
        this.updateTopPosition();
        this.parent.isFromTreeGrid = false;
      }
    };
    ChartScroll.prototype.updateContent = function () {
      var chartScroll = this;
      this.timelineScrollLeft = this.timelineHeaderElement.scrollLeft;
      var ganttElement = this.parent.element;
      var currentCount = Math.round(this.timelineScrollLeft / (ganttElement.offsetWidth * 2));
      if (this.previousCount != currentCount) {
        this.calculateScrollLeft();
        var tLeft = this.getTimelineLeft();
        chartScroll.parent.dotNetRef.invokeMethodAsync('VirtualRefresh', tLeft, ganttElement.offsetWidth).then(function () {
          chartScroll.updateChartElementStyle();
        });
      }
      this.previousCount = currentCount;
    };
    ChartScroll.prototype.updateVirtualContent = function () {
      this.timelineScrollLeft = this.timelineHeaderElement.scrollLeft;
      var ganttElement = this.parent.element;
      var currentCount = Math.round(this.timelineScrollLeft / ganttElement.offsetWidth);
      if (this.previousCount != currentCount) {
        this.appendDummyTable();
        this.timelineScrollLeft -= ganttElement.offsetWidth;
        this.updateSpinner(true);
      }
      this.previousCount = currentCount;
    };
    ChartScroll.prototype.updateChartElementStyle = function () {
      var tLeft = this.getTimelineLeft();
      var ganttElement = this.parent.element;
      var contentWidth = ganttElement.offsetWidth * 3;
      if (this.timelineVirtualTrack.offsetWidth > contentWidth) {
        var chartVirtualTableY = new DOMMatrixReadOnly(this.chartVirtualTable.style.transform).m42;
        this.chartVirtualTable.style.transform = 'translate(' + tLeft + 'px' + ',' + chartVirtualTableY + 'px)';
        var chartTableWidth = this.parent.enableRTL ? contentWidth + Math.abs(tLeft) : contentWidth + tLeft;
        var chartTableLeft = this.parent.enableRTL ? tLeft : -tLeft;
        if (!sf.base.isNullOrUndefined(this.chartTaskTable)) {
          this.chartTaskTable.style.setProperty(this.parent.enableRTL ? "right" : "left", chartTableLeft + 'px');
          this.chartTaskTable.style.width = chartTableWidth + 'px';
        }
        if (!sf.base.isNullOrUndefined(this.dependencyViewContainer)) {
          this.dependencyViewContainer.style.left = -tLeft + 'px';
        }
      } else if (this.timelineVirtualTrack.offsetWidth < contentWidth && !sf.base.isNullOrUndefined(this.chartTaskTable)) {
        this.chartTaskTable.style.width = this.timelineVirtualTrack.offsetWidth + 'px';
      }
    };
    ChartScroll.prototype.calculateScrollLeft = function () {
      var ganttElement = this.parent.element;
      var contentWidth = ganttElement.offsetWidth * 3;
      var maxLeft = this.timelineVirtualTrack.offsetWidth > contentWidth ? this.timelineVirtualTrack.offsetWidth - contentWidth : contentWidth;
      var tempScrollLeft = Math.abs(this.timelineScrollLeft);
      if (this.timelineScrollLeft >= maxLeft) {
        this.timelineScrollLeft = maxLeft;
      } else if (tempScrollLeft >= maxLeft && this.parent.enableRTL) {
        this.timelineScrollLeft = -maxLeft;
      } else if (this.element.scrollLeft < this.parent.chartPreviousScroll.left && !this.parent.enableRTL) {
        if (this.timelineScrollLeft <= ganttElement.offsetWidth) {
          this.timelineScrollLeft = 0;
        }
      } else if (this.timelineScrollLeft < 0 && !this.parent.enableRTL) {
        this.timelineScrollLeft = 0;
      }
    };
    ChartScroll.prototype.appendDummyTable = function () {
      this.timelineScrollLeft = this.timelineHeaderElement.scrollLeft;
      var trElement = this.timelineHeaderElement.querySelectorAll('.e-virtualtable');
      this.element.querySelector('.e-chart-rows-container').style.visibility = 'hidden';
      this.calculateScrollLeft();
      var tLeft = this.getTimelineLeft();
      for (var i = 0; i < trElement.length; i++) {
        var row = trElement[i];
        var rowTranslateY = new DOMMatrixReadOnly(row.style.transform).m42;
        row.style.transform = 'translate(' + tLeft + 'px' + ',' + rowTranslateY + 'px)';
      }
    };
    ChartScroll.prototype.mouseDownHandler = function (e) {
      var targetMouseDown = e.target;
      var emptyRow = false;
      var chartElement = this.parent.getParentElement(targetMouseDown, 'e-gantt-chart');
      var chartRow = this.parent.getParentElement(targetMouseDown, 'e-chart-row');
      if (chartRow != null) {
        emptyRow = chartRow.querySelector('.e-chart-empty-row') ? true : false;
      }
      if (chartElement != null) {
        var target = null;
        var cellUid = null;
        if (this.parent.getParentElement(targetMouseDown, 'e-timeline-header-container')) {
          target = "Header";
        } else if (this.parent.getParentElement(targetMouseDown, 'e-content')) {
          if (!sf.base.isNullOrUndefined(e.target.classList) && (e.target.classList.contains('e-connector-line') || e.target.classList.contains('e-rg-rangdiv'))) {
            return;
          }
          target = "Content";
          cellUid = this.parent.getParentElement(targetMouseDown, 'e-chart-row-cell') ? this.parent.getParentElement(e.target, 'e-chart-row-cell').getAttribute('data-uid') : null;
        }
        if (target == "Header" || target == "Content") {
          this.parent.dotNetRef.invokeMethodAsync("ChartMouseDownHandler", target, cellUid, emptyRow);
        }
      }
    };
    ChartScroll.prototype.setScrollLeft = function (scrollLeft, leftSign) {
      scrollLeft = leftSign == -1 && this.parent.enableRTL ? -scrollLeft : scrollLeft;
      this.element.scrollLeft = scrollLeft;
      this.timelineHeaderElement.scrollLeft = this.element.scrollLeft;
      this.parent.chartPreviousScroll.left = this.element.scrollLeft;
    };
    ChartScroll.prototype.setScrollTop = function (scrollTop) {
      this.element.scrollTop = scrollTop;
      this.parent.treeGrid.element.querySelector('.e-content').scrollTop = scrollTop;
    };
    ChartScroll.prototype.ChartHeight = function (element, rootElement) {
      this.toolbarElement = element.querySelector('#' + element.id + '_Gantt_Toolbar');
      this.viewPortHeight = this.parent.height - this.parent.toolbarHeight - this.timelineHeaderElement.offsetHeight;
      rootElement.style.height = 'calc(100% - ' + this.timelineHeaderElement.offsetHeight + 'px)';
    };
    ChartScroll.prototype.destroy = function (ganttParent) {
      this.removeEventListeners(ganttParent);
    };
    return ChartScroll;
  }();
  var TreeGrid = /** @class */function () {
    /**
    * Constructor for the Grid scrolling.
    * @hidden
    */
    function TreeGrid(ganttParent, content) {
      this.parent = ganttParent;
      this.content = content;
      this.treegridPane = this.parent.element.querySelector('.e-grid');
      this.addEventListeners();
    }
    TreeGrid.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.content, 'scroll', this.scrollHandler, this);
      sf.base.EventHandler.add(this.treegridPane, sf.base.Browser.touchStartEvent, this.treeMouseDownHandler, this);
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
      sf.base.EventHandler.add(window, 'resize', this.windowResize, this);
    };
    TreeGrid.prototype.removeEventListeners = function (ganttParent) {
      var content = ganttParent.element.querySelector('.e-gridcontent');
      sf.base.EventHandler.remove(this.treegridPane, sf.base.Browser.touchStartEvent, this.treeMouseDownHandler);
      sf.base.EventHandler.remove(content, 'scroll', this.scrollHandler);
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
      sf.base.EventHandler.remove(window, 'resize', this.windowResize);
    };
    TreeGrid.prototype.scrollHandler = function (e) {
      if (this.content.scrollTop !== this.parent.treegridPreviousScroll.top) {
        this.parent.chartScrollModule.gridScrollHandler(this.content.scrollTop);
      }
      this.parent.treegridPreviousScroll.top = this.content.scrollTop;
    };
    TreeGrid.prototype.treeMouseDownHandler = function (e) {
      var gridElement = this.parent.getParentElement(e.target, 'e-grid');
      if (gridElement != null) {
        var target = null;
        var cellUid = null;
        if (this.parent.getParentElement(e.target, 'e-gridcontent')) {
          target = "GridContent";
          cellUid = this.parent.getParentElement(e.target, 'e-row') ? this.parent.getParentElement(e.target, 'e-row').getAttribute('data-uid') : null;
        } else if (this.parent.getParentElement(e.target, 'e-headercontent')) {
          target = "Header";
          var gridHeader = true;
        }
        if (target == "Header" || target == "GridContent") {
          this.parent.dotNetRef.invokeMethodAsync("TreeMouseDownHandler", target, cellUid, gridHeader);
        }
      }
    };
    /**
     * Method trigger while user perform window resize.
     *
     * @returns {void} .
     * @private
     */
    TreeGrid.prototype.windowResize = function () {
      if (sf.base.Browser.isDevice) {
        this.parent.dotNetRef.invokeMethodAsync('WindowResize');
      }
      if (this.parent.options.enableTimelineVirtualization) {
        var timelineElement = this.parent.chartScrollModule.timelineHeaderElement;
        if (timelineElement) {
          timelineElement.style.width = this.parent.chartScrollModule.element.offsetWidth - this.parent.scrollWidth + 'px';
        }
        this.parent.chartScrollModule.updateContent();
      }
    };
    TreeGrid.prototype.updateScrollTop = function (top) {
      this.content.scrollTop = top;
      this.parent.treegridPreviousScroll.top = this.content.scrollTop;
    };
    TreeGrid.prototype.destroy = function (ganttParent) {
      this.removeEventListeners(ganttParent);
    };
    return TreeGrid;
  }();

  /**
   * CSS Constants
   */
  /** @hidden */

  // Timeline-Class
  var timelineSingleHeaderOuterDiv = 'e-timeline-single-header-outer-div';
  var taskBarMainContainer = 'e-taskbar-main-container';
  var taskBarLeftResizer = 'e-taskbar-left-resizer';
  var taskBarRightResizer = 'e-taskbar-right-resizer';
  var childProgressResizer = 'e-child-progress-resizer';
  var leftResizeGripper = 'e-left-resize-gripper';
  var rightResizeGripper = 'e-right-resize-gripper';
  var progressResizeGripper = 'e-progress-resize-gripper';
  var chartBodyContainer = 'e-chart-root-container';
  var chartRow = 'e-chart-row';
  var leftLabelContainer = 'e-left-label-container';
  var rightLabelContainer = 'e-right-label-container';
  var traceChildProgressBar = 'e-gantt-child-progressbar';
  var traceChildTaskBar = 'e-gantt-child-taskbar';
  var traceParentTaskBar = 'e-gantt-parent-taskbar';
  var traceParentProgressBar = 'e-gantt-parent-progressbar';
  var parentMilestone = 'e-gantt-parent-milestone';
  var traceMilestone = 'e-gantt-milestone';
  var Active = 'e-active-container';
  var LeftLabel = 'e-left-label-inner-div';
  var RightLabel = 'e-right-label-inner-div';
  var connectorPointLeft = 'e-connectorpoint-left';
  var connectorPointRight = 'e-connectorpoint-right';
  var connectorPointLeftHover = 'e-connectorpoint-left-hover';
  var connectorPointRightHover = 'e-connectorpoint-right-hover';
  var falseLine = 'e-gantt-false-line';
  var rightConnectorPointOuterDiv = 'e-right-connectorpoint-outer-div';
  var leftConnectorPointOuterDiv = 'e-left-connectorpoint-outer-div';
  var connectorPointAllowBlock = 'e-connectorpoint-allow-block';
  var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var TaskbarEdit = /** @class */function () {
    /**
    * Constructor for the taskbar editing
    * @hidden
    */
    function TaskbarEdit(ganttParent) {
      this.elementOffsetLeft = 0;
      this.elementOffsetTop = 0;
      this.elementOffsetWidth = 0;
      this.elementOffsetHeight = 0;
      this.restrictTaskbarEdit = false;
      this.restrictConnectorLineEdit = false;
      this.dblClick = 0;
      this.parent = ganttParent;
      this.initPublicProp();
      this.ganttChartTableBody = this.parent.element.querySelector("#" + this.parent.element.id + "_chartContentBody");
      this.chartPane = this.parent.element.querySelector(".e-gantt-chart-pane");
      this.chartBodyContainer = this.parent.element.querySelector("." + chartBodyContainer);
      this.addEventListeners();
    }
    TaskbarEdit.prototype.initPublicProp = function () {
      this.taskBarEditElement = null;
      this.taskBarEditRecord = null;
      this.taskBarEditAction = null;
      this.dragMouseLeave = false;
      this.isMouseDragging = false;
      this.isTaskbarHold = false;
      this.taskbarTouchEditing = false;
      this.connectorPointWidth = null;
      this.connectorSecondAction = null;
      this.toPredecessorText = null;
      this.highlightedSecondElement = null;
      this.falseLine = null;
    };
    TaskbarEdit.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseDown, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchCancelEvent, this.ganttMouseLeave, this);
      sf.base.EventHandler.add(document, sf.base.Browser.touchEndEvent, this.ganttChartMouseUp, this);
      sf.base.EventHandler.add(this.chartBodyContainer, 'click', this.click, this);
    };
    TaskbarEdit.prototype.removeEventListeners = function (ganttParent) {
      var chartPane = ganttParent.element.querySelector('.e-gantt-chart-pane');
      var chartBodyContainer$$1 = ganttParent.element.querySelector('.e-chart-root-container');
      sf.base.EventHandler.remove(chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseDown);
      sf.base.EventHandler.remove(chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove);
      sf.base.EventHandler.remove(chartPane, sf.base.Browser.touchCancelEvent, this.ganttMouseLeave);
      sf.base.EventHandler.remove(document, sf.base.Browser.touchEndEvent, this.ganttChartMouseUp);
      sf.base.EventHandler.remove(chartBodyContainer$$1, 'click', this.click);
    };
    TaskbarEdit.prototype.checkPointerType = function (e) {
      return e.type.indexOf('pointer') !== -1 && sf.base.Browser.info.name === 'safari' && parseInt(sf.base.Browser.info.version) > 12;
    };
    TaskbarEdit.prototype.isTaskbarDragAndDrop = function (element) {
      return !sf.base.isNullOrUndefined(element.querySelector('.e-gantt-taskbar-draganddrop'));
    };
    TaskbarEdit.prototype.ganttMouseDown = function (e) {
      this.taskbarCanDrag = false;
      var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
      this.event = this.getCoordinate(e);
      if (this.parent.enableRTL) {
        this.mouseDownX = Math.abs(e.pageX - (containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left)));
      } else {
        this.mouseDownX = this.event.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
      }
      var taskbar = e.target;
      var dropSymbol = taskbar.classList.contains('e-chart-row-cell');
      var targetElement = this.getElementByPosition(e);
      var chartRowCell = this.parent.getParentElement(targetElement, 'e-chart-row-cell');
      var isTaskbarContains = null;
      if (!sf.base.isNullOrUndefined(chartRowCell)) {
        isTaskbarContains = chartRowCell.querySelector('.e-taskbar-main-container');
      }
      this.taskBarRow = this.parent.getParentElement(targetElement, chartRow);
      if (!sf.base.isNullOrUndefined(this.taskBarRow)) {
        this.parent.options.allowTaskbarDragAndDrop = this.isTaskbarDragAndDrop(this.parent.element);
      }
      this.updateTaskBarEditElement(e);
      if (!this.taskBarEditAction && isTaskbarContains == null && this.parent.options.allowSchedulingOnDrag) {
        this.chartEmptyRowElement = sf.base.createElement('div', {
          className: 'e-chart-empty-row'
        });
        if (!sf.base.isNullOrUndefined(this.taskBarRow)) {
          this.taskBarRow.appendChild(this.chartEmptyRowElement);
          this.emptyRow = this.taskBarRow.querySelector("." + "e-chart-empty-row");
        }
        if (this.emptyRow) {
          var row = document.querySelectorAll(".e-row");
          this.dataGuid = this.taskBarRow.getAttribute('data-rowindex');
          var targetRow = row[this.dataGuid];
          var treegridExpandIcon = targetRow.querySelector(".e-treegridexpand");
          this.parentRow = treegridExpandIcon ? true : false;
          if (!this.parentRow) {
            this.taskBarRow.style.position = "relative";
            this.taskBarRow.style.cursor = "crosshair";
            this.emptyRow.style.left = 0 + 'px';
            this.emptyRow.style.backgroundColor = "transparent";
            this.emptyRow.style.top = (taskbar.offsetHeight - (Math.floor(taskbar.offsetHeight * 0.62) - 2)) / 2 - 1 + 'px';
            this.emptyRow.style.height = Math.floor(taskbar.offsetHeight * 0.62) + 'px';
            this.parent.dotNetRef.invokeMethodAsync('ChartRowMouseDownHandler', this.dataGuid);
            this.isDown = true;
          } else {
            this.taskBarRow.style.cursor = "no-drop";
          }
        }
        this.longPress(true);
      } else if (!this.taskBarEditAction && this.taskBarRow && dropSymbol && this.parent.options.allowSchedulingOnDrag) {
        this.taskBarRow.style.cursor = "no-drop";
      }
      var tempelement = this.parent.getParentElement(targetElement, taskBarMainContainer);
      if (!sf.base.isNullOrUndefined(tempelement) && !sf.base.isNullOrUndefined(this.taskbarCurrentEditElement) && tempelement == this.taskbarCurrentEditElement) {
        this.taskbarCanDrag = true;
        if (this.checkPointerType(e)) {
          e.stopPropagation();
          var ScrollContainer = this.parent.element.querySelector('.e-chart-scroll-container');
          ScrollContainer.style.overflow = "hidden";
        }
      }
      this.dblClick++;
      if (this.dblClick >= 2) {
        this.dblClick = 1;
      }
    };
    TaskbarEdit.prototype.click = function (e) {
      var targetElement = this.getElementByPosition(e);
      this.taskbarCurrentEditElement = this.parent.getParentElement(targetElement, taskBarMainContainer);
    };
    TaskbarEdit.prototype.ganttMouseLeave = function (e) {
      this.dragMouseLeave = true;
    };
    TaskbarEdit.prototype.ganttChartMouseUp = function (e) {
      var _this = this;
      this.isTaskbarHold = false;
      if (this.taskBarRow) {
        this.isDown = false;
        this.taskBarRow.style.cursor = "";
      }
      var dataRowIndex = -1;
      if (this.parent.options.allowTaskbarDragAndDrop && this.parent.options.enableRowVirtualization) {
        var element = document.elementFromPoint(e.clientX, e.clientY);
        var clientX = element.getBoundingClientRect().x - 5; // The value of 5 is used to get the element outbound value.
        var targetElement = document.elementFromPoint(clientX, e.clientY);
        var data = this.parent.getParentElement(targetElement, 'e-chart-row');
        dataRowIndex = !sf.base.isNullOrUndefined(data) ? Number(data.getAttribute('data-rowindex')) : dataRowIndex;
      }
      if (this.taskBarEditAction && this.isMouseDragging) {
        if (!this.dragMouseLeave) {
          this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', this.dataGuid, this.taskBarEditAction, this.taskBarEditRecord, dataRowIndex).then(function (task) {
            if (_this.taskBarEditRecord != null && task != null) {
              _this.taskBarEditRecord.left = task["left"];
              _this.taskBarEditRecord.width = task["width"];
              _this.taskBarEditRecord.progress = task["progress"];
              _this.taskBarEditRecord.progressWidth = task["progressWidth"];
            }
            _this.updateItemPosition();
          });
        } else {
          this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', null, null, null, dataRowIndex);
          this.taskBarEditRecord = this.previousItem;
          this.updateItemPosition();
        }
        if (this.checkPointerType(e)) {
          var ScrollContainer = this.parent.element.querySelector('.e-chart-scroll-container');
          ScrollContainer.style.overflow = "scroll auto";
        }
      } else if (this.taskBarEditElement && this.taskbarTouchEditing || this.taskBarEditAction) {
        this.parent.dotNetRef.invokeMethodAsync('UpdateResizedData', null, null, null, dataRowIndex);
        if (this.falseLine) {
          this.removeFalseLine(true);
        }
        this.initPublicProp();
      } else if (this.tappedPoint) {
        this.taskbarCurrentEditElement = null;
      } else if (!this.taskBarEditAction && this.emptyRow && !this.parentRow && this.parent.options.allowSchedulingOnDrag) {
        this.emptyRow.style.border = "none";
        if (!sf.base.isNullOrUndefined(this.chartEmptyRowElement)) {
          sf.base.remove(this.chartEmptyRowElement);
        }
        this.parent.dotNetRef.invokeMethodAsync('UpdateTaskbarResizedData', this.dataGuid);
        this.taskBarRow = null;
        this.emptyRow = null;
      }
      this.removeCloneElement();
      this.stopScrollTimer();
      this.longPress(false);
    };
    TaskbarEdit.prototype.updateItemPosition = function () {
      this.setItemPosition();
      if (this.falseLine) {
        this.removeFalseLine(true);
      }
      this.initPublicProp();
    };
    TaskbarEdit.prototype.createResizeElement = function () {
      var resizeElement = sf.base.createElement('div');
      resizeElement.classList.add('e-gantt-chart-resize-indicator');
      resizeElement.style.setProperty('width', this.taskBarEditElement.style.width);
      var position = this.parent.enableRTL ? "right" : "left";
      resizeElement.style.setProperty(position, this.taskBarEditElement.style.left);
      if (this.parent.options.enableTimelineVirtualization && this.parent.options.enableRowVirtualization) {
        var tleft = this.parent.chartScrollModule.getTimelineLeft();
        var resizeLeft = resizeElement.style.left;
        var left = resizeLeft.substring(0, resizeLeft.length - 2);
        resizeElement.style.left = parseInt(left) + (this.parent.enableRTL ? tleft : -tleft) + 'px';
      }
      var rootElement = this.parent.element.querySelector('.e-chart-rows-container');
      rootElement.appendChild(resizeElement);
    };
    TaskbarEdit.prototype.createTaskbarClone = function (element) {
      var check = this.parent.element.querySelector('.e-gantt-clone-taskbar');
      var cloneTaskbar = element.cloneNode(true);
      if (!check) {
        cloneTaskbar.classList.add('e-gantt-clone-taskbar');
        cloneTaskbar.style.setProperty("top", element.parentElement.offsetTop + 1 + 'px');
        if (this.taskBarEditAction === 'LeftResizing') {
          var leftResizer = cloneTaskbar.querySelector('.' + taskBarLeftResizer);
          leftResizer.classList.add(leftResizeGripper);
        }
        if (this.taskBarEditAction === 'RightResizing') {
          var rightResizer = cloneTaskbar.querySelector('.' + taskBarRightResizer);
          rightResizer.classList.add(rightResizeGripper);
        }
        if (this.taskBarEditAction === 'ProgressResizing') {
          var progressResizer = cloneTaskbar.querySelector('.' + childProgressResizer);
          progressResizer.classList.add(progressResizeGripper);
        }
        var connectorLeft = cloneTaskbar.querySelector('.' + leftConnectorPointOuterDiv);
        var connectorRight = cloneTaskbar.querySelector('.' + rightConnectorPointOuterDiv);
        if (!sf.base.isNullOrUndefined(connectorLeft) && !sf.base.isNullOrUndefined(connectorRight)) {
          connectorLeft.style.setProperty('visibility', 'hidden');
          connectorRight.style.setProperty('visibility', 'hidden');
        }
      }
      this.cloneTaskbarElement = cloneTaskbar;
      if (this.parent.options.allowTaskbarDragAndDrop) {
        this.cloneTaskbarElement.style.zIndex = '999';
      }
      this.cloneTaskbarElement.style.setProperty('opacity', '40%');
      this.taskBarEditElement = this.cloneTaskbarElement;
      if (!sf.base.isNullOrUndefined(cloneTaskbar)) {
        if (this.parent.options.enableRowVirtualization && this.parent.options.allowTaskbarDragAndDrop) {
          var currentElement = this.parent.element.querySelector(".e-chart-scroll-container");
          currentElement.appendChild(cloneTaskbar);
        } else {
          var currentElement_1 = element.parentElement;
          currentElement_1.appendChild(cloneTaskbar);
        }
      }
    };
    TaskbarEdit.prototype.removeCloneElement = function () {
      var resizeElement = this.parent.element.querySelector('.e-gantt-chart-resize-indicator');
      var cloneElement = this.parent.element.querySelector('.e-gantt-clone-taskbar');
      if (!sf.base.isNullOrUndefined(resizeElement)) {
        resizeElement.remove();
      }
      if (!sf.base.isNullOrUndefined(cloneElement)) {
        var taskbar = cloneElement.parentElement.querySelector('.' + taskBarMainContainer);
        taskbar.style.removeProperty('z-index');
        cloneElement.remove();
      }
    };
    TaskbarEdit.prototype.updateTaskBarEditElement = function (e) {
      var _this_1 = this;
      var target = this.getElementByPosition(e);
      var element = this.parent.getParentElement(target, taskBarMainContainer);
      this.taskBarEditElement = element;
      if (this.taskBarEditElement && !this.tappedPoint) {
        var cursor = element.style.cursor;
        if (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'click' || this.checkPointerType(e)) {
          this.dataGuid = this.taskBarEditElement.getAttribute('rowuniqueid');
          this.parent.dotNetRef.invokeMethodAsync('GetConnectorValues').then(function (width) {
            _this_1.connectorPointWidth = width;
          });
          this.taskBarEditAction = this.getTaskBarAction(e, cursor);
          if (this.parent.isTaskbarEditingEventMapped) {
            this.parent.dotNetRef.invokeMethodAsync('OnTaskbarEditing', this.dataGuid, this.taskBarEditAction).then(function (restrict) {
              _this_1.restrictTaskbarEdit = restrict;
            });
          }
          this.parent.dotNetRef.invokeMethodAsync('GetEditedRecord', this.dataGuid, this.taskBarEditAction).then(function (record) {
            _this_1.taskBarEditRecord = record;
            _this_1.updateMouseDownProperties(e);
          });
          this.isTaskbarHold = true;
        }
      } else if (this.taskBarEditElement && this.tappedPoint) {
        var toDataGuid = element.getAttribute('rowuniqueid');
        this.parent.dotNetRef.invokeMethodAsync("RenderConnectorLine", this.tappedPoint, this.dataGuid, toDataGuid);
        this.initPublicProp();
      }
    };
    TaskbarEdit.prototype.updateMouseDownProperties = function (event) {
      var e = this.getCoordinate(event);
      if (e.pageX || e.pageY) {
        var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
        if (this.parent.enableRTL) {
          this.mouseDownX = Math.abs(e.pageX - (containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left)));
        } else {
          this.mouseDownX = e.pageX - containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left);
        }
        this.mouseDownY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
      }
    };
    TaskbarEdit.prototype.getTaskBarAction = function (e, cursor) {
      var mouseDownElement = this.getElementByPosition(e);
      var data = this.taskBarEditRecord;
      var action = '';
      if (mouseDownElement.classList.contains(taskBarLeftResizer)) {
        action = 'LeftResizing';
      } else if (mouseDownElement.classList.contains(taskBarRightResizer)) {
        action = 'RightResizing';
      } else if (mouseDownElement.classList.contains(childProgressResizer) || sf.base.closest(mouseDownElement, '.' + childProgressResizer)) {
        action = 'ProgressResizing';
      } else if (mouseDownElement.classList.contains(connectorPointLeftHover)) {
        action = 'ConnectorPointLeftDrag';
        if (e.type === 'touchstart' || e.type === 'click' || this.checkPointerType(e)) this.tappedPoint = 'ConnectorPointLeftDrag';
      } else if (mouseDownElement.classList.contains(connectorPointRightHover)) {
        action = 'ConnectorPointRightDrag';
        if (e.type === 'touchstart' || e.type === 'click' || this.checkPointerType(e)) this.tappedPoint = 'ConnectorPointRightDrag';
      } else if (this.parent.options.taskMode === 'Auto' && (sf.base.closest(mouseDownElement, '.' + traceParentTaskBar) || sf.base.closest(mouseDownElement, '.' + parentMilestone)) && cursor != 'default') {
        action = 'ParentDrag';
      } else if (sf.base.closest(mouseDownElement, '.' + traceChildTaskBar) && cursor != 'default') {
        action = 'ChildDrag';
      } else if (sf.base.closest(mouseDownElement, '.' + traceMilestone) && cursor != 'default') {
        action = 'MilestoneDrag';
      }
      return action;
    };
    TaskbarEdit.prototype.getElementByPosition = function (event) {
      var e = this.getCoordinate(event);
      e.pageX = e.pageX != null ? e.pageX : 0;
      e.pageY = e.pageY != null ? e.pageY : 0;
      return document.elementFromPoint(e.pageX - window.pageXOffset, e.pageY - window.pageYOffset);
    };
    // Get XY coordinates for touch and non-touch device
    TaskbarEdit.prototype.getCoordinate = function (event) {
      var coordinates = {};
      if (event.type === "touchstart" || event.type === "touchmove" || event.type === "touchend" || event.type === "touchleave") {
        var e = event;
        coordinates.pageX = e.changedTouches[0].pageX;
        coordinates.pageY = e.changedTouches[0].pageY;
      } else {
        var e = event;
        coordinates.pageX = e.pageX;
        coordinates.pageY = e.pageY;
      }
      return coordinates;
    };
    TaskbarEdit.prototype.ganttMouseMove = function (event) {
      if (event.type === "touchmove" || event.type === "click" || this.checkPointerType(event)) {
        if (!this.taskbarCanDrag) {
          return;
        }
      }
      if (this.isDown && !this.taskBarEditAction && !this.parentRow && event.type == "mousemove" || this.LongPress && this.isDown) {
        var target = event.target;
        var scrollContainer = this.parent.getParentElement(target, 'e-chart-scroll-container');
        if (this.parent.chartPreviousScroll.left > 0 && scrollContainer.scrollWidth - this.chartBodyContainer.offsetWidth > this.parent.chartPreviousScroll.left) {
          event.preventDefault();
        }
        var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
        var e = this.getCoordinate(event);
        if (this.parent.enableRTL) {
          this.mouseMoveX = Math.abs(e.pageX - (containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left)));
        } else {
          this.mouseMoveX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        }
        if (this.emptyRow) {
          var tooltip = document.getElementById(this.parent.element.id + '_editingtooltip_content');
          if (!sf.base.isNullOrUndefined(tooltip)) {
            tooltip.style.left = this.event.pageX - 10 + "px";
            tooltip.style.top = this.event.pageY - 80 + 'px';
            var arrowEle = sf.base.select('.' + 'e-arrow-tip', tooltip);
            arrowEle.style.left = '2px';
          }
          if (this.mouseMoveX - this.mouseDownX > 2 || this.mouseDownX - this.mouseMoveX > 2) {
            if (this.mouseMoveX > this.mouseDownX) {
              this.taskBarWidth = this.mouseMoveX - this.mouseDownX;
              this.taskBarRight = this.mouseDownX + this.taskBarWidth;
              this.parent.dotNetRef.invokeMethodAsync('UpdateTaskbarResizingData', this.dataGuid, this.mouseDownX, this.taskBarRight);
            } else {
              this.taskBarWidth = this.mouseDownX - this.mouseMoveX;
              this.taskBarRight = this.mouseDownX - this.taskBarWidth;
              this.parent.dotNetRef.invokeMethodAsync('UpdateTaskbarResizingData', this.dataGuid, this.taskBarRight, this.mouseDownX);
            }
          }
          this.emptyRow.style.width = this.taskBarWidth + "px";
          if (this.parent.enableRTL) {
            this.emptyRow.style.left = this.mouseMoveX < this.mouseDownX ? scrollContainer.scrollWidth - this.mouseDownX + "px" : scrollContainer.scrollWidth - this.taskBarRight + "px";
          } else {
            this.emptyRow.style.left = this.mouseMoveX > this.mouseDownX ? this.mouseDownX + "px" : this.taskBarRight + "px";
          }
          this.emptyRow.style.backgroundColor = "";
          var mouseX = 0;
          if (this.parent.enableRTL) {
            mouseX = Math.abs(Math.abs(this.mouseMoveX) - Math.abs(this.parent.chartPreviousScroll.left) + containerPosition.left);
          } else {
            mouseX = this.mouseMoveX - this.parent.chartPreviousScroll.left + containerPosition.left;
          }
          if (mouseX + 20 > containerPosition.left + this.chartBodyContainer.offsetWidth) {
            this.timerCount = this.parent.chartPreviousScroll.left;
            this.startScrollTimer('right');
          } else if (mouseX + 40 > containerPosition.left + this.chartBodyContainer.offsetWidth && this.parent.enableRTL && this.parent.chartPreviousScroll.left == 0) {
            this.parent.chartPreviousScroll.left = -1;
            this.timerCount = this.parent.chartPreviousScroll.left;
            this.startScrollTimer('right');
          } else if (mouseX - 10 < containerPosition.left) {
            this.timerCount = this.parent.chartPreviousScroll.left;
            this.startScrollTimer('left');
          } else if (this.scrollTimer != null) {
            this.stopScrollTimer();
          }
        }
      }
      if (this.taskBarEditAction && this.taskBarEditRecord && this.isTaskbarHold) {
        var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
        var e = this.getCoordinate(event);
        if (this.parent.enableRTL) {
          this.mouseMoveX = Math.abs(e.pageX - (containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left)));
        } else {
          this.mouseMoveX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        }
        this.mouseMoveY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
        this.dragMouseLeave = false;
        this.isMouseDragCheck();
        if (this.isMouseDragging) {
          this.taskBarEditingAction(event, false);
          if (this.dblClick === 1 && this.taskBarEditAction !== 'ConnectorPointRightDrag' && this.taskBarEditAction !== 'ConnectorPointLeftDrag') {
            if (this.taskBarEditAction !== 'ProgressResizing') {
              this.createResizeElement();
            }
            this.taskBarEditElement.style.setProperty('z-index', '4');
            this.createTaskbarClone(this.taskBarEditElement);
            this.dblClick++;
          }
        }
      }
      var isTaskbar = sf.base.closest(event.target, '.e-taskbar-main-container');
      if (isTaskbar && isTaskbar.style.cursor != 'default') {
        if (this.parent.options.allowTaskbarEditing && this.taskBarEditAction !== 'ConnectorPointLeftDrag' && this.taskBarEditAction !== 'ConnectorPointRightDrag') {
          isTaskbar.style.cursor = 'move';
        } else {
          isTaskbar.style.cursor = 'auto';
        }
      }
    };
    TaskbarEdit.prototype.isMouseDragCheck = function () {
      if (!this.isMouseDragging && this.taskBarEditAction && (this.mouseDownX !== this.mouseMoveX && (this.mouseDownX + 3 < this.mouseMoveX || this.mouseDownX - 3 > this.mouseMoveX) || this.mouseDownY !== this.mouseMoveY && (this.mouseDownY + 3 < this.mouseMoveY || this.mouseDownY - 3 > this.mouseMoveY))) {
        this.isMouseDragging = true;
        var item = this.taskBarEditRecord;
        this.previousItem = __assign({}, item);
        this.taskBarEditElement.setAttribute('aria-grabbed', 'true');
      }
    };
    TaskbarEdit.prototype.updateMouseMoveProperties = function (event) {
      var containerPosition = this.parent.getOffsetRect(this.chartBodyContainer);
      var e = this.getCoordinate(event);
      var isConnectorLineEdit = this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag' ? true : false;
      var isTaskbarDrag = (this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'MilestoneDrag') && this.parent.options.allowTaskbarDragAndDrop ? true : false;
      if (e.pageX || e.pageY) {
        if (this.parent.enableRTL) {
          this.mouseMoveX = Math.abs(e.pageX - (containerPosition.left + Math.abs(this.parent.chartPreviousScroll.left)));
        } else {
          this.mouseMoveX = e.pageX - containerPosition.left + this.parent.chartPreviousScroll.left;
        }
        this.mouseMoveY = e.pageY - containerPosition.top + this.parent.chartPreviousScroll.top;
      }
      if (this.taskBarEditRecord.width > 3 && !(this.taskBarEditAction === 'ProgressResizing' && (this.taskBarEditRecord.progress === 0 || this.taskBarEditRecord.progress === 100)) || isConnectorLineEdit) {
        var mouseX = 0;
        if (this.parent.enableRTL) {
          mouseX = Math.abs(Math.abs(this.mouseMoveX) - Math.abs(this.parent.chartPreviousScroll.left) + containerPosition.left);
        } else {
          mouseX = this.mouseMoveX - this.parent.chartPreviousScroll.left + containerPosition.left;
        }
        var mouseY = this.mouseMoveY - this.parent.chartPreviousScroll.top + containerPosition.top;
        if (mouseX + 20 > containerPosition.left + this.chartBodyContainer.offsetWidth) {
          this.timerCount = this.parent.chartPreviousScroll.left;
          this.startScrollTimer('right');
        } else if (mouseX + 40 > containerPosition.left + this.chartBodyContainer.offsetWidth && this.parent.enableRTL && this.parent.chartPreviousScroll.left == 0) {
          this.parent.chartPreviousScroll.left = -1;
          this.timerCount = this.parent.chartPreviousScroll.left;
          this.startScrollTimer('right');
        } else if (mouseX - 10 < containerPosition.left) {
          this.timerCount = this.parent.chartPreviousScroll.left;
          this.startScrollTimer('left');
        } else if ((isConnectorLineEdit || isTaskbarDrag) && mouseY > containerPosition.top + this.chartBodyContainer.offsetHeight - 80) {
          this.timerCount = this.parent.chartPreviousScroll.top;
          this.startScrollTimer('bottom');
        } else if ((isConnectorLineEdit || isTaskbarDrag) && mouseY - 25 < containerPosition.top) {
          this.timerCount = this.parent.chartPreviousScroll.top;
          this.startScrollTimer('top');
        } else if (this.scrollTimer != null) {
          this.stopScrollTimer();
        }
      }
      event.preventDefault();
    };
    TaskbarEdit.prototype.longPress = function (rowLongPress) {
      var _this = this;
      if (rowLongPress) {
        _this.longPressTimer = window.setTimeout(function () {
          _this.LongPress = true;
          return;
        }, 1000);
      } else {
        _this.LongPress = false;
        window.clearTimeout(_this.longPressTimer);
      }
    };
    TaskbarEdit.prototype.startScrollTimer = function (direction) {
      var _this_1 = this;
      this.parent.chartScrollModule.previousCount = 0;
      this.stopScrollTimer();
      var leftSign = 0;
      var chartElement = this.parent.element.querySelector(".e-chart-root-container");
      this.scrollTimer = window.setInterval(function () {
        if (Math.sign(_this_1.timerCount) == -1) {
          leftSign = -1;
          _this_1.timerCount = Math.abs(_this_1.timerCount);
        }
        if (direction === 'right') {
          _this_1.timerCount = _this_1.timerCount + 1 >= _this_1.parent.totalTimelineWidth ? _this_1.parent.totalTimelineWidth : _this_1.timerCount + 1;
        } else if (direction === 'bottom' && !sf.base.isNullOrUndefined(chartElement)) {
          var height = _this_1.parent.options.enableRowVirtualization ? parseFloat(chartElement.querySelector(".e-virtualtrack").style.height) : parseFloat(chartElement.querySelector(".e-chart-rows-container").style.height);
          _this_1.timerCount = _this_1.timerCount + 1 >= height ? height : _this_1.timerCount + 1;
        } else {
          _this_1.timerCount = _this_1.timerCount - 1 < 0 ? 0 : _this_1.timerCount - 1;
        }
        if (direction === 'bottom' || direction === 'top') {
          _this_1.parent.chartScrollModule.setScrollTop(_this_1.timerCount);
        } else {
          _this_1.parent.chartScrollModule.setScrollLeft(_this_1.timerCount, leftSign);
          if (_this_1.parent.options.enableTimelineVirtualization) {
            _this_1.parent.chartScrollModule.updateContent();
          }
        }
        if (_this_1.taskBarEditAction === 'ConnectorPointLeftDrag' || _this_1.taskBarEditAction === 'ConnectorPointRightDrag') {
          _this_1.drawFalseLine();
        }
      }, 0);
    };
    TaskbarEdit.prototype.stopScrollTimer = function () {
      window.clearInterval(this.scrollTimer);
      this.scrollTimer = null;
    };
    TaskbarEdit.prototype.taskBarEditingAction = function (e, isMouseClick) {
      // let args: ITaskbarEditedEventArgs = {} as ITaskbarEditedEventArgs;
      if (!this.restrictTaskbarEdit) this.updateMouseMoveProperties(e);
      if (this.taskBarEditAction === 'ProgressResizing' && !this.restrictTaskbarEdit) {
        this.performProgressResize(e);
      } else if (this.taskBarEditAction === 'LeftResizing' && !this.restrictTaskbarEdit) {
        this.enableLeftResizing(e);
      } else if ((this.taskBarEditAction === 'RightResizing' || this.taskBarEditAction === 'ParentResizing') && !this.restrictTaskbarEdit) {
        this.enableRightResizing(e);
      } else if ((this.taskBarEditAction === 'ParentDrag' || this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'MilestoneDrag') && !this.restrictTaskbarEdit) {
        this.enableDragging(e);
      } else if ((this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag') && (e.type != 'touchmove' || this.checkPointerType(e)) && !this.restrictConnectorLineEdit) {
        this.updateConnectorLineSecondProperties(e);
        this.triggerDependencyEvent(e);
        this.drawFalseLine();
      }
      if (!this.restrictTaskbarEdit) this.setItemPosition();
      if (this.taskBarEditAction !== 'ConnectorPointLeftDrag' && this.taskBarEditAction !== 'ConnectorPointRightDrag') {
        this.parent.dotNetRef.invokeMethodAsync('UpdateResizingData', this.dataGuid, this.taskBarEditAction, this.taskBarEditRecord);
      }
      this.taskbarTouchEditing = true;
      this.updateTooltip(e);
    };
    /**
     * To update tooltip position.
     *
     * @param {number} segmentIndex .
     * @returns {void} .
     * @private
     */
    TaskbarEdit.prototype.updateTooltip = function (e) {
      var tooltip = document.getElementById(this.parent.element.id + '_editingtooltip_content');
      if (!sf.base.isNullOrUndefined(tooltip)) {
        var item = this.taskBarEditRecord;
        var taskWidth = item.width;
        var progressWidth = item.progressWidth;
        var taskbarPosition = this.parent.getOffsetRect(this.taskBarEditElement);
        var mousePostion = this.parent.tooltipModule.getPointerPosition(e);
        var arrowEle = sf.base.select('.' + 'e-arrow-tip', tooltip);
        var tipWidthAdjust = arrowEle.offsetWidth / 2 + (tooltip.offsetWidth - tooltip.clientWidth);
        arrowEle.style.left = '2px';
        if (this.taskBarEditAction === 'ConnectorPointLeftDrag' || this.taskBarEditAction === 'ConnectorPointRightDrag') {
          return;
        } else {
          if (this.taskBarEditAction === 'LeftResizing') {
            tooltip.style.left = taskbarPosition.left - tipWidthAdjust + 'px';
          } else if (this.taskBarEditAction === 'RightResizing' || this.taskBarEditAction === 'ParentResizing') {
            tooltip.style.left = (this.parent.enableRTL ? taskbarPosition.left - taskWidth - tipWidthAdjust : taskbarPosition.left + taskWidth - tipWidthAdjust) + 'px';
          } else if (this.taskBarEditAction === 'ProgressResizing') {
            tooltip.style.left = (this.parent.enableRTL ? taskbarPosition.left - progressWidth - tipWidthAdjust : taskbarPosition.left + progressWidth - tipWidthAdjust) + 'px';
          } else {
            tooltip.style.left = mousePostion.x - tipWidthAdjust + 'px';
          }
          if (this.parent.options.allowTaskbarDragAndDrop) {
            tooltip.style.top = Math.abs(taskbarPosition.top - (tooltip.offsetHeight + 10)) + 'px';
          }
        }
      }
    };
    TaskbarEdit.prototype.setItemPosition = function () {
      var item = this.taskBarEditRecord;
      var position = this.parent.enableRTL ? "right" : "left";
      if (item == null || this.taskBarEditElement == null || sf.base.closest(this.taskBarEditElement, 'tr.' + chartRow) == null && !(this.parent.options.allowTaskbarDragAndDrop && this.parent.options.enableRowVirtualization)) {
        return;
      }
      var width = this.taskBarEditAction === 'MilestoneDrag' || item.isMilestone ? this.milestoneHeight : item.width;
      var rightResizer = width - 10;
      var connectorResizer = width - 2;
      var progressResizer = item.progress / 100 * item.width;
      /* tslint:disable-next-line */
      var taskBarMainContainer$$1 = !this.taskBarEditElement.classList.contains(taskBarMainContainer) ? this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'LeftResizing' ? this.taskBarEditElement : sf.base.closest(this.taskBarEditElement, 'tr.' + chartRow).querySelector('.' + taskBarMainContainer) : this.taskBarEditElement;
      var traceChildProgressBar$$1 = this.taskBarEditElement.querySelector('.' + traceChildProgressBar);
      var traceChildTaskBar$$1 = this.taskBarEditElement.querySelector('.' + traceChildTaskBar);
      var childProgressResizer$$1 = this.taskBarEditElement.querySelector('.' + childProgressResizer);
      var taskBarRightResizer$$1 = this.taskBarEditElement.querySelector('.' + taskBarRightResizer);
      var traceParentTaskBar$$1 = this.taskBarEditElement.querySelector('.' + traceParentTaskBar);
      var traceParentProgressBar$$1 = this.taskBarEditElement.querySelector('.' + traceParentProgressBar);
      var rightConnectorPointOuterDiv$$1 = this.taskBarEditElement.querySelector('.' + rightConnectorPointOuterDiv);
      if (this.parent.biggerMode) {
        rightResizer = width - 24;
        connectorResizer = width + 10;
      }
      var rootElement = this.parent.element.querySelector('.e-chart-rows-container');
      var resizeElement = rootElement.querySelector('.e-gantt-chart-resize-indicator');
      if (!sf.base.isNullOrUndefined(resizeElement) && (this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'ParentDrag' || this.taskBarEditAction === 'RightResizing' || this.taskBarEditAction === 'LeftResizing')) {
        resizeElement.style.width = width + 'px';
        resizeElement.style.setProperty(position, item.left + 'px');
        if (this.parent.options.enableTimelineVirtualization && this.parent.options.enableRowVirtualization) {
          var tleft = this.parent.chartScrollModule.getTimelineLeft();
          resizeElement.style.left = item.left + (this.parent.enableRTL ? tleft : -tleft) + 'px';
        }
      }
      if (taskBarMainContainer$$1.classList.contains("e-gantt-clone-taskbar") && this.taskBarEditAction !== 'ParentResizing' && this.taskBarEditAction !== 'ConnectorPointLeftDrag' && this.taskBarEditAction !== 'ConnectorPointRightDrag') {
        taskBarMainContainer$$1.style.width = width + 'px';
        taskBarMainContainer$$1.style.setProperty(position, item.left + 'px');
        if (this.parent.options.allowTaskbarDragAndDrop && (this.taskBarEditAction === 'ChildDrag' || this.taskBarEditAction === 'MilestoneDrag')) {
          taskBarMainContainer$$1.style.top = item.top + 'px';
        }
      }
      if (rightConnectorPointOuterDiv$$1) {
        rightConnectorPointOuterDiv$$1.style.setProperty(position, connectorResizer + 'px');
      }
      if (taskBarRightResizer$$1) {
        taskBarRightResizer$$1.style.setProperty(position, rightResizer + 'px');
      }
      if (this.taskBarEditAction === 'MilestoneDrag' || item.isMilestone) {
        taskBarMainContainer$$1.style.setProperty(position, item.left - width / 2 + 2 + 'px');
        if (!sf.base.isNullOrUndefined(resizeElement)) {
          resizeElement.style.setProperty("left", item.left - width / 2 + 'px');
        }
      } else if (this.taskBarEditAction === 'ProgressResizing') {
        traceChildTaskBar$$1.style.setProperty(position, item.left + item.progressWidth - 10 + 'px');
        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceChildProgressBar$$1.style.width = item.progressWidth + 'px';
          traceChildProgressBar$$1.style.borderBottomRightRadius = this.progressBorderRadius + 'px';
          traceChildProgressBar$$1.style.borderTopRightRadius = this.progressBorderRadius + 'px';
          childProgressResizer$$1.style.setProperty(position, item.progressWidth - 8 + 'px');
        }
      } else if (taskBarMainContainer$$1.classList.contains("e-gantt-clone-taskbar") && this.taskBarEditAction === 'RightResizing' && !sf.base.isNullOrUndefined(traceChildTaskBar$$1)) {
        traceChildTaskBar$$1.style.width = width + 'px';
        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceChildProgressBar$$1.style.width = progressResizer + 'px';
          taskBarRightResizer$$1.style.setProperty(position, rightResizer + 'px');
          childProgressResizer$$1.style.setProperty(position, progressResizer - 8 + 'px');
        }
      } else if (this.taskBarEditAction === 'ParentDrag') {
        if (!sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          traceParentProgressBar$$1.style.width = item.progressWidth + 'px';
        }
      } else {
        if (taskBarMainContainer$$1.classList.contains("e-gantt-clone-taskbar") && !sf.base.isNullOrUndefined(traceChildTaskBar$$1)) {
          traceChildTaskBar$$1.style.width = width + 'px';
        }
        if (taskBarMainContainer$$1.classList.contains("e-gantt-clone-taskbar") && !sf.base.isNullOrUndefined(traceChildProgressBar$$1)) {
          taskBarRightResizer$$1.style.setProperty(position, rightResizer + 'px');
          traceChildProgressBar$$1.style.width = progressResizer + 'px';
          childProgressResizer$$1.style.setProperty(position, progressResizer - 8 + 'px');
        }
      }
    };
    /**
     * To update left and width while perform taskbar left resize operation.
     * @return {void}
     * @private
     */
    TaskbarEdit.prototype.enableLeftResizing = function (e) {
      var item = this.taskBarEditRecord;
      var diffrenceWidth = 0;
      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseDownX - this.mouseMoveX;
          if (item.left > 0) {
            item.left = this.previousItem.left - diffrenceWidth;
            item.width = this.previousItem.width + diffrenceWidth;
          }
        } else {
          if (this.mouseMoveX > item.left + item.width) {
            diffrenceWidth = this.mouseDownX - this.mouseMoveX;
            item.left = this.previousItem.left - diffrenceWidth;
            item.width = 3;
          }
        }
      } else {
        if (this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseMoveX - this.mouseDownX;
          if (item.left < item.left + item.width && this.previousItem.left + diffrenceWidth <= this.previousItem.left + this.previousItem.width) {
            item.left = this.previousItem.left + diffrenceWidth;
            item.width = this.previousItem.width - diffrenceWidth;
          }
        } else {
          diffrenceWidth = this.mouseMoveX - this.mouseDownX;
          item.left = this.previousItem.left + diffrenceWidth;
          item.width = 3;
        }
      }
      this.updateEditPosition(e, item);
      item.left = this.previousItem.left + this.previousItem.width - item.width;
    };
    TaskbarEdit.prototype.enableRightResizing = function (e) {
      var item = this.taskBarEditRecord;
      var differenceWidth = 0;
      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX > item.left && this.mouseDownX - this.mouseMoveX > 3) {
          differenceWidth = this.mouseDownX - this.mouseMoveX;
          item.width = this.previousItem.width - differenceWidth;
        } else {
          if (this.mouseMoveX < item.left) {
            item.width = 3;
          }
        }
      } else {
        if (this.mouseMoveX > item.left) {
          differenceWidth = this.mouseMoveX - this.mouseDownX;
          item.width = this.previousItem.width + differenceWidth;
        }
      }
      this.updateEditPosition(e, item);
    };
    TaskbarEdit.prototype.enableDragging = function (e) {
      var item = this.taskBarEditRecord;
      var differenceWidth = 0;
      if (this.mouseDownX > this.mouseMoveX) {
        differenceWidth = this.mouseDownX - this.mouseMoveX;
        if (differenceWidth > 0) {
          item.left = this.previousItem.left - differenceWidth;
        }
      } else {
        differenceWidth = this.mouseMoveX - this.mouseDownX;
        item.left = this.previousItem.left + differenceWidth;
      }
      var chartWidth = this.chartBodyContainer.querySelector(".e-task-table");
      var left = item.left < 0 ? 0 : item.left + item.width >= chartWidth.offsetWidth ? chartWidth.offsetWidth - item.width : item.left;
      if (this.parent.options.allowTaskbarDragAndDrop) {
        item.top = this.previousItem.top + Math.abs(15 - this.mouseMoveY);
      }
      item.left = left;
    };
    TaskbarEdit.prototype.performProgressResize = function (e) {
      var item = this.taskBarEditRecord;
      var diffrenceWidth = 0;
      if (this.mouseDownX > this.mouseMoveX) {
        if (this.mouseMoveX > item.left && this.mouseMoveX < item.left + item.width && item.left > 0) {
          diffrenceWidth = this.mouseMoveX - item.left;
          item.progressWidth = diffrenceWidth;
        } else {
          if (this.mouseMoveX >= item.left + item.width) {
            item.progressWidth = item.width;
          } else {
            item.progressWidth = 0;
          }
        }
      } else {
        if (this.mouseMoveX > item.left && this.mouseMoveX < item.left + item.width) {
          diffrenceWidth = this.mouseMoveX - item.left;
          item.progressWidth = diffrenceWidth;
        } else {
          if (this.mouseMoveX <= item.left) {
            item.progressWidth = 0;
          } else {
            item.progressWidth = item.width;
          }
        }
      }
      var widthValue = item.progressWidth > item.width ? item.width : item.progressWidth;
      widthValue = item.progressWidth < 0 ? 0 : item.progressWidth;
      item.progressWidth = widthValue;
      var diff = item.width - item.progressWidth;
      if (diff <= 4) {
        this.progressBorderRadius = 4 - diff;
      } else {
        this.progressBorderRadius = 0;
      }
    };
    TaskbarEdit.prototype.updateEditPosition = function (e, item) {
      this.updateIsMilestone(item);
    };
    TaskbarEdit.prototype.updateIsMilestone = function (item) {
      if (item.width <= 3) {
        item.width = 3;
        item.isMilestone = true;
      } else {
        item.isMilestone = false;
      }
    };
    TaskbarEdit.prototype.updateConnectorLineSecondProperties = function (e) {
      var target = this.getElementByPosition(e);
      var element = this.parent.getParentElement(target, taskBarMainContainer);
      this.connectorSecondAction = null;
      var scrollTop = 0;
      if (this.parent.getParentElement(target, connectorPointLeft)) {
        this.connectorSecondAction = 'ConnectorPointLeftDrag';
        this.toPredecessorText = 'Start';
      } else if (this.parent.getParentElement(target, connectorPointRight)) {
        this.connectorSecondAction = 'ConnectorPointRightDrag';
        this.toPredecessorText = 'Finish';
      } else {
        this.connectorSecondAction = null;
        this.toPredecessorText = null;
      }
      if (this.taskBarEditElement !== element && this.taskBarEditElement !== this.highlightedSecondElement) {
        if (this.parent.options.enableRowVirtualization) {
          scrollTop = this.getTopPosition(this.parent.element);
        }
        if (this.parent.options.enableRowVirtualization && this.elementOffsetLeft == 0 || !this.parent.options.enableRowVirtualization) {
          this.elementOffsetLeft = this.taskBarEditElement.offsetLeft;
          this.elementOffsetTop = this.taskBarEditElement.offsetTop + scrollTop;
          this.elementOffsetWidth = this.taskBarEditElement.offsetWidth;
          this.elementOffsetHeight = this.taskBarEditElement.offsetHeight;
          this.showHideTaskBarEditingElements(element, this.highlightedSecondElement);
        }
      }
      if (sf.base.isNullOrUndefined(this.connectorSecondAction) && !sf.base.isNullOrUndefined(this.connectorSecondElement)) {
        this.connectorSecondElement.querySelector('.' + connectorPointLeft).classList.remove(connectorPointAllowBlock);
        this.connectorSecondElement.querySelector('.' + connectorPointRight).classList.remove(connectorPointAllowBlock);
      }
      this.connectorSecondElement = this.connectorSecondAction ? element : null;
      this.toDataGuid = sf.base.isNullOrUndefined(this.connectorSecondElement) ? null : this.connectorSecondElement.getAttribute('rowuniqueid');
    };
    TaskbarEdit.prototype.getTopPosition = function (element) {
      var virtualTable = element.querySelector('.e-virtualtable');
      var translates = virtualTable.style.transform.split(',');
      var top;
      if (translates.length > 1) {
        top = translates[1].trim().split(')')[0];
      } else {
        var transformString = virtualTable.style.transform;
        top = transformString.substring(transformString.lastIndexOf("(") + 1, transformString.lastIndexOf(")"));
      }
      return parseFloat(top);
    };
    TaskbarEdit.prototype.showHideTaskBarEditingElements = function (element, secondElement) {
      secondElement = secondElement ? secondElement : this.taskBarEditElement;
      if (secondElement && element !== secondElement) {
        if (secondElement.querySelector('.' + taskBarLeftResizer)) {
          secondElement.querySelector('.' + taskBarLeftResizer).classList.remove(leftResizeGripper);
          secondElement.querySelector('.' + taskBarRightResizer).classList.remove(rightResizeGripper);
          if (secondElement.querySelector('.' + childProgressResizer)) {
            secondElement.querySelector('.' + childProgressResizer).classList.remove(progressResizeGripper);
          }
        }
        if (secondElement.querySelector('.' + connectorPointLeft) || secondElement.parentElement.querySelector('.' + connectorPointLeft)) {
          var connectorElement = !sf.base.isNullOrUndefined(secondElement.querySelector('.' + connectorPointLeft)) ? secondElement : secondElement.parentElement;
          connectorElement.querySelector('.' + connectorPointLeft).classList.remove(connectorPointLeftHover);
          connectorElement.querySelector('.' + connectorPointRight).classList.remove(connectorPointRightHover);
        }
      }
    };
    TaskbarEdit.prototype.triggerDependencyEvent = function (e, mouseUp) {
      var _this_1 = this;
      this.parent.dotNetRef.invokeMethodAsync("DrawConnectorLine", this.taskBarEditAction, this.connectorSecondAction, this.toDataGuid).then(function (drawLine) {
        if (!drawLine) {
          var target = _this_1.getElementByPosition(e);
          if (target.classList.contains(connectorPointLeft) || target.classList.contains(connectorPointRight)) target.classList.add(connectorPointAllowBlock);
        } else {
          var tooltip = document.getElementById(_this_1.parent.element.id + '_editingtooltip_content');
          if (!sf.base.isNullOrUndefined(tooltip)) {
            var mousePostion = _this_1.parent.tooltipModule.getPointerPosition(e);
            var arrowEle = sf.base.select('.' + 'e-arrow-tip', tooltip);
            var tipWidthAdjust = arrowEle.offsetWidth / 2 + (tooltip.offsetWidth - tooltip.clientWidth);
            tooltip.style.left = mousePostion.x - tipWidthAdjust + 'px';
            tooltip.style.visibility = 'visible';
          }
        }
      });
    };
    TaskbarEdit.prototype.drawFalseLine = function () {
      var x1 = this.mouseDownX;
      var y1 = this.mouseDownY;
      var x2 = this.mouseMoveX;
      var y2 = this.mouseMoveY;
      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
      var transform = 'rotate(' + (this.parent.enableRTL ? -angle : angle) + 'deg)';
      var left;
      var width = 0;
      if (!sf.base.isNullOrUndefined(document.querySelectorAll(".e-chart-row")[0])) {
        width = document.querySelectorAll(".e-chart-row")[0].offsetWidth;
      }
      if (this.taskBarEditAction === 'ConnectorPointLeftDrag') {
        if (this.parent.enableRTL) {
          left = width - (this.elementOffsetLeft + this.elementOffsetWidth + this.connectorPointWidth / 2) - Math.abs(this.parent.chartPreviousScroll.left);
        } else {
          left = this.elementOffsetLeft - this.connectorPointWidth / 2 - Math.abs(this.parent.chartPreviousScroll.left);
        }
      }
      if (this.taskBarEditAction === 'ConnectorPointRightDrag') {
        if (this.parent.enableRTL) {
          left = width - (this.elementOffsetLeft - this.connectorPointWidth / 2) - Math.abs(this.parent.chartPreviousScroll.left);
        } else {
          left = this.elementOffsetLeft + this.elementOffsetWidth + this.connectorPointWidth / 2 - Math.abs(this.parent.chartPreviousScroll.left);
        }
      }
      var top = this.elementOffsetTop + this.elementOffsetHeight / 2 + this.chartBodyContainer.offsetTop - this.parent.chartPreviousScroll.top;
      this.removeFalseLine(false);
      this.falseLine = document.createElement('div');
      this.falseLine.className = falseLine;
      this.falseLine.id = 'ganttfalseline' + this.parent.element.id;
      this.falseLine.style.position = 'absolute';
      this.falseLine.style.transform = transform;
      this.falseLine.style.borderTopWidth = '1px';
      this.falseLine.style.borderTopStyle = 'dashed';
      this.falseLine.style.zIndex = '5';
      this.falseLine.style.width = length - 3 + 'px';
      this.falseLine.style.top = top + 'px';
      if (this.parent.enableRTL) {
        this.falseLine.style.left = 'auto';
        this.falseLine.style.right = left + 'px';
        this.falseLine.style.transformOrigin = '100% 0%';
      } else {
        this.falseLine.style.right = 'auto';
        this.falseLine.style.left = left + 'px';
        this.falseLine.style.transformOrigin = '0% 100%';
      }
      this.chartBodyContainer.appendChild(this.falseLine);
    };
    TaskbarEdit.prototype.removeFalseLine = function (isRemoveConnectorPointDisplay) {
      if (this.falseLine) {
        sf.base.remove(this.falseLine);
        this.falseLine = null;
        if (isRemoveConnectorPointDisplay) {
          this.elementOffsetLeft = 0;
          this.elementOffsetTop = 0;
          this.elementOffsetWidth = 0;
          this.elementOffsetHeight = 0;
        }
      }
    };
    TaskbarEdit.prototype.destroy = function (ganttParent) {
      this.stopScrollTimer();
      this.removeEventListeners(ganttParent);
    };
    return TaskbarEdit;
  }();

  /**
   * File for handling tooltip in Gantt.
   */
  var Tooltip = /** @class */function () {
    function Tooltip(parent) {
      this.parent = parent;
      this.chartPane = this.parent.element.querySelector(".e-gantt-chart-pane");
      this.addEventListeners();
    }
    Tooltip.prototype.addEventListeners = function () {
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseMove, this);
      sf.base.EventHandler.add(this.chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove, this);
    };
    Tooltip.prototype.removeEventListeners = function (ganttParent) {
      var chartPane = ganttParent.element.querySelector('.e-gantt-chart-pane');
      sf.base.EventHandler.remove(chartPane, sf.base.Browser.touchStartEvent, this.ganttMouseMove);
      sf.base.EventHandler.remove(chartPane, sf.base.Browser.touchMoveEvent, this.ganttMouseMove);
    };
    Tooltip.prototype.ganttMouseMove = function (event) {
      this.tooltipMouseEvent = event;
    };
    Tooltip.prototype.tooltipOpened = function (args) {
      var tooltip = document.getElementById(args.element.id);
      if (sf.base.isNullOrUndefined(this.tooltipMouseEvent)) {
        return;
      }
      var postion = this.getPointerPosition(this.tooltipMouseEvent);
      var containerPosition = this.parent.getOffsetRect(this.chartPane);
      var bottomEnd = containerPosition.top + this.chartPane.offsetHeight;
      var rightEnd = containerPosition.left + this.chartPane.offsetWidth;
      var tooltipPositionX = postion.x;
      var tooltipPositionY = postion.y;
      if (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
        while (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
          tooltipPositionX = rightEnd - tooltip.offsetWidth - 10;
          tooltip.style.left = tooltipPositionX + 'px';
        }
      } else {
        tooltipPositionX = tooltipPositionX + 10;
        tooltip.style.left = tooltipPositionX + 'px';
      }
      if (window.innerHeight < tooltip.offsetHeight + tooltipPositionY) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      }
      if (bottomEnd < tooltipPositionY + tooltip.offsetHeight + 20) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      } else {
        tooltipPositionY = tooltipPositionY + 10;
      }
      tooltip.style.top = tooltipPositionY + "px";
      tooltip.style.visibility = 'visible';
    };
    Tooltip.prototype.predecessorTooltipOpened = function (args) {
      var tooltip = document.getElementById(args.element.id);
      if (sf.base.isNullOrUndefined(this.tooltipMouseEvent)) {
        return;
      }
      var postion = this.getPointerPosition(this.tooltipMouseEvent);
      var containerPosition = this.parent.getOffsetRect(this.chartPane);
      var bottomEnd = containerPosition.top + this.chartPane.offsetHeight;
      var rightEnd = containerPosition.left + this.chartPane.offsetWidth;
      var tooltipPositionX = postion.x;
      var tooltipPositionY = postion.y;
      if (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
        while (rightEnd < tooltipPositionX + tooltip.offsetWidth + 10) {
          tooltipPositionX = rightEnd - tooltip.offsetWidth - 10;
          tooltip.style.left = tooltipPositionX + 'px';
        }
      } else {
        tooltipPositionX = tooltipPositionX;
        tooltip.style.left = tooltipPositionX + 'px';
      }
      if (window.innerHeight < tooltip.offsetHeight + tooltipPositionY) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      }
      if (bottomEnd < tooltipPositionY + tooltip.offsetHeight + 20) {
        tooltipPositionY = tooltipPositionY - tooltip.offsetHeight - 10;
      } else {
        tooltipPositionY = tooltipPositionY + 10;
      }
      if (document.getElementsByClassName("e-arrow-tip e-tip-bottom").length > 0) {
        var tipPointer = document.getElementsByClassName("e-arrow-tip e-tip-bottom")[0];
        tipPointer.style.left = postion.x - tooltip.offsetLeft + "px";
      }
      tooltip.style.visibility = 'visible';
    };
    /**
     * Method to get mouse pointer position
     *
     * @param {Event} e .
     * @returns {number} .
     */
    Tooltip.prototype.getPointerPosition = function (e) {
      var posX;
      var posY;
      if (!sf.base.isNullOrUndefined(sf.base.getValue('pageX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('pageY', e))) {
        posX = sf.base.getValue('pageX', e);
        posY = sf.base.getValue('pageY', e);
      } else if (!sf.base.isNullOrUndefined(sf.base.getValue('touches[0].pageX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('touches[0].pageY', e))) {
        posX = sf.base.getValue('touches[0].pageX', e);
        posY = sf.base.getValue('touches[0].pageY', e);
      } else if (!sf.base.isNullOrUndefined(sf.base.getValue('clientX', e)) || !sf.base.isNullOrUndefined(sf.base.getValue('clientY', e))) {
        posX = sf.base.getValue('clientX', e) + document.body.scrollLeft + document.documentElement.scrollLeft;
        posY = sf.base.getValue('clientY', e) + document.body.scrollTop + document.documentElement.scrollTop;
      }
      return {
        x: posX,
        y: posY
      };
    };
    Tooltip.prototype.destroy = function (ganttParent) {
      this.removeEventListeners(ganttParent);
    };
    return Tooltip;
  }();

  /**
   * Specifies SfGantt class for native blazor rendering.
   * @hidden
   */
  var SfGantt = /** @class */function () {
    function SfGantt(dataId, element, options, dotnetRef) {
      this.toolbarHeight = 0;
      this.chartPreviousScroll = {
        top: 0,
        left: 0
      };
      this.treegridPreviousScroll = {
        top: 0,
        left: 0
      };
      window.sfBlazor = window.sfBlazor;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.isFromTreeGrid = false;
      this.options = options;
      this.dataId = dataId;
      window.sfBlazor.setCompInstance(this);
      this.enableRTL = options.enableRtl;
      this.enableAdaptiveUI = options.enableAdaptiveUI;
    }
    SfGantt.prototype.getOffsetRect = function (element) {
      var box = element.getBoundingClientRect();
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
      var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
      var clientLeft = document.documentElement.clientLeft || document.body.clientLeft || 0;
      var top = box.top + scrollTop - clientTop;
      var left = this.enableRTL ? box.right + scrollLeft - clientLeft : box.left + scrollLeft - clientLeft;
      return {
        top: Math.round(top),
        left: Math.round(left),
        width: box.width,
        height: box.height
      };
    };
    SfGantt.prototype.getParentElement = function (elem, selector, isID) {
      var parent = elem;
      while (parent) {
        if (isID ? parent.id === selector : parent.classList.contains(selector)) {
          break;
        }
        parent = parent.parentElement;
      }
      return parent;
    };
    SfGantt.prototype.destroy = function () {
      ChartScroll.prototype.destroy(this);
      TaskbarEdit.prototype.destroy(this);
      Tooltip.prototype.destroy(this);
      TreeGrid.prototype.destroy(this);
    };
    return SfGantt;
  }();

  /**
   * Keyboard module is used to define the keyboard interactions.
   */
  var KeyboardHandler = /** @class */function () {
    function KeyboardHandler(parent) {
      this.activeElementName = null;
      this.activeElement = null;
      this.parent = parent;
    }
    KeyboardHandler.prototype.taskbarFocus = function (tdElem) {
      var taskbarElem = tdElem.querySelector('.' + traceChildTaskBar);
      var parentTaskbarElem = tdElem.querySelector('.' + traceParentTaskBar);
      var milestoneElem = tdElem.querySelector('.' + traceMilestone);
      var parentmilestone = tdElem.querySelector('.' + parentMilestone);
      this.activeElementName = taskBarMainContainer;
      if (milestoneElem) {
        this.activeElement = milestoneElem;
        milestoneElem.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + traceMilestone).classList.add(Active);
      } else if (parentmilestone) {
        this.activeElement = parentmilestone;
        parentmilestone.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + parentMilestone).classList.add(Active);
      } else if (taskbarElem) {
        this.activeElement = taskbarElem;
        taskbarElem.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + traceChildTaskBar).classList.add(Active);
      } else {
        this.activeElement = parentTaskbarElem;
        parentTaskbarElem.focus();
        tdElem.querySelector('.' + taskBarMainContainer).querySelector('.' + traceParentTaskBar).classList.add(Active);
      }
      return "isNextTaskbar";
    };
    KeyboardHandler.prototype.RightLabelFocus = function (tdElem) {
      var rightLabelElem = tdElem.querySelector('.' + rightLabelContainer);
      this.activeElementName = rightLabelContainer;
      this.activeElement = rightLabelElem;
      rightLabelElem.focus();
      rightLabelElem.querySelector('.e-label').classList.add(Active);
      return "isNextRightLabel";
    };
    KeyboardHandler.prototype.LeftLabelFocus = function (tdElem) {
      var leftLabelElem = tdElem.querySelector('.' + leftLabelContainer);
      this.activeElementName = leftLabelContainer;
      this.activeElement = leftLabelElem;
      leftLabelElem.focus();
      leftLabelElem.querySelector('.e-label').classList.add(Active);
      return "isNextLeftLabel";
    };
    return KeyboardHandler;
  }();

  /**
   * Blazor gantt interop handler
   */
  // tslint:disable
  var Gantt = {
    initialize: function initialize(dataId, element, ganttInitiazeProp, dotnetRef, isSingleTier, isFrozenColumn) {
      var options = {
        taskMode: ganttInitiazeProp.taskMode,
        allowTaskbarEditing: ganttInitiazeProp.allowTaskbarEditing,
        enableRowVirtualization: ganttInitiazeProp.enableRowVirtualization,
        enableTimelineVirtualization: ganttInitiazeProp.enableTimelineVirtualization,
        allowSchedulingOnDrag: ganttInitiazeProp.allowSchedulingOnDrag,
        enableRtl: ganttInitiazeProp.enableRtl,
        enableAdaptiveUI: ganttInitiazeProp.enableAdaptiveUI
      };
      var instance = new SfGantt(dataId, element, options, dotnetRef);
      this.dotnetRef = dotnetRef;
      var offset = {};
      this.instance = window.sfBlazor.getCompInstance(dataId);
      var splitterElement = instance.element.querySelector("#" + instance.element.id + "_Gantt_Splitter");
      instance.height = offset.height = element.offsetHeight;
      instance.isMobileDevice = sf.base.Browser.isDevice;
      instance.width = offset.width = element.offsetWidth;
      instance.toolbarElement = element.querySelector("#" + element.id + "_Gantt_Toolbar");
      if (!sf.base.isNullOrUndefined(instance.toolbarElement)) {
        instance.toolbarHeight = offset.toolbarHeight = instance.toolbarElement.offsetHeight;
      }
      if (document.body.classList.contains("e-bigger")) {
        instance.biggerMode = offset.biggerMode = true;
      } else if (this.instance.enableAdaptiveUI) {
        instance.biggerMode = offset.biggerMode = true;
        document.body.classList.add("e-bigger");
      }
      splitterElement.style.height = 'calc(100% - ' + instance.toolbarHeight + 'px)';
      offset.ganttOffsetSize = this.ChartInitialize(ganttInitiazeProp.timelineWidth, ganttInitiazeProp.milestoneHeight, ganttInitiazeProp.taskbarEvent, ganttInitiazeProp.connectorLineEvent);
      this.getTreeGrid(dataId, isSingleTier, isFrozenColumn);
      return offset;
    },
    refreshGantt: function refreshGantt(dataId) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      if (document.body.classList.contains("e-bigger")) {
        instance.biggerMode = true;
      } else {
        instance.biggerMode = false;
      }
      return instance.biggerMode;
    },
    adjustTable: function adjustTable(instance, totalWidth, isFrozenColumn, isColumnVirtualization) {
      var chartModule = instance.chartScrollModule;
      var chartVirtualTable = chartModule.chartVirtualTable;
      var chartVirtualTrack = chartModule.chartRootElement.querySelector(".e-virtualtrack");
      var chartDomMatrix;
      if (instance.options.enableRowVirtualization) {
        var treeElement = document.getElementById("treeGrid" + instance.element.id + "_gridcontrol");
        var content = treeElement.querySelector(".e-gridcontent");
        var treeVirtualTable = void 0;
        var treeVirtualTrack = void 0;
        if (isFrozenColumn) {
          treeVirtualTrack = content.querySelectorAll('.e-virtualtrack')[1];
          treeVirtualTable = content.querySelectorAll('.e-virtualtable')[0];
        } else {
          treeVirtualTable = content.querySelector('.e-virtualtable');
          treeVirtualTrack = content.querySelector('.e-virtualtrack');
        }
        chartDomMatrix = new DOMMatrixReadOnly(chartVirtualTable.style.transform);
        var treegridDomMatrix = new DOMMatrixReadOnly(treeVirtualTable.style.transform);
        if (!sf.base.isNullOrUndefined(treeVirtualTable) && !sf.base.isNullOrUndefined(chartVirtualTable)) {
          chartVirtualTrack.style.height = treeVirtualTrack.style.height;
          if (chartVirtualTable.style.transform == '') {
            chartVirtualTable.style.transform = treeVirtualTable.style.transform;
          } else {
            chartVirtualTable.style.transform = 'translate(' + chartDomMatrix.m41 + 'px,' + treegridDomMatrix.m42 + 'px)';
          }
        }
      }
      if (instance.options.enableTimelineVirtualization) {
        var contentWidth = instance.element.offsetWidth * 3;
        chartDomMatrix = new DOMMatrixReadOnly(chartVirtualTable.style.transform);
        var newTranslateX = totalWidth < contentWidth ? 0 : totalWidth < chartDomMatrix.m41 ? totalWidth - contentWidth : chartDomMatrix.m41;
        chartVirtualTrack.style.width = chartModule.timelineVirtualTrack.offsetWidth + "px";
        chartVirtualTable.style.transform = 'translate(' + newTranslateX + 'px,' + chartDomMatrix.m42 + 'px)';
        if (!sf.base.isNullOrUndefined(chartModule.dependencyViewContainer)) {
          chartModule.dependencyViewContainer.style.left = -newTranslateX + 'px';
        }
      }
    },
    setChartHeight: function setChartHeight(dataId, totalWidth, isFrozenColumn, isColumnVirtualization) {
      var instance = window.sfBlazor.getCompInstance(dataId);
      var chartHeight = 0;
      var offset = {};
      offset["chartHeight"] = 0;
      offset["viewPortHeight"] = 0;
      var chartModule = instance.chartScrollModule;
      var gridContent = instance.element.querySelector(".e-gridcontent");
      var holidayContainer = instance.element.querySelector(".e-holiday-container");
      var treegrid;
      if (isFrozenColumn) {
        if (isColumnVirtualization) {
          treegrid = gridContent.querySelectorAll('.e-virtualtrack')[1];
        }
      } else {
        treegrid = gridContent.querySelector('.e-virtualtrack');
      }
      var content = instance.element.querySelector(".e-gridcontent").querySelector('.e-content');
      content.setAttribute("tabindex", "0");
      var treeGridrole = instance.element.querySelector(".e-gridcontent").querySelector('.e-table');
      treeGridrole.setAttribute("role", "treegrid");
      if (sf.base.isNullOrUndefined(treegrid)) {
        treegrid = instance.element.querySelector("#treeGrid" + instance.element.id + "_gridcontrol_content_table");
      }
      if (treegrid && treegrid.clientHeight) {
        var treeElement = instance.element.querySelector("#treeGrid" + instance.element.id + "_gridcontrol");
        var treegridClientHeight = treegrid.clientHeight + "px";
        var chart = chartModule.chartRootElement;
        chartModule.chartTaskTable = chart.querySelector(".e-task-table");
        var taskTableHeight = chartModule.chartTaskTable.clientHeight;
        var chartContent = chart.getElementsByClassName("e-chart-rows-container")[0];
        var treegridInnerClientHeight = treeElement.querySelectorAll(".e-content")[0].clientHeight;
        var timelineHeader = chartModule.timelineHeaderElement;
        if (treegridInnerClientHeight < treegrid.clientHeight) {
          chartHeight = treegrid.clientHeight;
          chartContent.style.height = instance.options.enableRowVirtualization ? taskTableHeight + "px" : treegridClientHeight;
          timelineHeader.style.width = 'calc(100% - ' + (instance.isMobileDevice ? 0 : instance.scrollWidth) + 'px)';
          content.style.cssText += 'width: calc(100% + ' + (instance.scrollWidth + 1) + 'px);';
          this.viewPortHeight = treegridInnerClientHeight;
        } else {
          chartHeight = treegridInnerClientHeight;
          chartContent.style.height = chartModule.element.clientHeight - 1 + "px";
          timelineHeader.style.width = '100%';
          content.style.cssText += 'width: calc(100% + 1px);';
          this.viewPortHeight = chartContent.clientHeight;
        }
        offset["chartHeight"] = instance.options.enableRowVirtualization ? chartHeight - taskTableHeight : chartHeight;
        offset["viewPortHeight"] = this.viewPortHeight;
      }
      if (!sf.base.isNullOrUndefined(instance) && instance.enableRTL) {
        instance.element.querySelector('.e-gridheader').style.paddingLeft = "0";
      }
      this.adjustTable(instance, totalWidth, isFrozenColumn, isColumnVirtualization);
      if (!sf.base.isNullOrUndefined(holidayContainer)) {
        chartModule.updateTopPosition();
      }
      chartModule.updateScrollTopPosition();
      return offset;
    },
    treegridHeaderAlign: function treegridHeaderAlign(instance, isSingleTier) {
      if (isSingleTier) {
        sf.base.addClass(instance.treeGridElement.querySelectorAll('.e-headercell'), timelineSingleHeaderOuterDiv);
        sf.base.addClass(instance.treeGridElement.querySelectorAll('.e-columnheader'), timelineSingleHeaderOuterDiv);
        var gridHeaderHeight = instance.element.querySelector('.e-gridheader').offsetHeight;
        var gridContent = instance.element.querySelector('.e-gridcontent');
        gridContent.style.height = 'calc(100% - ' + gridHeaderHeight + 'px)';
      } else {
        sf.base.removeClass(instance.treeGridElement.querySelectorAll('.e-headercell'), timelineSingleHeaderOuterDiv);
        sf.base.removeClass(instance.treeGridElement.querySelectorAll('.e-columnheader'), timelineSingleHeaderOuterDiv);
      }
    },
    getTreeGrid: function getTreeGrid(element, isSingleTier, isFrozenColumn) {
      var instance = window.sfBlazor.getCompInstance(element);
      this.hideTreeGridScrollBar(instance, isFrozenColumn);
      if (!sf.base.isNullOrUndefined(instance.treeGridElement)) {
        this.instance.treeGrid = instance.treeGridElement.blazor_instance;
      }
      this.treegridHeaderAlign(instance, isSingleTier);
    },
    hideTreeGridScrollBar: function hideTreeGridScrollBar(instance, isFrozenColumn) {
      instance.treeGridElement = instance.element.querySelector('#treeGrid' + instance.element.id);
      var content = instance.treeGridElement.querySelector('.e-content');
      var gridTable = content.querySelector(".e-table");
      var headerContent = instance.treeGridElement.querySelector('.e-headercontent');
      var scrollbarWidth = 16;
      if (!isFrozenColumn) {
        if (content) {
          content.style.height = '100%';
          instance.element.querySelector('.e-gridcontent').style.height = 'calc(100% - ' + instance.element.querySelector('.e-gridheader').offsetHeight + 'px)';
          instance.treeGridModule = new TreeGrid(instance, content);
        }
        instance.scrollWidth = this.getScrollbarWidth(instance.element);
        if (content.clientHeight > gridTable.clientHeight) {
          content.style.cssText += 'width: calc(100% + 1px);';
        } else if (content.clientHeight < gridTable.clientHeight) {
          instance.scrollWidth = instance.isMobileDevice ? scrollbarWidth : instance.scrollWidth;
          content.style.cssText += 'width: calc(100% + ' + (instance.scrollWidth + 1) + 'px);';
        } else {
          content.classList.add("e-gantt-scroll-padding");
        }
        content.style.cssText += 'overflow: auto;';
        headerContent.style.width = 'calc(100% + 1px)';
      } else {
        instance.treeGridModule = new TreeGrid(instance, content);
        instance.scrollWidth = this.getScrollbarWidth(instance.element);
        if (content.clientHeight > gridTable.clientHeight) {
          content.style.cssText += 'width: calc(100% + 1px);';
        } else if (content.clientHeight < gridTable.clientHeight) {
          instance.scrollWidth = instance.isMobileDevice ? scrollbarWidth : instance.scrollWidth;
          content.style.cssText += 'width: calc(100% + ' + (instance.scrollWidth + 1) + 'px);';
        } else {
          content.classList.add("e-gantt-scroll-padding");
        }
      }
    },
    getScrollbarWidth: function getScrollbarWidth(element) {
      var instance = element;
      var outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.overflow = 'scroll';
      outer.style.msOverflowStyle = 'scrollbar';
      var inner = document.createElement('div');
      outer.appendChild(inner);
      instance.appendChild(outer);
      var scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      outer.parentNode.removeChild(outer);
      return scrollbarWidth;
    },
    getOffsetLeft: function getOffsetLeft(element) {
      var box = this.instance.element.getBoundingClientRect();
      var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
      var clientLeft = document.documentElement.clientLeft || document.body.clientLeft || 0;
      var left = box.left + scrollLeft - clientLeft;
      return Math.round(left);
    },
    tooltipOpened: function tooltipOpened(element, args) {
      this.instance.tooltipModule.tooltipOpened(args);
    },
    predecessorTooltipOpened: function predecessorTooltipOpened(element, args) {
      this.instance.tooltipModule.predecessorTooltipOpened(args);
    },
    setTooltipVisibility: function setTooltipVisibility() {
      var tooltip = document.getElementById(this.instance.element.id + '_editingtooltip_content');
      if (!sf.base.isNullOrUndefined(tooltip)) {
        tooltip.style.visibility = 'visible';
      }
    },
    removeEmptyRowElement: function removeEmptyRowElement() {
      if (!sf.base.isNullOrUndefined(this.instance.taskbarEditModule.chartEmptyRowElement)) {
        sf.base.remove(this.instance.taskbarEditModule.chartEmptyRowElement);
        this.instance.taskbarEditModule.chartEmptyRowElement = null;
      }
    },
    ChartInitialize: function ChartInitialize(totalTimelineWidth, milestoneHeight, TaskbarEditingEvent, ConnectorLineEvent) {
      this.instance.totalTimelineWidth = totalTimelineWidth;
      this.instance.isTaskbarEditingEventMapped = TaskbarEditingEvent;
      this.instance.isConnectorLineEventMapped = ConnectorLineEvent;
      this.instance.keyboardModule = new KeyboardHandler(this.instance);
      if (this.instance.options.allowTaskbarEditing) {
        this.instance.taskbarEditModule = new TaskbarEdit(this.instance);
        this.instance.taskbarEditModule.milestoneHeight = milestoneHeight;
      }
      this.instance.tooltipModule = new Tooltip(this.instance);
      this.instance.chartScrollModule = new ChartScroll(this.instance, this.instance.element);
      this.instance.spinnerShown = false;
      var chartProp = {
        viewPortHeight: this.instance.element.querySelector('.e-gridcontent').querySelector('.e-content').clientHeight,
        chartWidth: this.instance.element.querySelector(".e-gantt-chart-pane").offsetWidth
      };
      return chartProp;
    },
    UpdateScroll: function UpdateScroll(element, scrollBarValue) {
      this.scrollBarElement = this.instance.element.querySelector('.e-chart-scroll-container');
      this.instance.chartScrollModule.previousCount = -1;
      var tempScollLeft = this.scrollBarElement.scrollLeft;
      tempScollLeft = this.instance.enableRTL && Math.sign(tempScollLeft) == -1 ? -tempScollLeft : tempScollLeft;
      if (this.scrollBarElement.offsetWidth < scrollBarValue || tempScollLeft > scrollBarValue) {
        this.scrollBarElement.scrollLeft = this.instance.enableRTL ? -scrollBarValue : scrollBarValue;
      }
    },
    chartFocusOutHandler: function chartFocusOutHandler(id, element) {
      var tdElement = this.instance.element.querySelector(".e-chart-row-cell[data-uid=" + id + "]");
      var focusElement = tdElement.querySelector('.' + Active) ? tdElement.querySelector('.' + Active).parentElement : null;
      if (focusElement) {
        focusElement.querySelector('.e-label').classList.remove(Active);
        focusElement.blur();
      }
    },
    focusOutHandler: function focusOutHandler(elem) {
      var focusElement = elem.querySelector('.' + Active);
      if (!sf.base.isNullOrUndefined(focusElement)) {
        focusElement.classList.remove(Active);
      }
      if (!sf.base.isNullOrUndefined(elem.classList)) {
        elem.classList.remove(Active);
      }
    },
    resetPrivateProperties: function resetPrivateProperties(element) {
      this.instance.taskbarEditModule.tappedPoint = null;
    },
    setActiveElement: function setActiveElement(tdElem, elementName) {
      this.instance.keyboardModule.activeElement = tdElem;
      this.instance.keyboardModule.activeElementName = elementName;
    },
    tabFocusHandler: function tabFocusHandler(id, element, isShift, code) {
      var tdElem = this.instance.element.querySelector(".e-chart-row-cell[data-uid=" + id + "]");
      var result = "isNextLeftLabel";
      var focusElem = tdElem.querySelector('.' + Active) ? tdElem.querySelector('.' + Active).parentElement : null;
      if ((code == "ArrowDown" || code == "ArrowUp") && focusElem == null) {
        this.focusOutHandler(this.instance.keyboardModule.activeElement);
        switch (this.instance.keyboardModule.activeElementName) {
          case taskBarMainContainer:
            this.instance.keyboardModule.taskbarFocus(tdElem);
            break;
          case leftLabelContainer:
            this.instance.keyboardModule.LeftLabelFocus(tdElem);
            break;
          default:
            this.instance.keyboardModule.RightLabelFocus(tdElem);
        }
        return "";
      } else if (!focusElem) {
        if (!isShift && code != "ArrowLeft" && tdElem.querySelector('.' + LeftLabel)) {
          result = this.instance.keyboardModule.LeftLabelFocus(tdElem);
        } else if (isShift && tdElem.querySelector('.' + RightLabel)) {
          result = this.instance.keyboardModule.RightLabelFocus(tdElem);
        } else {
          result = this.instance.keyboardModule.taskbarFocus(tdElem);
        }
        return result;
      } else if (focusElem == null && this.instance.keyboardModule.activeElement != null) {
        if (code == "Tab" || code == "ArrowRight") {
          switch (this.instance.keyboardModule.activeElementName) {
            case leftLabelContainer:
              result = this.instance.keyboardModule.taskbarFocus(tdElem);
              break;
            case taskBarMainContainer:
              result = this.instance.keyboardModule.RightLabelFocus(tdElem);
              break;
            default:
              this.instance.keyboardModule.activeElement = null;
              this.instance.keyboardModule.activeElementName = null;
              result = "isFirstGridCell";
          }
          return result;
        } else {
          switch (this.instance.keyboardModule.activeElementName) {
            case leftLabelContainer:
              this.instance.keyboardModule.activeElement = null;
              this.instance.keyboardModule.activeElementName = null;
              result = "isLastGridCell";
              break;
            case taskBarMainContainer:
              result = this.instance.keyboardModule.LeftLabelFocus(tdElem);
              break;
            default:
              result = this.instance.keyboardModule.taskbarFocus(tdElem);
          }
          return result;
        }
      } else if (focusElem.classList.contains(LeftLabel)) {
        if (isShift) {
          focusElem.querySelector('.e-label').classList.remove(Active);
          focusElem.blur();
          this.instance.keyboardModule.activeElement = null;
          this.instance.keyboardModule.activeElementName = null;
          return "isLastGridCell";
        } else {
          return this.instance.keyboardModule.taskbarFocus(tdElem);
        }
      } else if (!focusElem.classList.length) {
        if (!isShift) {
          if (tdElem.querySelector('.e-right-label-inner-div')) {
            return this.instance.keyboardModule.RightLabelFocus(tdElem);
          } else if (code == "ArrowRight" || code == "Tab") {
            this.instance.keyboardModule.activeElement = null;
            this.instance.keyboardModule.activeElementName = null;
            return "isFirstGridCell";
          } else {
            this.instance.keyboardModule.activeElement = null;
            this.instance.keyboardModule.activeElementName = null;
            return "isLastGridCell";
          }
        } else {
          if (tdElem.querySelector('.e-left-label-inner-div')) {
            return this.instance.keyboardModule.LeftLabelFocus(tdElem);
          } else {
            this.instance.keyboardModule.activeElement = null;
            this.instance.keyboardModule.activeElementName = null;
            return "isLastGridCell";
          }
        }
      } else if (focusElem.classList.contains(RightLabel)) {
        if (isShift) {
          return this.instance.keyboardModule.taskbarFocus(tdElem);
        } else if (code == "ArrowRight" || code == "Tab") {
          this.instance.keyboardModule.activeElement = null;
          this.instance.keyboardModule.activeElementName = null;
          return "isFirstGridCell";
        } else {
          this.instance.keyboardModule.activeElement = null;
          this.instance.keyboardModule.activeElementName = null;
          return "isLastGridCell";
        }
      } else {
        return "";
      }
    },
    updateScrollLeft: function updateScrollLeft(element, scrollLeft, index) {
      var chartElement = this.instance.element.querySelector('.e-chart-scroll-container');
      if (index != null) {
        var taskbarHeight = this.instance.element.querySelector('.e-row').offsetHeight;
        var ScrollTop = index * taskbarHeight;
        if (chartElement.offsetHeight - taskbarHeight / 2 + chartElement.scrollTop < ScrollTop || chartElement.scrollTop > ScrollTop) {
          chartElement.scrollTop = ScrollTop;
        }
      }
      scrollLeft = scrollLeft > 0 ? scrollLeft : 0;
      scrollLeft = chartElement.scrollWidth <= scrollLeft ? chartElement.scrollWidth : scrollLeft;
      if (chartElement.offsetWidth + chartElement.scrollLeft < scrollLeft || chartElement.scrollLeft > scrollLeft) {
        var tempScollLeft = scrollLeft - 50;
        chartElement.scrollLeft = this.instance.enableRTL ? -tempScollLeft : tempScollLeft;
      }
    },
    destroy: function destroy(dataId) {
      var ganttInstance = window.sfBlazor.getCompInstance(dataId);
      if (ganttInstance != undefined && ganttInstance.dotNetRef != null) {
        ganttInstance.destroy();
      }
    }
  };
  return Gantt;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfgantt');})})();