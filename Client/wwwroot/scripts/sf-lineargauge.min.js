(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-lineargauge"],{

/***/ "./bundles/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./bundles/sf-lineargauge.js ***!
  \***********************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-lineargauge.js */ "./modules/sf-lineargauge.js");
/* harmony import */ var _modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_lineargauge_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-lineargauge.js":
/*!***********************************!*\
  !*** ./modules/sf-lineargauge.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.LinearGauge = function () {
  'use strict';

  /* eslint-disable @typescript-eslint/member-delimiter-style */
  /* eslint-disable @typescript-eslint/naming-convention */
  /* eslint-disable @typescript-eslint/dot-notation */
  /* eslint-disable max-len */
  /**
   * LinearGauge Blazor introp module
   */
  var SfLinearGauge = /** @class */function () {
    // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
    function SfLinearGauge(id, element, options, dotnetRef) {
      this.dragMillisecond = 0;
      this.tooltipTimer = 0;
      this.isTouch = false;
      this.isResized = false;
      this.allowAnimation = false;
      window.sfBlazor = window.sfBlazor;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.valueToCoefficient = function (numberValue, options) {
        var result = (numberValue - options.Minimum) / options.Delta;
        result = options.Orientation === 'Vertical' ? !options.IsInversed || options.ContainerType === "Thermometer" ? 1 - result : result : !options.IsInversed || options.ContainerType === "Thermometer" ? result : 1 - result;
        return result;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.barAnimationProgress = function (options, timeStamp, element, start, end, val, isRoundedRectangleAtMinimum) {
        var currentValue = start < end ? start + timeStamp * val : start - timeStamp * val;
        var maxValue = this.valueToCoefficient(currentValue, options) * options.RectHeight + options.RectY;
        var minValue = this.valueToCoefficient(options.Minimum, options) * options.RectHeight + options.RectY;
        var currentHeight = Math.abs(maxValue - minValue);
        if (options.Orientation === 'Vertical') {
          options.PointerBoundY = options.ContainerType === "Thermometer" ? maxValue : !options.IsInversed ? maxValue : minValue;
          options.PointerBoundHeight = currentHeight;
          if (options.PointerType === 'Bar' && options.ContainerType === "Normal") {
            element.setAttribute('y', options.PointerBoundY.toString());
            element.setAttribute('height', options.PointerBoundHeight.toString());
            element.setAttribute('x', options.PointerBoundX.toString());
            element.setAttribute('width', options.PointerWidth.toString());
          }
          if (element.tagName === "path") {
            element.setAttribute('d', isRoundedRectangleAtMinimum ? '' : this.getPathContainer(options));
          }
        } else {
          options.PointerBoundX = options.ContainerType === "Thermometer" ? minValue : options.IsInversed ? maxValue : minValue;
          options.PointerBoundWidth = currentHeight;
          if (options.PointerType === 'Bar' && options.ContainerType === "Normal") {
            element.setAttribute('x', options.PointerBoundX.toString());
            element.setAttribute('width', options.PointerBoundWidth.toString());
            element.setAttribute('y', options.PointerBoundY.toString());
            element.setAttribute('height', options.PointerHeight.toString());
          }
          if (element.tagName === "path") {
            element.setAttribute('d', isRoundedRectangleAtMinimum ? '' : this.getPathContainer(options));
          }
        }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.markerAnimationProgress = function (options, timeStamp, element, start, end, val, allowPointerAnimation, allowAnimation) {
        var currentValue = start < end ? start + timeStamp * val : start - timeStamp * val;
        var shapeBasedOnPosition = options.MarkerType;
        if (options.MarkerType == 'InvertedTriangle' || options.MarkerType == 'Triangle') {
          shapeBasedOnPosition = (options.Position == 'Outside' && !options.OpposedPosition || options.Position == 'Inside' && options.OpposedPosition || options.Position == 'Cross') && options.MarkerType == 'Triangle' ? 'InvertedTriangle' : (options.Position == 'Inside' && !options.OpposedPosition || options.Position == 'Outside' && options.OpposedPosition) && options.MarkerType == 'InvertedTriangle' ? 'Triangle' : options.MarkerType;
        }
        if (allowPointerAnimation || allowAnimation) {
          for (var i = 0; i < element.childNodes.length; i++) {
            var childElement = element.childNodes[i];
            if (childElement.id === options.AnimationId) {
              if (options.Orientation === 'Vertical') {
                var locationX = options.PointerBoundX;
                options.PointerBoundY = this.valueToCoefficient(currentValue, options) * options.RectHeight + options.RectY;
                if (options.MarkerType === 'Circle') {
                  var radius = (options.PointerWidth + options.PointerHeight) / 4;
                  var cx = !options.OpposedPosition ? options.Placement != 'Far' ? locationX - radius : locationX + radius : options.Placement == 'Near' ? locationX - radius : locationX + radius;
                  childElement.setAttribute('cy', options.PointerBoundY.toString());
                  childElement.setAttribute('cx', cx.toString());
                } else if (options.MarkerType === 'Image' || options.MarkerType === 'Rectangle') {
                  var x = !options.OpposedPosition && options.Placement !== 'Far' || options.OpposedPosition && options.Placement === 'Near' ? locationX - (options.MarkerType === 'Image' ? options.PointerWidth / 2 : options.PointerWidth) : locationX;
                  childElement.setAttribute('y', (options.PointerBoundY - options.PointerHeight / 2).toString());
                  childElement.setAttribute('x', x.toString());
                } else if (options.MarkerType === 'Text') {
                  var x = !options.OpposedPosition && options.Placement !== 'Far' || options.OpposedPosition && options.Placement === 'Near' ? options.Position === 'Inside' && !options.OpposedPosition || options.OpposedPosition && options.Placement === 'Near' && options.Position === 'Outside' ? locationX - options.PointerBoundWidth / 2 : locationX - options.PointerBoundWidth : locationX;
                  childElement.setAttribute('y', options.PointerBoundY.toString());
                  childElement.setAttribute('x', x.toString());
                } else {
                  childElement.setAttribute('d', this.calculateShapes(options, shapeBasedOnPosition));
                }
              } else {
                options.PointerBoundX = this.valueToCoefficient(currentValue, options) * options.RectHeight + options.RectY;
                var locationY = options.PointerBoundY;
                if (options.MarkerType === 'Circle') {
                  var radius = (options.PointerWidth + options.PointerHeight) / 4;
                  var cy = !options.OpposedPosition ? options.Placement == 'Far' ? locationY + radius : locationY - radius : options.Placement == 'Near' ? locationY - radius : locationY + radius;
                  childElement.setAttribute('cx', options.PointerBoundX.toString());
                  childElement.setAttribute('cy', cy.toString());
                } else if (options.MarkerType === 'Image' || options.MarkerType === 'Rectangle') {
                  var height = options.PointerHeight;
                  var y = !options.OpposedPosition ? options.Placement === 'Far' ? locationY + height / 2 : locationY - height / 2 : options.Placement === 'Near' ? locationY - height / 2 : locationY + height / 2;
                  childElement.setAttribute('x', (options.PointerBoundX - options.PointerWidth / 2).toString());
                  childElement.setAttribute('y', y.toString());
                } else if (options.MarkerType === 'Text') {
                  var y = !options.OpposedPosition ? options.Placement == 'Far' ? options.Position == 'Cross' ? locationY + options.PointerBoundHeight + options.PointerBoundHeight / 4 : options.Position == 'Inside' ? locationY + options.PointerBoundHeight * 2 + options.PointerBoundHeight / 4 : locationY + options.PointerBoundHeight / 2 : options.Position == 'Cross' ? locationY + options.PointerBoundHeight / 2 : options.Position == 'Inside' ? locationY + options.PointerBoundHeight + options.PointerBoundHeight / 2 : locationY - options.PointerBoundHeight / 4 : options.Placement == 'Near' ? options.Position == 'Outside' ? locationY + options.PointerBoundHeight + options.PointerBoundHeight / 4 : options.Position == 'Cross' ? locationY + options.PointerBoundHeight / 2 : locationY - options.PointerBoundHeight / 4 : options.Position == 'Cross' ? locationY + options.PointerBoundHeight + options.PointerBoundHeight / 4 : options.Position == 'Outside' ? locationY + options.PointerBoundHeight * 2 + options.PointerBoundHeight / 4 : locationY + options.PointerBoundHeight / 2;
                  childElement.setAttribute('x', options.PointerBoundX.toString());
                  childElement.setAttribute('y', y.toString());
                } else {
                  childElement.setAttribute('d', this.calculateShapes(options, shapeBasedOnPosition));
                }
              }
            }
          }
        }
      };
      this.id = id;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.options = options;
      this.dataId = id;
      window.sfBlazor.setCompInstance(this);
    }
    SfLinearGauge.prototype.destroy = function () {
      this.dotNetRef = null;
      this.unWireEvents();
    };
    SfLinearGauge.prototype.unWireEvents = function () {
      /*! Bind the Event handler */
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchStartEvent, this.gaugeOnMouseDown);
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchMoveEvent, this.gaugeOnMouseMove);
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchEndEvent, this.gaugeOnMouseEnd);
      sf.base.EventHandler.remove(this.element, sf.base.Browser.touchCancelEvent, this.gaugeOnMouseEnd);
      sf.base.EventHandler.remove(this.element, 'click', this.gaugeOnMouseClick);
      sf.base.EventHandler.remove(this.element, 'mouseleave', this.gaugeOnMouseLeave);
      window.removeEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.gaugeOnResize.bind(this));
    };
    SfLinearGauge.prototype.render = function () {
      this.wireEvents();
    };
    SfLinearGauge.prototype.wireEvents = function () {
      /*! Bind the Event handler */
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchStartEvent, this.gaugeOnMouseDown, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchMoveEvent, this.gaugeOnMouseMove, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchEndEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, sf.base.Browser.touchCancelEvent, this.gaugeOnMouseEnd, this);
      sf.base.EventHandler.add(this.element, 'click', this.gaugeOnMouseClick, this);
      sf.base.EventHandler.add(this.element, 'mouseleave', this.gaugeOnMouseLeave, this);
      window.addEventListener(sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.gaugeOnResize.bind(this));
    };
    SfLinearGauge.prototype.gaugeOnResize = function () {
      var width;
      var height;
      if (!sf.base.isNullOrUndefined(this.element)) {
        var svgElement = document.getElementById(this.element.id + '_svg');
        if (!sf.base.isNullOrUndefined(svgElement)) {
          svgElement.style.display = 'none';
          var elementRect = this.element.getBoundingClientRect();
          width = elementRect.width;
          height = elementRect.height;
          svgElement.style.removeProperty('display');
        }
      }
      if (this.previousHeight !== height || this.previousWidth !== width) {
        this.previousHeight = height;
        this.previousWidth = width;
        this.isResized = true;
        this.allowAnimation = false;
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerResizeEvent', width, height);
        }
      }
    };
    SfLinearGauge.prototype.gaugeOnMouseClick = function (element) {
      var targetId = element.target.id;
      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
      }
    };
    SfLinearGauge.prototype.gaugeOnMouseLeave = function (element) {
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        var index = this.calculateSelectedElementIndex(element);
        this.dotNetRef.invokeMethodAsync('TriggerMouseLeaveEvent', element.x, element.y, index.axisIndex, index.pointerIndex, index.rangeIndex, index.annotationIndex);
      }
    };
    SfLinearGauge.prototype.gaugeOnMouseDown = function (element) {
      var targetId = element.target.id;
      var clientX = 0;
      var clientY = 0;
      if (element.type === 'touchstart') {
        this.isTouch = true;
        clientX = element['touches'][0].clientX;
        clientY = element['touches'][0].clientY;
      } else {
        this.isTouch = false;
        clientX = element.pageX;
        clientY = element.pageY;
      }
      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = true;
        this.pointerId = targetId;
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        if (!sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex] && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          element.preventDefault();
          this.dotNetRef.invokeMethodAsync('TriggerDragStart', axisIndex, pointerIndex);
        }
      }
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        var index = this.calculateSelectedElementIndex(element);
        this.dotNetRef.invokeMethodAsync('TriggerMouseDownEvent', clientX, clientY, index.axisIndex, index.pointerIndex, index.rangeIndex, index.annotationIndex);
      }
      if (this.isTouch) {
        this.tooltipRenderer(targetId, clientX, clientY);
      }
    };
    SfLinearGauge.prototype.gaugeOnMouseMove = function (element) {
      var currentDate = new Date();
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var moveClientX = 0;
      var moveClientY = 0;
      if (element.type === 'touchmove') {
        moveClientX = element['touches'][0].clientX;
        moveClientY = element['touches'][0].clientY;
      } else {
        moveClientX = element.clientX;
        moveClientY = element.clientY;
      }
      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        if (this.pointerCheck && (this.dragMillisecond == 0 || Math.abs(currentDate.getMilliseconds() - this.dragMillisecond) > 80) && !sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex] && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dragMillisecond = currentDate.getMilliseconds();
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'grabbing');
          this.dotNetRef.invokeMethodAsync('TriggerDrag', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top);
        } else if (!this.pointerCheck && !sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex]) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
        }
      } else if (!sf.base.isNullOrUndefined(document.getElementById(this.id + '_svg'))) {
        document.getElementById(this.id + '_svg').setAttribute('cursor', 'auto');
      }
      this.tooltipRenderer(targetId, moveClientX, moveClientY);
    };
    SfLinearGauge.prototype.tooltipRenderer = function (targetId, moveClientX, moveClientY) {
      var _this = this;
      if (targetId === this.element.id + '_LinearGaugeTitle' && event.target.textContent.indexOf('...') > -1) {
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          clearTimeout(this.tooltipTimer);
          this.dotNetRef.invokeMethodAsync('TriggerTooltip', targetId, 0, 0, 0, 0, {}, {}, {}, {});
          if (this.isTouch) {
            this.tooltipTimer = setTimeout(function () {
              var tooltipElement = document.getElementById(_this.element.id + '_Tooltip');
              if (tooltipElement != null) {
                _this.dotNetRef.invokeMethodAsync('TriggerTooltip', "", 0, 0, 0, 0, {}, {}, {}, {});
              }
            }, 1500);
          }
        }
      } else if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1 || targetId.indexOf('Range') > -1) {
        var svgBounds = this.svgClient(targetId);
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        var parentId = targetId.split('_')[0];
        var parentElement = document.getElementById(parentId).getBoundingClientRect();
        var parentEle = {
          Bottom: parentElement['bottom'],
          Height: parentElement['height'],
          Left: parentElement['left'],
          Right: parentElement['right'],
          Top: parentElement['top'],
          Width: parentElement['width'],
          X: parentElement['x'],
          Y: parentElement['y']
        };
        var lineElement = document.getElementById(parentId + '_AxisLine_' + axisIndex).getBoundingClientRect();
        var lineEle = {
          Bottom: lineElement['bottom'],
          Height: lineElement['height'],
          Left: lineElement['left'],
          Right: lineElement['right'],
          Top: lineElement['top'],
          Width: lineElement['width'],
          X: lineElement['x'],
          Y: lineElement['y']
        };
        var tickElement = document.getElementById(parentId + '_MajorTicksLine_' + axisIndex).getBoundingClientRect();
        var tickEle = {
          Bottom: tickElement['bottom'],
          Height: tickElement['height'],
          Left: tickElement['left'],
          Right: tickElement['right'],
          Top: tickElement['top'],
          Width: tickElement['width'],
          X: tickElement['x'],
          Y: tickElement['y']
        };
        var pointElement = document.getElementById(targetId).getBoundingClientRect();
        var pointEle = {
          Bottom: pointElement['bottom'],
          Height: pointElement['height'],
          Left: pointElement['left'],
          Right: pointElement['right'],
          Top: pointElement['top'],
          Width: pointElement['width'],
          X: pointElement['x'],
          Y: pointElement['y']
        };
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          clearTimeout(this.tooltipTimer);
          this.dotNetRef.invokeMethodAsync('TriggerTooltip', targetId, axisIndex, pointerIndex, moveClientX - svgBounds.left, moveClientY - svgBounds.top, parentEle, lineEle, tickEle, pointEle);
          if (this.isTouch) {
            this.tooltipTimer = setTimeout(function () {
              var tooltipElement = document.getElementById(_this.element.id + '_Tooltip');
              if (tooltipElement != null) {
                _this.dotNetRef.invokeMethodAsync('TriggerTooltip', "", 0, 0, 0, 0, {}, {}, {}, {});
              }
            }, 1500);
          }
        }
      } else {
        var tooltipElement = document.getElementById(this.element.id + '_Tooltip');
        if (tooltipElement != null) {
          this.dotNetRef.invokeMethodAsync('TriggerTooltip', "", 0, 0, 0, 0, {}, {}, {}, {});
        }
      }
    };
    SfLinearGauge.prototype.gaugeOnMouseEnd = function (element) {
      var targetId = this.pointerCheck ? this.pointerId : element.target.id;
      var clientX = 0;
      var clientY = 0;
      if (element.type === 'touchend') {
        var touchArg = element;
        clientX = touchArg.changedTouches[0].pageX;
        clientY = touchArg.changedTouches[0].pageY;
      } else {
        clientX = element.clientX;
        clientY = element.clientY;
      }
      this.pointerCheck = false;
      if (targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1) {
        this.pointerCheck = false;
        this.dragMillisecond = 0;
        this.pointerId = "";
        var svgBounds = this.svgClient(targetId);
        var parentId = targetId.split('_AxisIndex_')[0].split('_')[0];
        var axisIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10);
        var pointerIndex = parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10);
        if (!sf.base.isNullOrUndefined(this.enableDragCollection) && this.enableDragCollection[axisIndex][pointerIndex] && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          document.getElementById(this.id + '_svg').setAttribute('cursor', 'pointer');
          this.dotNetRef.invokeMethodAsync('TriggerDragEnd', axisIndex, pointerIndex, parentId, targetId, clientX - svgBounds.left, clientY - svgBounds.top);
        }
      }
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        var index = this.calculateSelectedElementIndex(element);
        this.dotNetRef.invokeMethodAsync('TriggerMouseUpEvent', clientX, clientY, index.axisIndex, index.pointerIndex, index.rangeIndex, index.annotationIndex);
      }
    };
    SfLinearGauge.prototype.calculateSelectedElementIndex = function (element) {
      var targetId = element.target.id;
      var pointerIndexCheck = targetId.indexOf('Bar') > -1 || targetId.indexOf('Marker') > -1;
      var defaultIndex = -1;
      var axisIndex = defaultIndex;
      var pointerIndex = defaultIndex;
      var rangeIndex = defaultIndex;
      var annotationIndex = defaultIndex;
      if (targetId.indexOf('Range') > -1 || pointerIndexCheck) {
        axisIndex = targetId.indexOf('_AxisIndex_') > -1 ? parseInt(targetId.split('_AxisIndex_')[1].split('_')[0], 10) : defaultIndex;
        pointerIndex = pointerIndexCheck ? parseInt(targetId.split('_AxisIndex_')[1].split('_')[2], 10) : defaultIndex;
        rangeIndex = targetId.indexOf('Range') > -1 ? parseInt(targetId.split('_Range_')[1], 10) : defaultIndex;
      } else if (!sf.base.isNullOrUndefined(element.target.closest(".e-lineargauge-annotation"))) {
        var parentElement = element.target.closest(".e-lineargauge-annotation").parentElement;
        axisIndex = parentElement.id.indexOf('Annotation') > -1 ? parseInt(parentElement.id.split('_')[2]) : defaultIndex;
        annotationIndex = parentElement.id.indexOf('Annotation') > -1 ? parseInt(parentElement.id.split('_')[parentElement.id.split('_').length - 1]) : defaultIndex;
      }
      return {
        axisIndex: axisIndex,
        pointerIndex: pointerIndex,
        rangeIndex: rangeIndex,
        annotationIndex: annotationIndex
      };
    };
    SfLinearGauge.prototype.svgClient = function (targetId) {
      var svg = document.getElementById(targetId.split('_AxisIndex_')[0] + '_svg');
      return svg.getBoundingClientRect();
    };
    SfLinearGauge.prototype.pointerAnimation = function (options, id, allowAnimation, annotationDuration, animationPointer, isAnnotationAvailable) {
      var _this = this;
      var instance = window.sfBlazor.getCompInstance(id);
      var element = document.getElementById(options.AnimationId);
      var start = options.PreviousPointerValue;
      var _end = options.PointerValue;
      start = start === _end ? options.Minimum : start;
      var val = Math.abs(start - _end);
      var timeStamp;
      new sf.base.Animation({}).animate(element.parentElement, {
        name: 'Linear',
        duration: options.Duration,
        progress: function progress(args) {
          element.style.visibility = 'visible';
          if (!_this.isResized && (animationPointer || instance.allowAnimation)) {
            timeStamp = (args.timeStamp - args.delay) / options.Duration;
            if (options.PointerType != 'Bar') {
              _this.markerAnimationProgress(options, timeStamp, element.parentElement, start, _end, val, animationPointer, instance.allowAnimation);
            } else {
              _this.barAnimationProgress(options, timeStamp, element, start, _end, val, false);
            }
          } else {
            element.parentElement.removeAttribute('style');
          }
        },
        end: function end(args) {
          if (!_this.isResized && (animationPointer || instance.allowAnimation)) {
            timeStamp = 1;
            if (options.PointerType != 'Bar') {
              _this.markerAnimationProgress(options, timeStamp, element.parentElement, start, _end, val, animationPointer, instance.allowAnimation);
            } else {
              _this.barAnimationProgress(options, timeStamp, element, start, _end, val, options.ContainerType === 'RoundedRectangle' && options.Minimum === options.PointerValue);
            }
          } else {
            element.parentElement.removeAttribute('style');
          }
          if (allowAnimation && annotationDuration > 0) {
            if (isAnnotationAvailable) {
              instance.annotationAnimation(id, annotationDuration);
            } else {
              instance.cancelAnimation();
            }
          }
        }
      });
      if (!allowAnimation) {
        this.isResized = false;
      }
    };
    SfLinearGauge.prototype.annotationAnimation = function (id, duration) {
      var instance = window.sfBlazor.getCompInstance(this.element.id);
      var element = document.getElementById(id + '_AnnotationGroup');
      var styleElement = document.getElementById(id + '_create_Animation');
      if (element.style.opacity === '0') {
        var tempOpacity_1 = 0;
        var opacity_1 = 1;
        new sf.base.Animation({}).animate(element, {
          duration: duration,
          progress: function progress(args) {
            if (args.timeStamp > args.delay) {
              tempOpacity_1 = (args.timeStamp - args.delay) / args.duration;
              element['style']['opacity'] = (opacity_1 * tempOpacity_1).toString();
            }
          },
          end: function end() {
            element['style']['opacity'] = opacity_1.toString();
            instance.cancelAnimation();
          }
        });
      }
    };
    SfLinearGauge.prototype.animationProcess = function (id, duration, allowAnimation, axesOptions, pointerOptions, pointerCount, totalAnimationDuration) {
      var element = document.getElementById(id + '_Axis_Collections');
      var styleElement = document.getElementById(id + '_create_Animation');
      var instance = window.sfBlazor.getCompInstance(id);
      var tempOpacity = 0;
      var opacity = 1;
      var elements = document.querySelectorAll('style.' + id + '_Animation');
      var isAnnotationAvailable = !sf.base.isNullOrUndefined(document.getElementById(id + '_AnnotationGroup')) && document.getElementById(id + '_AnnotationGroup').children.length > 0 ? true : false;
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        progress: function progress(args) {
          tempOpacity = (args.timeStamp - args.delay) / args.duration;
          elements[0].innerHTML = '.' + id + '_Animation' + '{opacity:' + opacity * tempOpacity + '}';
        },
        end: function end() {
          elements[0].innerHTML = '.' + id + '_Animation' + '{opacity: 1}';
          if (instance && instance.element) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var pointerData = JSON.parse(pointerOptions.animationSettings);
            for (var i = 0; i < pointerCount; i++) {
              var pointerElement = document.getElementById(id + '_PointersGroup_' + i);
              if (!sf.base.isNullOrUndefined(pointerElement)) {
                pointerElement.style.visibility = "visible";
              }
              if (pointerData.length > 0) {
                instance.pointerAnimation(pointerData[i], id, allowAnimation, duration, false, isAnnotationAvailable);
              }
            }
            if (allowAnimation && pointerCount < 1) {
              if (isAnnotationAvailable) {
                instance.annotationAnimation(id, duration);
              } else {
                instance.cancelAnimation();
              }
            }
          }
        }
      });
      setTimeout(function () {
        if (!sf.base.isNullOrUndefined(styleElement)) {
          styleElement.remove();
        }
      }, totalAnimationDuration + 100);
      this.isResized = false;
    };
    SfLinearGauge.prototype.cancelAnimation = function () {
      this.allowAnimation = false;
      this.dotNetRef.invokeMethodAsync('EndAnimation');
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfLinearGauge.prototype.getPathContainer = function (options) {
      var path = ' ';
      var radius = options.CornerRadius;
      var rectWidth = options.PointerBoundWidth;
      var rectHeight = options.PointerBoundHeight;
      var orientation = options.Orientation;
      var isInversed = options.IsInversed;
      var pointerType = options.PointerType;
      var pointerBoundX = options.PointerBoundX;
      var pointerBoundY = options.PointerBoundY;
      var bottomRadius = 0;
      var topRadius = 0;
      switch (options.ContainerType) {
        case 'RoundedRectangle':
          var horizontalCurve = pointerBoundX + rectWidth - radius;
          var verticalCurve = pointerBoundY + rectHeight - radius;
          var verticalRadius = radius + pointerBoundY;
          var horizontalRadius = radius + pointerBoundX;
          if (pointerType === 'Bar' && (orientation === 'Vertical' && rectHeight !== 0 || orientation === 'Horizontal' && rectWidth !== 0)) {
            if (horizontalRadius > pointerBoundX + rectWidth / 2) {
              horizontalRadius = horizontalCurve = pointerBoundX + rectWidth / 2;
            }
            if (verticalRadius > pointerBoundY + rectHeight / 2) {
              verticalRadius = verticalCurve = pointerBoundY + rectHeight / 2;
            }
          }
          if (pointerType === 'Bar' && (orientation === 'Vertical' && rectHeight === 0 || orientation === 'Horizontal' && rectWidth === 0)) {
            if (rectWidth < radius / 2 && !isInversed) {
              horizontalCurve = horizontalCurve + radius + radius / 2;
            } else if (rectWidth < radius / 2 && isInversed) {
              horizontalRadius = pointerBoundX - Math.ceil(radius / 4);
            }
            if (rectHeight < radius / 2 && !isInversed) {
              verticalRadius = pointerBoundY - Math.ceil(radius / 4);
            } else if (rectHeight < radius / 2 && isInversed) {
              verticalCurve = verticalCurve + radius + radius / 2;
            }
          }
          path = 'M' + ' ' + pointerBoundX + ' ' + verticalRadius + ' Q ' + pointerBoundX + ' ' + pointerBoundY + ' ' + horizontalRadius + ' ' + pointerBoundY + ' ' + 'L' + ' ' + horizontalCurve + ' ' + pointerBoundY + ' Q ' + (pointerBoundX + rectWidth) + ' ' + pointerBoundY + ' ' + (pointerBoundX + rectWidth) + ' ' + verticalRadius + ' ' + 'L ' + (pointerBoundX + rectWidth) + ' ' + verticalCurve + ' Q ' + (pointerBoundX + rectWidth) + ' ' + (pointerBoundY + rectHeight) + ' ' + horizontalCurve + ' ' + (pointerBoundY + rectHeight) + ' ' + ' L ' + horizontalRadius + ' ' + (pointerBoundY + rectHeight) + ' Q ' + pointerBoundX + ' ' + (pointerBoundY + rectHeight) + ' ' + pointerBoundX + ' ' + verticalCurve + ' ' + 'L' + ' ' + pointerBoundX + ' ' + verticalRadius + ' ' + 'z';
          break;
        case 'Thermometer':
          var width = orientation === 'Vertical' ? rectWidth : rectHeight;
          bottomRadius = width + width / 2 / Math.PI;
          topRadius = width / 2;
          if (orientation === 'Vertical') {
            var addValue = options.ContainerWidth + options.ContainerWidth / 2 / Math.PI - bottomRadius;
            var boundY = pointerType === 'Bar' ? pointerBoundY + addValue : pointerBoundY;
            var locationY = pointerType === 'Bar' ? pointerBoundY + (topRadius - topRadius / Math.PI) : pointerBoundY;
            var locHeight = rectHeight;
            path = 'M' + pointerBoundX + ' ' + (boundY + locHeight) + ' A ' + bottomRadius + ' ' + bottomRadius + ', 0, 1, 0, ' + (pointerBoundX + rectWidth) + ' ' + (boundY + locHeight) + ' L ' + (pointerBoundX + rectWidth) + ' ' + locationY + ' A ' + topRadius + ' ' + topRadius + ', 0, 1, 0, ' + pointerBoundX + ' ' + locationY + ' z ';
          } else {
            var pointX = pointerType === 'Bar' && !options.IsInversed ? pointerBoundX - (options.ContainerWidth + options.ContainerWidth / 2 / Math.PI - bottomRadius) : pointerBoundX;
            var locWidth = pointerType === 'Bar' ? rectWidth - (topRadius - topRadius / Math.PI) : rectWidth;
            path = 'M' + pointX + ' ' + pointerBoundY + ' A ' + bottomRadius + ' ' + bottomRadius + ', 0, 1, 0, ' + pointX + ' ' + (pointerBoundY + rectHeight) + ' L ' + ((pointerType === 'Bar' ? pointerBoundX : pointX) + locWidth) + ' ' + (pointerBoundY + rectHeight) + ' A ' + topRadius + ' ' + topRadius + ', 0, 1, 0, ' + ((pointerType === 'Bar' ? pointerBoundX : pointX) + locWidth) + ' ' + pointerBoundY + ' z ';
          }
          break;
      }
      return path;
    };

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SfLinearGauge.prototype.calculateShapes = function (options, shape) {
      var path;
      var width = options.PointerWidth;
      var height = options.PointerHeight;
      var locationX = options.PointerBoundX;
      var locationY = options.PointerBoundY;
      var pointerPlacement = options.Placement;
      var isOpposedPosition = options.OpposedPosition;
      var orientation = options.Orientation;
      switch (shape) {
        case 'Diamond':
          locationX = orientation === 'Horizontal' ? locationX - width / 2 : !isOpposedPosition && pointerPlacement !== 'Far' || isOpposedPosition && pointerPlacement === 'Near' ? locationX - width : locationX;
          locationY = orientation === 'Vertical' ? locationY : !isOpposedPosition ? pointerPlacement === 'Far' ? locationY + height / 2 : locationY - height / 2 : pointerPlacement === 'Near' ? locationY - height / 2 : locationY + height / 2;
          path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + ' ' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + ' ' + (locationX + width) + ' ' + locationY + ' ' + 'L' + ' ' + (locationX + width / 2) + ' ' + (locationY + height / 2) + ' ' + 'L' + ' ' + locationX + ' ' + locationY + ' z';
          break;
        case 'Triangle':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX - width) + ' ' + (locationY - height / 2) + 'L' + (locationX - width) + ' ' + (locationY + height / 2) + ' Z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height) + 'L' + (locationX - width / 2) + ' ' + (locationY - height) + ' Z';
          }
          break;
        case 'InvertedTriangle':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width) + ' ' + (locationY - height / 2) + 'L' + (locationX + width) + ' ' + (locationY + height / 2) + ' Z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height) + 'L' + (locationX - width / 2) + ' ' + (locationY + height) + ' Z';
          }
          break;
        case 'Arrow':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX - width) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX - width) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2) + 'z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY - height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY - height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY - height / 2) + 'z';
          }
          break;
        case 'InvertedArrow':
          if (orientation === 'Vertical') {
            path = 'M' + ' ' + locationX + ' ' + locationY + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX + width) + ' ' + (locationY - height / 2 + height / 4) + ' ' + 'L' + (locationX + width) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2 - height / 4) + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2) + 'z';
          } else {
            path = 'M' + ' ' + locationX + ' ' + locationY + ' ' + 'L' + (locationX + width / 2) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX + width / 2 - width / 4) + ' ' + (locationY + height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY + height) + ' ' + 'L' + (locationX - width / 2 + width / 4) + ' ' + (locationY + height / 2) + ' ' + 'L' + (locationX - width / 2) + ' ' + (locationY + height / 2) + 'z';
          }
          break;
      }
      return path;
    };
    return SfLinearGauge;
  }();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var LinearGauge = {
    initialize: function initialize(element, options, dotnetRef, style, allowAnimation) {
      var instance = new SfLinearGauge(element.id, element, options, dotnetRef);
      instance.render();
      if (!sf.base.isNullOrUndefined(style)) {
        element.setAttribute('style', style);
      }
      if (allowAnimation) {
        this.createAnimationProcess(element.id, allowAnimation);
      }
      return this.getElementSize(element.id);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementSize: function getElementSize(id) {
      var elementWidth;
      var elementHeight;
      var element = document.getElementById(id);
      if (element != null) {
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width;
        elementHeight = elementRect.height;
      }
      return {
        width: elementWidth,
        height: elementHeight,
        isIE: sf.base.Browser.isIE
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    pointerAnimationProcess: function pointerAnimationProcess(id, options, pointerCount) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.isResized = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var pointerOptions = JSON.parse(options.animationSettings);
        for (var i = 0; i < pointerCount; i++) {
          instance.pointerAnimation(pointerOptions[i], id, false, 0, true);
        }
      }
    },
    createAnimationProcess: function createAnimationProcess(id, allowAnimation) {
      var element = document.getElementById(id + '_create_Animation');
      if (allowAnimation && sf.base.isNullOrUndefined(element)) {
        var styleClass_1 = document.createElement('style');
        styleClass_1.className = id + '_Animation';
        styleClass_1.innerText = '.' + id + '_Animation' + '{opacity: 0}';
        styleClass_1.id = id + '_create_Animation';
        document.body.appendChild(styleClass_1);
      }
    },
    animationProcess: function animationProcess(id, duration, allowAnimation, axesOptions, pointerOptions, pointerCount, totalAnimationDuration) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.allowAnimation = allowAnimation;
        var axes = JSON.parse(axesOptions.axisAnimation);
        instance.animationProcess(id, duration, allowAnimation, axes, pointerOptions, pointerCount, totalAnimationDuration);
      }
    },
    cancelAnimation: function cancelAnimation(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.allowAnimation = false;
      }
    },
    setPathAttribute: function setPathAttribute(id, type, path, x, y, orientation) {
      var pathElement = document.getElementById(id);
      if (type === '') {
        pathElement.setAttribute('d', path);
      } else if (type == 'Circle') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('cx', x.toString());
        } else {
          pathElement.setAttribute('cy', y.toString());
        }
      } else if (type == 'Rectangle' || type == 'Image') {
        if (orientation == "Horizontal") {
          pathElement.setAttribute('x', x.toString());
        } else {
          pathElement.setAttribute('y', y.toString());
        }
      } else {
        pathElement.setAttribute('x', x.toString());
        pathElement.setAttribute('y', y.toString());
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateCollection: function updateCollection(id, collection) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.enableDragCollection = JSON.parse(collection.enableDragCollection);
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementBounds: function getElementBounds(id) {
      var htmlElement = document.getElementById(id);
      if (htmlElement) {
        var bounds = htmlElement.getBoundingClientRect();
        return {
          width: bounds.width,
          height: bounds.height,
          top: bounds.top,
          bottom: bounds.bottom,
          left: bounds.left,
          right: bounds.right
        };
      }
      return null;
    },
    dispose: function dispose(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.destroy();
      }
    }
  };
  return LinearGauge;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sflineargauge');})})();