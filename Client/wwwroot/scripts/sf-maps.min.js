(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["sf-maps"],{

/***/ "./bundles/sf-maps.js":
/*!****************************!*\
  !*** ./bundles/sf-maps.js ***!
  \****************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_maps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-maps.js */ "./modules/sf-maps.js");
/* harmony import */ var _modules_sf_maps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_maps_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./modules/sf-maps.js":
/*!****************************!*\
  !*** ./modules/sf-maps.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Maps = function () {
  'use strict';

  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  /* eslint-disable no-case-declarations */
  /* eslint-disable radix */
  /* eslint-disable @typescript-eslint/no-unused-vars */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  /* eslint-disable camelcase */
  /* eslint-disable @typescript-eslint/no-this-alias */
  /* eslint-disable max-len */
  /**
   * Maps Blazor introp module
   */
  var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  var MapLocation = /** @class */function () {
    function MapLocation(x, y) {
      this.x = x;
      this.y = y;
    }
    return MapLocation;
  }();
  /**
   *
   * @param {string} id Specifies the string
   * @returns {Element} Returns the element
   */
  function createGroup(id) {
    var group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.setAttribute('id', id);
    return group;
  }
  /**
   *
   * @param {any} shape Specifies the shape
   * @param {Size} size Specifies the size
   * @param {MapLocation} location Specifies the location
   * @returns {string} Returns the string
   */
  function calculateShape(shape, size, location) {
    var path = '';
    switch (shape) {
      case 'Balloon':
        path = 'M15,0C8.8,0,3.8,5,3.8,11.2C3.8,17.5,9.4,24.4,15,30c5.6-5.6,11.2-12.5,11.2-18.8C26.2,5,21.2,0,15,0z M15,16' + 'c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S17.8,16,15,16z';
        break;
      case 'Cross':
        path = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;
        break;
      case 'Diamond':
        path = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + location.y + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + location.y + ' Z';
        break;
      case 'Star':
        path = 'M ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x - size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' Z';
        break;
      case 'Triangle':
        path = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 2) + ' Z';
        break;
      case 'HorizontalLine':
        path = ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;
        break;
      case 'VerticalLine':
        path = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2);
        break;
      case 'InvertedTriangle':
        path = 'M ' + (location.x - size.width / 2) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' Z';
        break;
      case 'Pentagon':
        var factor = 72;
        var xValue = void 0;
        var yValue = void 0;
        for (var i = 0; i < 5; i++) {
          xValue = size.width / 2 * Math.cos(Math.PI / 180 * (i * factor));
          yValue = size.height / 2 * Math.sin(Math.PI / 180 * (i * factor));
          path += (i === 0 ? 'M ' : 'L ') + (location.x + xValue) + ' ' + (location.y + yValue);
        }
        path += ' Z';
        break;
    }
    return path;
  }
  var SfMaps = /** @class */function () {
    function SfMaps(id, element, options, dotnetRef) {
      this.previousMarkerId = '';
      this.previousId = '';
      this.moveClientX = 0;
      this.moveClientY = 0;
      this.clientX = 0;
      this.clientY = 0;
      this.isPinch = false;
      this.enableSelectionZoom = false;
      this.allowPanning = false;
      this.isPanning = false;
      this.isPan = true;
      this.zoomClick = false;
      this.mouseClick = false;
      this.position = null;
      this.height = 0;
      this.width = 0;
      this.mapsBorderWidth = 0;
      this.toolbarButtonOpacity = 1;
      this.toolbarShapeOpacity = 1;
      this.markerClusterExpandCheck = false;
      this.svgCreated = false;
      this.zoomIn = 1;
      this.zoomOut = 1;
      this.scaleFactor = 1;
      this.factorCount = 0;
      this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      this.lastScale = 1;
      this.clusterLocation = [];
      this.isTouch = false;
      this.touchMoveList = [];
      this.touchStartList = [];
      this.tileTranslatePoint = null;
      this.isToolbarTooltip = false;
      this.marginTop = 0;
      this.marginLeft = 0;
      this.isPinchZoomed = false;
      this.panComplete = false;
      this.pinchComplete = false;
      this.mouseMoveId = '';
      this.isReset = false;
      window.sfBlazor = window.sfBlazor;
      this.tapCount = 0;
      this.isMarkerDrag = false;
      this.allowMarkerDragStartEvent = false;
      this.id = id;
      this.element = element;
      this.dotNetRef = dotnetRef;
      this.layerCount = options.layerCount;
      this.clusterSettings = options.markerCluster ? JSON.parse(options.markerCluster) : null;
      this.dataSource = options.dataSource ? JSON.parse(options.dataSource) : null;
      this.polygonDataSource = options.polygonDataSource ? JSON.parse(options.polygonDataSource) : null;
      this.shapeTranslatePoint = options.shapeTranslatePoint ? options.shapeTranslatePoint : null;
      this.shapeBorderWidth = options.shapeBorderWidth;
      this.projectionType = options.projectionType;
      this.options = options;
      this.options.layerHighlightSettings = JSON.parse(this.options.layerHighlightSettings);
      this.options.markerHighlightSettings = JSON.parse(this.options.markerHighlightSettings);
      this.options.bubbleHighlightSettings = JSON.parse(this.options.bubbleHighlightSettings);
      this.options.navigationHighlightSettings = JSON.parse(this.options.navigationHighlightSettings);
      this.options.polygonHighlightSettings = JSON.parse(this.options.polygonHighlightSettings);
      this.options.selectionSettings = JSON.parse(this.options.selectionSettings);
      this.marginLeft = 0;
      this.urlTemplate = options.urlTemplate ? options.urlTemplate : null;
      this.isToolbarTooltip = false;
      this.isTouch = false;
      this.pinchFactor = 1;
      this.lastScale = 1;
      this.touchStartList = [];
      this.touchMoveList = [];
      this.dataId = id;
      window.sfBlazor.setCompInstance(this);
    }
    SfMaps.prototype.wireEvents = function () {
      sf.base.EventHandler.add(this.element, 'wheel', this.mapMouseWheel.bind(this), this);
      sf.base.EventHandler.add(this.element, 'touchmove mousemove', this.mouseMove.bind(this), this);
      sf.base.EventHandler.add(this.element, 'touchend mouseup mouseleave', this.mouseUp.bind(this), this);
      sf.base.EventHandler.add(this.element, 'touchstart mousedown', this.mouseDown.bind(this), this);
      sf.base.EventHandler.add(this.element, 'click pointerdown', this.click.bind(this), this);
      sf.base.EventHandler.add(this.element, 'dblclick', this.doubleClick.bind(this), this);
      sf.base.EventHandler.add(this.element, 'contextmenu', this.rightClick.bind(this), this);
      sf.base.EventHandler.add(this.element, 'keydown', this.keyDown.bind(this), this);
      sf.base.EventHandler.add(this.element, 'keyup', this.keyUp.bind(this), this);
      window.addEventListener('resize', this.reSize.bind(this));
    };
    SfMaps.prototype.unwireEvents = function () {
      sf.base.EventHandler.remove(this.element, 'wheel', this.mapMouseWheel);
      sf.base.EventHandler.remove(this.element, 'touchmove mousemove', this.mouseMove);
      sf.base.EventHandler.remove(this.element, 'touchend mouseup mouseleave', this.mouseUp);
      sf.base.EventHandler.remove(this.element, 'touchstart mousedown', this.mouseDown);
      sf.base.EventHandler.remove(this.element, 'click pointerdown', this.click);
      sf.base.EventHandler.remove(this.element, 'dblclick', this.doubleClick);
      sf.base.EventHandler.remove(this.element, 'contextmenu', this.rightClick);
      sf.base.EventHandler.remove(this.element, 'keydown', this.keyDown);
      sf.base.EventHandler.remove(this.element, 'keyup', this.keyUp);
      window.removeEventListener('resize', this.reSize.bind(this));
    };
    SfMaps.prototype.destroy = function () {
      this.unwireEvents();
      this.dotNetRef = null;
    };
    SfMaps.prototype.keyUp = function (event) {
      var id = event.target['id'];
      if (this.options['enablePanning'] && this.isPanning) {
        this.isPanning = false;
        var animatedTiles = document.getElementById(this.element.id + '_animated_tiles');
        if (this.isTileMap && !sf.base.isNullOrUndefined(this.currentTiles) && !sf.base.isNullOrUndefined(animatedTiles) && this.currentTiles.childElementCount != animatedTiles.childElementCount && this.currentTiles.childElementCount < animatedTiles.childElementCount) {
          for (var i = animatedTiles.childElementCount - 1; i >= this.currentTiles.childElementCount; i--) {
            animatedTiles.removeChild(animatedTiles.children[i]);
          }
        }
        this.currentTiles = null;
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('UpdateTranslatePoint', this.isTileMap ? this.translatePoint : this.shapeTranslatePoint, this.tileTranslatePoint, this.scaleFactor, false);
        }
      }
      if (event.code === 'Tab') {
        if (id.indexOf('_LayerIndex_') > -1) {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          if (id.indexOf('shapeIndex') > -1) {
            this.targetElementPath = event.target;
            var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
            if (id.indexOf('shapeIndex') > -1 && this.options.layerHighlightSettings[layerIndex] && this.options.layerHighlightSettings[layerIndex].Enable) {
              this.removeAllHighlight();
              if (!this.targetElementPath.classList.contains('mapShapeSelection') && !sf.base.isNullOrUndefined(this.dotNetRef)) {
                this.dotNetRef.invokeMethodAsync('TriggerShapeHighlight', layerIndex, shapeIndex, id);
              }
            }
          }
        }
      }
    };
    SfMaps.prototype.triggerEnableZoom = function (factor, zoomType, eventType) {
      if (factor >= 1) {
        this.scaleFactor = factor;
        this.removeCluster();
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerZoom', zoomType, eventType);
        }
      }
    };
    SfMaps.prototype.keyDown = function (event) {
      var factor = 1;
      var zoomType;
      var eventType = event.type;
      var id = event.target['id'];
      this.isReset = false;
      var animatedTiles = document.getElementById(this.element.id + '_animated_tiles');
      if (this.isTileMap && !sf.base.isNullOrUndefined(animatedTiles)) {
        this.currentTiles = animatedTiles.cloneNode(true);
      }
      if (event.key === '+' || event.code === 'Equal') {
        if (this.options.enableZoom) {
          event.preventDefault();
          this.mergeSeparation();
          factor = this.factorCount === 0 ? this.options.factor + 1 : this.scaleFactor + 1;
          this.factorCount++;
          this.triggerEnableZoom(factor, 'ZoomIn', eventType);
        }
      } else if (event.key === '-' || event.code === 'Minus') {
        if (this.options.enableZoom) {
          event.preventDefault();
          this.mergeSeparation();
          factor = this.factorCount === 0 ? this.options.factor - 1 : this.scaleFactor - 1;
          factor = this.options.maxZoom >= factor && this.options.minZoom <= factor ? factor : this.options.minZoom;
          this.factorCount++;
          this.triggerEnableZoom(factor, 'ZoomOut', eventType);
        }
      } else if (event['keyCode'] === 82) {
        if (this.options.enableZoom) {
          event.preventDefault();
          this.mergeSeparation();
          this.zoomClick = false;
          zoomType = 'Reset';
          this.enableSelectionZoom = false;
          this.isReset = true;
          this.scaleFactor = factor = this.options.minZoom;
          this.removeCluster();
          if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
            this.dotNetRef.invokeMethodAsync('TriggerZoom', zoomType, eventType);
          }
        }
      } else if ((event.code === 'ArrowUp' || event.code === 'ArrowDown') && this.options['enablePanning']) {
        this.isPanning = true;
        event.preventDefault();
        this.mergeSeparation();
        this.moveClientY = this.areaRect.height / 7;
        this.clientX = 0;
        this.panning(this.clientX, event.code === 'ArrowUp' ? -this.moveClientY : this.moveClientY, event['layerX'], event['layerY'], this.scaleFactor, true);
        this.clientY = this.moveClientY;
      } else if ((event.code === 'ArrowLeft' || event.code === 'ArrowRight') && this.options['enablePanning']) {
        this.isPanning = true;
        event.preventDefault();
        this.mergeSeparation();
        this.clientY = 0;
        this.moveClientX = this.areaRect.width / 7;
        this.panning(event.code === 'ArrowLeft' ? -this.moveClientX : this.moveClientX, this.clientY, event['layerX'], event['layerY'], this.scaleFactor, true);
        this.clientX = this.moveClientX;
      } else if (event.code === 'Enter') {
        event.preventDefault();
        if ((id.indexOf('_Left_Page_Rect') > -1 || id.indexOf('_Right_Page_Rect') > -1) && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          var textContent = document.getElementById(this.id + "_Paging_Text").textContent;
          textContent = textContent.trim().replace("\n", "");
          var text = textContent.split("/").map(Number);
          if (id.indexOf('_Left_Page_Rect') > -1) {
            document.getElementById(id).style.outlineColor = text[0] + 1 != text[1] ? "" : "transparent";
          } else {
            document.getElementById(id).style.outlineColor = text[0] != text[1] + 1 ? "" : "transparent";
          }
          this.dotNetRef.invokeMethodAsync('TriggerLegendPaging', id.indexOf('_Left_Page_Rect') > -1 ? 1 : 0);
        } else if (id.indexOf('_LayerIndex_') > -1 && id.indexOf('shapeIndex') > -1) {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          this.shapeSelection(id, layerIndex);
        }
      }
      this.setToolbarButtonColor(factor, this.isReset ? this.element.id + '_Zooming_' : this.mouseMoveId);
      if (!sf.base.Browser.isDevice) {
        this.setToolbarButtonColor(factor, this.mouseMoveId);
      }
      this.clientX = this.moveClientX;
      this.clientY = this.moveClientY;
    };
    SfMaps.prototype.shapeSelection = function (id, layerIndex) {
      var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
      var dataIndex = id.indexOf('_dataIndex_') !== -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : null;
      if (this.options.selectionSettings && this.options.selectionSettings[layerIndex] && this.options.selectionSettings[layerIndex]['Enable']) {
        this.removeAllHighlight();
      }
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.dotNetRef.invokeMethodAsync('SelectMap', id, layerIndex, shapeIndex, 'Shape', dataIndex);
      }
    };
    SfMaps.prototype.rightClick = function (event) {
      var id = event.target['id'];
      var clientValue = this.getMousePosition(event.pageX, event.pageY);
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.dotNetRef.invokeMethodAsync('TriggerMouseClick', clientValue.x, clientValue.y, document.getElementById(id), event['layerX'], event['layerY']);
      }
    };
    SfMaps.prototype.reSize = function () {
      this.mergeSeparation();
      var width;
      var height;
      var tileElement;
      var secondaryElement;
      var svgIndex;
      if (this.element !== null) {
        var svgElement = document.getElementById(this.element.id + '_svg');
        if (!sf.base.isNullOrUndefined(svgElement)) {
          svgElement.style.display = 'none';
          if (this.isTileMap) {
            tileElement = document.getElementById(this.element.id + '_tile_parent');
            tileElement.style.display = 'none';
            secondaryElement = document.getElementById(this.element.id + '_Secondary_Element');
            secondaryElement.style.display = 'none';
            for (var i = 0; i < this.element.children.length; i++) {
              if (this.element.children[i].id === this.element.id + '_svg') {
                this.element.children[i].style.display = 'none';
                svgIndex = i;
              }
            }
          }
          var elementRect = this.element.getBoundingClientRect();
          width = elementRect.width;
          height = elementRect.height;
          svgElement.style.removeProperty('display');
          if (!sf.base.isNullOrUndefined(tileElement)) {
            tileElement.style.removeProperty('display');
            secondaryElement.style.removeProperty('display');
            this.element.children[svgIndex].style.removeProperty('display');
          }
        }
      }
      if (this.previousHeight !== height || this.previousWidth !== width) {
        this.previousHeight = height;
        this.previousWidth = width;
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerResize', width, height);
        }
      }
    };
    SfMaps.prototype.doubleClick = function (event) {
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        if (event.detail === 2 && this.options.enableZoom && this.options.doubleClickZoom) {
          var parentElement = document.getElementById(this.id).getBoundingClientRect();
          var factor = this.scaleFactor + 1;
          if (factor >= 1) {
            this.scaleFactor = factor;
            this.removeCluster();
            this.dotNetRef.invokeMethodAsync('MouseWheelZoom', event.pageX - parentElement['x'], event.pageY - parentElement['y'], event.which, 'doubleClick');
          }
        }
        var id = event.target['id'];
        var clientValue = this.getMousePosition(event.pageX, event.pageY);
        if (this.options.tooltipDisplayMode === 'DoubleClick') {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          if (id.indexOf('shapeIndex') > -1) {
            var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
            this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, shapeIndex, 'Shape', 0);
          } else if (id.indexOf('_MarkerIndex_') > -1 && id.indexOf('_cluster_') === -1) {
            var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
            var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
            this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, dataIndex, 'Marker', markerIndex);
          } else if (id.indexOf('_BubbleIndex_') > -1) {
            var markerIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
            var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
            this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, dataIndex, 'Bubble', markerIndex);
          } else if (id.indexOf('_shapeIndex_') === -1 && id.indexOf('_MarkerIndex_') === -1 && id.indexOf('_BubbleIndex_') === -1) {
            this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
          }
        }
        this.dotNetRef.invokeMethodAsync('TriggerDoubleClick', clientValue.x, clientValue.y, document.getElementById(id), event['layerX'], event['layerY']);
      }
    };
    SfMaps.prototype.mapMouseWheel = function (event) {
      this.mergeSeparation();
      var parentElement = document.getElementById(this.element.id).getBoundingClientRect();
      var delta = !sf.base.isNullOrUndefined(event['wheelDelta']) ? event['wheelDelta'] : -event['deltaY'];
      var direction = delta / 120 > 0 ? 'ZoomIn' : 'ZoomOut';
      var factor = direction === 'ZoomIn' ? this.scaleFactor + 1 : this.scaleFactor - 1;
      var isMousewheelProcess = factor == 0;
      this.scaleFactor = factor = this.options.maxZoom >= factor && this.options.minZoom <= factor ? factor : factor > this.options.maxZoom ? this.options.maxZoom : this.options.minZoom;
      this.isReset = false;
      this.setToolbarButtonColor(factor, sf.base.Browser.isDevice ? this.element.id + '_Zooming_' : event.target['id']);
      var position = this.getMousePosition(event.pageX, event.pageY);
      if (this.options.enableZoom && this.options.enableMouseWheelZoom && factor >= 1 && !isMousewheelProcess) {
        event.preventDefault();
        this.scaleFactor = factor;
        this.removeCluster();
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('MouseWheelZoom', position.x, position.y, delta, 'wheelZoom');
        }
      }
    };
    SfMaps.prototype.getGeoLocation = function (pageX, pageY, layerIndex) {
      var factor = this.calculateFactor(layerIndex);
      var translatePointX = this.shapeTranslatePoint.x * this.scaleFactor;
      var translatePointY = this.shapeTranslatePoint.y * this.scaleFactor;
      var mapSize = Math.min(this.areaRect.height, this.areaRect.width) * factor * this.scaleFactor;
      var x1 = Math.min(Math.max(pageX - translatePointX, 0), mapSize - 1) / mapSize - 0.5;
      var y1 = 0.5 - Math.min(Math.max(pageY - translatePointY, 0), mapSize - 1) / mapSize;
      var lat = 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;
      var lng = 360 * x1;
      return {
        latitude: lat,
        longitude: lng
      };
    };
    SfMaps.prototype.getClickLocation = function (pageX, pageY) {
      var latLongValue = null;
      if (!this.isTileMap && this.geometryType[this.markerDragArgument.layerIndex] === "Normal") {
        if (!sf.base.isNullOrUndefined(this.markerDragArgument)) {
          var factor = this.calculateFactor(this.markerDragArgument.layerIndex);
          var element = document.getElementById(this.element.id + '_LayerIndex_' + this.markerDragArgument.layerIndex);
          var elementRect = element.getBoundingClientRect();
          var location_1 = {
            x: pageX + this.positionX > elementRect.left ? Math.abs(elementRect.left - (pageX + this.positionX)) : 0,
            y: pageY + this.positionY > elementRect.top ? Math.abs(elementRect.top - (pageY + this.positionY)) : 0
          };
          var minLongitude = Math.abs(-this.baseMapBounds.longitudeMin * factor);
          var minLatitude = Math.abs(this.baseMapBounds.latitudeMax * factor);
          latLongValue = {
            latitude: Math.abs(this.baseMapBounds.latitudeMax - location_1.y / (factor * this.scaleFactor)),
            longitude: Math.abs(location_1.x / (factor * this.scaleFactor) + this.baseMapBounds.longitudeMin)
          };
          if (this.baseMapBounds.longitudeMin < 0 && minLongitude > location_1.x) {
            latLongValue.longitude = -latLongValue.longitude;
          }
          if (this.baseMapBounds.latitudeMin < 0 && minLatitude > location_1.y) {
            latLongValue.latitude = -latLongValue.latitude;
          }
        }
      }
      return this.isTileMap ? this.pointToLatLong(pageX - this.areaRect.x, pageY - this.areaRect.y) : !sf.base.isNullOrUndefined(latLongValue) ? latLongValue : this.getGeoLocation(pageX, pageY, this.markerDragArgument.layerIndex);
    };
    SfMaps.prototype.getMarkerClickLocation = function (pageX, pageY, x, y, isDragEnd) {
      var marker = this.markerDragArgument;
      var factor = this.calculateFactor(marker.layerIndex);
      var element = document.getElementById(marker.targetId);
      this.changeCursorPointer(marker.targetId);
      var latLongValue = this.getClickLocation(pageX, pageY);
      var location = this.isTileMap ? this.convertTileLatLongToPoint({
        x: latLongValue.longitude,
        y: latLongValue.latitude
      }, this.tileZoomLevel, this.tileTranslatePoint, true) : this.convertGeoToPoint(latLongValue.latitude, latLongValue.longitude, factor, marker.layerIndex);
      var transPoint = this.shapeTranslatePoint;
      var translateX = this.isTileMap ? location.x : (location.x + transPoint.x) * this.scaleFactor;
      var translateY = this.isTileMap ? location.y : (location.y + transPoint.y) * this.scaleFactor;
      var markerSettings = this.markerSettings[marker.layerIndex][marker.markerIndex];
      if (this.dataSource[marker.layerIndex][marker.markerIndex][marker.dataIndex][this.markerSettings[marker.layerIndex][marker.markerIndex].ShapeValuePath] === "Balloon" || markerSettings.Type == "Balloon") {
        element.setAttribute('transform', 'translate( ' + (translateX - markerSettings.Width / 2) + ' ' + (translateY - markerSettings.Height) + ' )' + 'scale(' + markerSettings.Width / 30 + ' ' + markerSettings.Height / 30 + ' ' + ')');
      } else if (this.dataSource[marker.layerIndex][marker.markerIndex][marker.dataIndex][this.markerSettings[marker.layerIndex][marker.markerIndex].ShapeValuePath] === "Rectangle" || markerSettings.Type == "Rectangle") {
        element.setAttribute('transform', 'translate( ' + (translateX - markerSettings.Width / 2) + ' ' + (translateY - markerSettings.Height / 2) + ' )');
      } else {
        element.setAttribute('transform', 'translate( ' + translateX + ' ' + translateY + ' )');
      }
      if (isDragEnd) {
        var latLongValue_1 = this.getClickLocation(pageX - markerSettings.X, pageY - markerSettings.Y);
        this.dotNetRef.invokeMethodAsync('TriggerMarkerDragEnd', this.markerDragArgument.layerIndex, this.markerDragArgument.markerIndex, this.markerDragArgument.dataIndex, pageX, pageY, latLongValue_1.latitude, latLongValue_1.longitude);
      }
    };
    SfMaps.prototype.changeCursorPointer = function (id) {
      if (id.indexOf('_MarkerIndex_') > -1 && id.indexOf('_LayerIndex_') > -1 && !(id.indexOf('cluster') > -1)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
        if (this.markerSettings[layerIndex][markerIndex].EnableDrag && sf.base.isNullOrUndefined(this.markerDragArgument)) {
          document.getElementById(this.element.id + "_svg").setAttribute("style", "cursor: pointer");
        } else if (this.markerSettings[layerIndex][markerIndex].EnableDrag && !sf.base.isNullOrUndefined(this.markerDragArgument)) {
          document.getElementById(this.element.id + "_svg").setAttribute("style", "cursor: grabbing");
        } else {
          document.getElementById(this.element.id + "_svg").setAttribute("style", "cursor: auto");
        }
      }
    };
    SfMaps.prototype.mouseUp = function (event) {
      var id = event.target['id'];
      var layerX;
      var layerY;
      var translatePoint = this.isTileMap ? this.tileTranslatePoint : this.shapeTranslatePoint;
      var touchCheck = false;
      this.lastScale = 1;
      if (event.type === 'touchend') {
        if (id.indexOf('LayerIndex') > -1 || this.options.enableZoom && (this.options.enablePinchZooming || this.options.enablePanning || this.enableSelectionZoom) || !sf.base.isNullOrUndefined(this.markerDragArgument)) {
          event.preventDefault();
        }
        this.moveClientX = layerX = event.changedTouches[0].pageX;
        this.moveClientY = layerY = event.changedTouches[0].pageY;
        touchCheck = true;
        this.isTouch = false;
        this.touchMoveList = [];
        this.touchStartList = [];
      } else {
        this.moveClientX = event.pageX;
        this.moveClientY = event.pageY;
        layerX = event['layerX'];
        layerY = event['layerY'];
      }
      var clientValue = this.getMousePosition(this.moveClientX, this.moveClientY);
      this.moveClientX = clientValue.x;
      this.moveClientY = clientValue.y;
      var parentId = id.split('_')[0];
      if (this.options.doubleClickZoom && event.type === 'touchend') {
        this.tapCount = this.tapCount > 1 ? 0 : this.tapCount + 1;
        var proxy_1 = this;
        if (sf.base.isNullOrUndefined(this.tapCountTimer)) {
          this.tapCountTimer = setTimeout(function () {
            window.clearTimeout(proxy_1.tapCountTimer);
            proxy_1.tapCountTimer = null;
            proxy_1.tapCount = 0;
          }, 1000);
        }
      }
      if (!(id.indexOf('_Zooming_') > -1) && this.options.enableZoom && !this.isPanning && event.type !== 'mouseleave' && (this.options.zoomOnClick || this.options.doubleClickZoom && event.type === 'touchend' && this.tapCount > 1) && !this.isPinch) {
        this.tapCount = 0;
        var factor = this.scaleFactor + (this.isPinchZoomed ? 0 : 1);
        if (factor >= 1) {
          this.scaleFactor = factor;
          this.removeCluster();
          var eventPageX = event.type === 'touchend' ? event.changedTouches[0].pageX : event.pageX;
          var eventPageY = event.type === 'touchend' ? event.changedTouches[0].pageY : event.pageY;
          var eventValues = this.getMousePosition(eventPageX, eventPageY);
          if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
            this.dotNetRef.invokeMethodAsync('MouseWheelZoom', eventValues.x, eventValues.y, event.type === 'touchend' ? 1 : event.which, this.options.zoomOnClick ? 'click' : 'doubleClick');
          }
        }
      }
      if (this.allowPanning && this.isPanning && this.options['enablePanning'] || this.isPinchZoomed) {
        var animatedTiles = document.getElementById(this.element.id + '_animated_tiles');
        if (this.isTileMap && this.isPinchZoomed) {
          animatedTiles.style.removeProperty('transform');
          this.scaleFactor = this.tileZoomLevel = Math.round(this.scaleFactor);
          this.getTileTranslatePosition(this.scaleFactor, this.scaleFactor, this.currentTouchCenter, null);
          this.translatePoint.x = (this.tileTranslatePoint.x - 0.01 * this.scaleFactor) / Math.pow(2, this.scaleFactor - 1);
          this.translatePoint.y = (this.tileTranslatePoint.y - 0.01 * this.scaleFactor) / Math.pow(2, this.scaleFactor - 1);
          this.generateTiles();
          this.renderMarkers();
        }
        if (this.isTileMap && !sf.base.isNullOrUndefined(this.currentTiles) && !sf.base.isNullOrUndefined(animatedTiles) && this.currentTiles.childElementCount != animatedTiles.childElementCount && this.currentTiles.childElementCount < animatedTiles.childElementCount) {
          for (var i = animatedTiles.childElementCount - 1; i >= this.currentTiles.childElementCount; i--) {
            animatedTiles.removeChild(animatedTiles.children[i]);
          }
        }
        this.currentTiles = null;
        if (!sf.base.isNullOrUndefined(this.dotNetRef) && !this.isPinchZoomed) {
          this.dotNetRef.invokeMethodAsync('UpdateTranslatePoint', this.isTileMap ? this.translatePoint : this.shapeTranslatePoint, this.tileTranslatePoint, this.scaleFactor, false);
          if (this.panComplete) {
            this.dotNetRef.invokeMethodAsync('TriggerPanningComplete', this.previousPoint.x, this.previousPoint.y, translatePoint.x, translatePoint.y, layerX, layerY, this.scaleFactor);
          }
        }
      }
      if (this.isPinchZoomed && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.dotNetRef.invokeMethodAsync('UpdateTranslatePoint', this.isTileMap ? this.translatePoint : this.shapeTranslatePoint, this.tileTranslatePoint, this.scaleFactor, true);
        if (this.pinchComplete) {
          this.dotNetRef.invokeMethodAsync('TriggerOnZoomComplete', translatePoint.x, translatePoint.y);
        }
      }
      this.isPanning = false;
      this.allowPanning = false;
      if (this.options.enableZoom && this.options.enableSelectionZooming && this.mouseClick && this.zoomClick) {
        this.svgCreated = false;
        this.mouseClick = false;
        var rectElement = document.getElementById(this.element.id + 'drawRect');
        if (rectElement) {
          rectElement.remove();
          this.mergeSeparation();
          this.removeCluster();
          var zoomFactor = 0;
          if (this.height > 0 && this.width > 0) {
            var size = this.element.getBoundingClientRect();
            if (!this.isTileMap) {
              zoomFactor = this.scaleFactor + Math.round((size.width / this.width + size.height / this.height) / 2);
            } else {
              zoomFactor = this.scaleFactor + Math.round(this.scaleFactor + (size.width / this.width + size.height / this.height) / 2);
              zoomFactor -= 2;
            }
            this.scaleFactor = zoomFactor;
          }
          this.setToolbarButtonColor(this.scaleFactor, this.element.id + "_Zooming_");
          if (zoomFactor >= 1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
            this.dotNetRef.invokeMethodAsync('TriggerZoomSelection', this.position.x, this.position.y, this.height, this.width);
          }
        }
      }
      if (id.indexOf('_LayerIndex_') > -1) {
        var dataIndex = void 0;
        var bubbleIndex = void 0;
        var navigationIndex = void 0;
        var polygonIndex = void 0;
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        if (id.indexOf('shapeIndex') > -1) {
          this.shapeSelection(id, layerIndex);
        }
        if (id.indexOf('_BubbleIndex_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          bubbleIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
          dataIndex = id.indexOf('_dataIndex_') !== -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : null;
          this.removeAllHighlight();
          this.dotNetRef.invokeMethodAsync('SelectMap', id, layerIndex, dataIndex, 'Bubble', bubbleIndex);
        }
        if (id.indexOf('_NavigationIndex_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          navigationIndex = parseInt(id.split('_NavigationIndex_')[1].split('_')[0], 10);
          dataIndex = id.indexOf('_Line_') !== -1 ? parseInt(id.split('_Line_')[1].split('_')[0], 10) : null;
          this.removeAllHighlight();
          this.dotNetRef.invokeMethodAsync('SelectMap', id, layerIndex, dataIndex, 'NavigationLine', navigationIndex);
        }
        if (id.indexOf('_PolygonIndex_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          polygonIndex = parseInt(id.split('_PolygonIndex_')[1].split('_')[0], 10);
          this.removeAllHighlight();
          this.dotNetRef.invokeMethodAsync('SelectMap', id, layerIndex, polygonIndex, 'Polygon', polygonIndex);
        }
        if (touchCheck && id.indexOf('MarkerIndex') > -1 && !(id.indexOf('cluster') > -1) && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          var layerIndex_1 = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
          dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
          this.dotNetRef.invokeMethodAsync('TriggerMouseLeave', layerIndex_1, markerIndex, dataIndex, layerX, layerY, touchCheck);
        }
      }
      var annotationElement = document.getElementById(this.element.id + '_AnnotationGroup');
      var isWithinAnnotation = !sf.base.isNullOrUndefined(annotationElement) && annotationElement.contains(event.target);
      if (!(id.indexOf('_Zooming_') > -1) && sf.base.isNullOrUndefined(this.markerDragArgument) && event.type !== 'mouseleave' && !this.isPinchZoomed && this.element.contains(event.target) && !sf.base.isNullOrUndefined(this.dotNetRef) && !isWithinAnnotation) {
        this.dotNetRef.invokeMethodAsync('TriggerClickEventArgs', false, clientValue.x, clientValue.y, this.getDomObject('Target', document.getElementById(id)), !sf.base.isNullOrUndefined(this.isTileMap) ? this.isTileMap : false);
      }
      if (!sf.base.isNullOrUndefined(this.markerDragArgument) && event.type !== 'mouseleave') {
        this.getMarkerClickLocation(this.moveClientX, this.moveClientY, layerX, layerY, true);
        this.dotNetRef.invokeMethodAsync('TriggerMouseMove', this.markerDragArgument.layerIndex, this.markerDragArgument.markerIndex, this.markerDragArgument.dataIndex, id, this.moveClientX, this.moveClientY, id.indexOf('cluster') > -1 ? 'cluster' : 'marker', touchCheck, false, false, layerX, layerY);
        this.markerDragArgument = null;
        this.changeCursorPointer(id);
        this.isMarkerDrag = true;
      }
      if (sf.base.Browser.isDevice || id.indexOf('Reset') > -1) {
        this.enableSelectionZoom = id.indexOf('Reset') > -1 ? false : this.enableSelectionZoom;
        this.isReset = id.indexOf('Reset') > -1;
        this.setToolbarButtonColor(id.indexOf('Reset') > -1 ? this.options.minZoom : this.scaleFactor, this.element.id + "_Zooming_");
      }
      this.isPinchZoomed = false;
    };
    SfMaps.prototype.getDomObject = function (value, element) {
      if (element != null) {
        // tslint:disable-next-line
        return window.sfBlazor.getDomObject(value, element);
      } else {
        return null;
      }
    };
    SfMaps.prototype.targetTouches = function (touches) {
      var targetTouches = [];
      for (var i = 0; i < touches.length; i++) {
        targetTouches.push({
          pageX: touches[i].pageX,
          pageY: touches[i].pageY
        });
      }
      return targetTouches;
    };
    SfMaps.prototype.mouseMove = function (event) {
      var id = event.target['id'];
      this.mouseMoveId = id;
      this.moveClientX = event.pageX;
      this.moveClientY = event.pageY;
      var layerX;
      var layerY;
      var translatePoint = this.isTileMap ? this.tileTranslatePoint : this.shapeTranslatePoint;
      var x;
      var y;
      var touchCheck = false;
      if (event.type === 'touchmove') {
        this.moveClientX = x = event['touches'][0].pageX;
        this.moveClientY = y = event['touches'][0].pageY;
        if (event['touches'].length === 2) {
          this.touchMoveList = this.targetTouches(event['touches']);
        }
        if (this.options.enableZoom && (this.options.enablePinchZooming || this.options.enablePanning || this.enableSelectionZoom) || !sf.base.isNullOrUndefined(this.markerDragArgument)) {
          event.preventDefault();
        }
        layerX = 0;
        layerY = 0;
        touchCheck = true;
      } else {
        this.moveClientX = event.pageX;
        this.moveClientY = event.pageY;
        x = event.clientX;
        y = event.clientY;
        layerX = event['layerX'];
        layerY = event['layerY'];
      }
      this.tooltipVisiblityChange();
      this.setToolbarButtonColor(this.scaleFactor, id);
      this.renderInteractiveLegend(id, event);
      var clientValue = this.getMousePosition(this.moveClientX, this.moveClientY);
      this.moveClientX = clientValue.x;
      this.moveClientY = clientValue.y;
      var parentId = id.split('_')[0];
      if (id.indexOf('_MapAreaBorder') == -1) {
        this.highlightMap(event);
      } else {
        this.removeAllHighlight();
      }
      if (this.options.enableZoom && this.options.enableSelectionZooming && this.mouseClick && this.zoomClick && this.options.maxZoom > this.options.factor && this.enableSelectionZoom) {
        event.preventDefault();
        if (!this.svgCreated) {
          this.startValue = this.svgPoint(this.svg, x, y);
          this.svgCreated = true;
        }
        this.position = this.svgPoint(this.svg, x, y);
        var svgElement = document.getElementById(this.element.id).getBoundingClientRect();
        this.width = Math.abs(this.position.x - this.startValue.x);
        this.height = Math.abs(this.position.y - this.startValue.y);
        if (this.position.x > this.startValue.x) {
          this.position.x = this.startValue.x;
        }
        if (this.position.y > this.startValue.y) {
          this.position.y = this.startValue.y;
        }
        this.position.x = this.position.x - svgElement['x'];
        this.position.y = this.position.y - svgElement['y'];
        rect.setAttributeNS(null, 'x', this.position.x.toString());
        rect.setAttributeNS(null, 'y', this.position.y.toString());
        rect.setAttributeNS(null, 'id', this.element.id + 'drawRect');
        rect.setAttributeNS(null, 'width', this.width.toString());
        rect.setAttributeNS(null, 'height', this.height.toString());
        rect.setAttributeNS(null, 'fill', this.options.rectangleZoomFillColor);
        rect.setAttributeNS(null, 'stroke-dasharray', '3');
        rect.setAttributeNS(null, 'opacity', this.options.rectangleZoomFillOpacity.toString());
        rect.setAttributeNS(null, 'stroke', this.options.rectangleZoomBorderColor);
        if (document.getElementById(this.element.id + '_tile_parent') !== null) {
          document.getElementById(this.element.id + '_LayerCollections').parentNode.appendChild(rect);
        } else {
          document.getElementById(this.element.id + '_svg').appendChild(rect);
        }
      }
      this.isPinch = false;
      if (this.options.enableZoom && this.options.enablePinchZooming && this.touchMoveList.length >= 2 && this.touchStartList.length >= 2) {
        this.isPinchZoomed = this.isPinch = true;
        if (!this.pinchComplete && !this.panComplete && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerOnZoom', translatePoint.x, translatePoint.y);
        }
        this.pinchZooming(event);
        this.pinchComplete = true;
      }
      if (sf.base.isNullOrUndefined(this.markerDragArgument) && this.allowPanning && this.options.enablePanning && (this.clientX !== this.moveClientX || this.clientY !== this.moveClientY) && !this.isPinchZoomed) {
        this.isPanning = true;
        if (!this.isTileMap) {
          var element = document.getElementById(this.element.id + '_LayerCollections');
          for (var i = 0; i < element.children.length; i++) {
            for (var j = 0; j < element.children[i].childElementCount; j++) {
              if (element.children[i].children[j].id.indexOf('Polygon_Group') > -1) {
                this.scaleFactor = element.children[i].children[j]['transform']['baseVal'][0]['matrix']['a'];
                break;
              }
            }
          }
          if (this.clientX !== this.moveClientX && this.clientY !== this.moveClientY) {
            var xDifference = this.clientX - this.moveClientX;
            var yDifference = this.clientY - this.moveClientY;
            var x_1 = translatePoint.x - xDifference / this.scaleFactor;
            var y_1 = translatePoint.y - yDifference / this.scaleFactor;
            if (!this.panComplete && !this.pinchComplete && !sf.base.isNullOrUndefined(this.dotNetRef)) {
              this.previousPoint = this.isTileMap ? this.tileTranslatePoint : this.shapeTranslatePoint;
              this.dotNetRef.invokeMethodAsync('TriggerPanning', translatePoint.x, translatePoint.y, x_1, y_1, layerX, layerY, this.scaleFactor);
            }
            this.panning(xDifference, yDifference, layerX, layerY, this.scaleFactor, false);
            this.panComplete = this.isTouch && this.touchMoveList.length === 2 && this.touchStartList.length === 2 ? false : true;
            this.clientX = this.moveClientX;
            this.clientY = this.moveClientY;
          }
        }
        if (id.indexOf(parentId) > -1) {
          var element = document.getElementById(event.currentTarget['id'] + '_animated_tiles');
          if (element !== null) {
            this.isTileMap = true;
            this.scaleFactor = parseInt(element['className'], 10);
            var xDifference = this.clientX - this.moveClientX;
            var yDifference = this.clientY - this.moveClientY;
            if (!this.panComplete && !sf.base.isNullOrUndefined(this.dotNetRef) && this.touchMoveList.length !== 2 && this.touchStartList.length !== 2) {
              this.previousPoint = this.isTileMap ? this.tileTranslatePoint : this.shapeTranslatePoint;
              this.dotNetRef.invokeMethodAsync('TriggerTilePanning', this.previousPoint.x, this.previousPoint.y, translatePoint.x, translatePoint.y, layerX, layerY, this.scaleFactor);
            }
            this.panning(xDifference, yDifference, layerX, layerY, this.scaleFactor, false);
            this.panComplete = this.isTouch && this.touchMoveList.length === 2 && this.touchStartList.length === 2 ? false : true;
            this.clientX = this.moveClientX;
            this.clientY = this.moveClientY;
          }
        }
      }
      if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
        if (!this.allowPanning && !(this.mouseClick && this.zoomClick)) {
          if (id.indexOf('shapeIndex') > -1 && this.options.tooltipDisplayMode === 'MouseMove') {
            var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
            var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
            this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, shapeIndex, 'Shape', 0);
          }
        }
        if ((id === '' || id.indexOf(this.element.id) === -1) && !sf.base.isNullOrUndefined(event.target['offsetParent'])) {
          var parentId_1 = event.target['offsetParent'].id;
          id = parentId_1.indexOf('_MarkerIndex_') > -1 ? parentId_1 : id;
        }
        if (id.indexOf("_MapAreaBorder") > -1 || id.indexOf("_MapMargin") > -1 || id == "" || id.indexOf("_svg") > -1 || this.isToolbarTooltip && id.indexOf('_Zooming_ToolBar_') > -1) {
          this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
        }
        this.isToolbarTooltip = false;
        if (id.indexOf('_Zooming_ToolBar_') > -1) {
          this.isToolbarTooltip = true;
          var text = id.split('_Zooming_ToolBar_')[1].split('_')[0];
          this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, 0, 0, text, 0);
        }
        this.renderTitleTooltip(id, clientValue, event);
        this.renderLegendTitleTooltip(id, clientValue, event);
        this.renderLegendTextTooltip(id, clientValue, event);
        if (!this.isMarkerDrag && id.indexOf('_LayerIndex_') > -1 && id.indexOf('_MarkerIndex_') > -1 || touchCheck && id.indexOf('MarkerIndex') > -1 && !(id.indexOf('cluster') > -1)) {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
          var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
          this.changeCursorPointer(id);
          this.dotNetRef.invokeMethodAsync('TriggerMouseMove', layerIndex, markerIndex, dataIndex, id, clientValue.x, clientValue.y, id.indexOf('cluster') > -1 ? 'cluster' : 'marker', touchCheck, !sf.base.isNullOrUndefined(this.markerDragArgument), true, layerX, layerY);
        }
        this.isMarkerDrag = false;
        if (id.indexOf('_LayerIndex_') > -1 && id.indexOf('_BubbleIndex_') > -1) {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var markerIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
          var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
          this.dotNetRef.invokeMethodAsync('TriggerBubbleMouseMove', layerIndex, markerIndex, dataIndex, id, clientValue.x, clientValue.y, layerX, layerY);
        }
        if (this.previousMarkerId.indexOf('_MarkerIndex_') > -1 && this.previousMarkerId != id) {
          var layerIndex = parseInt(this.previousMarkerId.split('_LayerIndex_')[1].split('_')[0], 10);
          var markerIndex = parseInt(this.previousMarkerId.split('_MarkerIndex_')[1].split('_')[0], 10);
          var dataIndex = parseInt(this.previousMarkerId.split('_dataIndex_')[1].split('_')[0], 10);
          this.dotNetRef.invokeMethodAsync('TriggerMouseLeave', layerIndex, markerIndex, dataIndex, layerX, layerY, touchCheck);
        }
      }
      if (!sf.base.isNullOrUndefined(this.markerDragArgument)) {
        this.getMarkerClickLocation(this.moveClientX, this.moveClientY, layerX, layerY, false);
        this.changeCursorPointer(id);
      } else if (!(id.indexOf('MarkerIndex') > -1)) {
        document.getElementById(this.element.id + "_svg").setAttribute("style", "cursor: auto");
      }
      this.previousMarkerId = id.indexOf('MarkerIndex') > -1 && !(id.indexOf('cluster') > -1) ? id : '';
    };
    SfMaps.prototype.removeInteractiveLegend = function () {
      var groupElement = document.getElementById(this.element.id + '_Interactive_Legend_Group');
      if (groupElement !== null) {
        groupElement.setAttribute('style', 'display: none;');
      }
    };
    SfMaps.prototype.renderInteractiveLegend = function (id, event) {
      var _this = this;
      if (!sf.base.isNullOrUndefined(this.legendSettings) && this.legendSettings.mode === 'Interactive' && id.indexOf('_LayerIndex') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var elementId = document.getElementById(event.target['id']);
        var fill = elementId.getAttribute('fill');
        if (id.indexOf('_shapeIndex') > -1 && this.legendSettings.type === 'Layers') {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
          var elementId_1 = document.getElementById(id);
          clearTimeout(this.arrowCountTimer);
          this.renderInteractive(fill, layerIndex, shapeIndex, 0);
          if (event.pointerType === 'touch') {
            this.arrowCountTimer = setTimeout(function () {
              _this.removeInteractiveLegend();
            }, 1500);
          }
        } else if (id.indexOf('_MarkerIndex_') > -1 && this.legendSettings.type === 'Markers') {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
          var dataIndex = id.indexOf('_dataIndex_') !== -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : null;
          clearTimeout(this.arrowCountTimer);
          this.renderInteractive(fill, layerIndex, markerIndex, dataIndex);
          if (event.pointerType === 'touch') {
            this.arrowCountTimer = setTimeout(function () {
              _this.removeInteractiveLegend();
            }, 1500);
          }
        } else if (id.indexOf('_BubbleIndex_') > -1 && this.legendSettings.type === 'Bubbles') {
          var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
          var bubbleIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
          var dataIndex = id.indexOf('_dataIndex_') !== -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : null;
          clearTimeout(this.arrowCountTimer);
          this.renderInteractive(fill, layerIndex, bubbleIndex, dataIndex);
          if (event.pointerType === 'touch') {
            this.arrowCountTimer = setTimeout(function () {
              _this.removeInteractiveLegend();
            }, 1500);
          }
        } else {
          this.removeInteractiveLegend();
        }
      } else if (!sf.base.isNullOrUndefined(this.legendSettings) && this.legendSettings.mode === 'Interactive' && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.removeInteractiveLegend();
      }
    };
    SfMaps.prototype.renderInteractive = function (fill, layerIndex, markerIndex, dataIndex) {
      for (var i = 0; i < this.legendDetails.length; i++) {
        var isBreak = false;
        for (var j = 0; j < this.legendDetails[i].length; j++) {
          var collection = this.legendDetails[i][j];
          if (this.legendSettings.type === 'Bubbles' && parseInt(collection['layerIndex']) === layerIndex && parseInt(collection['dataIndex']) === dataIndex || this.legendSettings.type === 'Markers' && parseInt(collection['layerIndex']) === layerIndex && parseInt(collection['dataIndex']) === dataIndex && parseInt(collection['settingIndex']) === markerIndex || this.legendSettings.type === 'Layers' && parseInt(collection['layerIndex']) === layerIndex && parseInt(collection['settingIndex']) === markerIndex) {
            var legendRect = this.getLegendRect(this.legendShapeCollection[i].ShapeId);
            if (!sf.base.isNullOrUndefined(legendRect)) {
              this.renderInteractivePointer(fill, legendRect);
            }
            isBreak = true;
            break;
          } else {
            this.removeInteractiveLegend();
          }
        }
        if (isBreak) {
          break;
        }
      }
    };
    SfMaps.prototype.getLegendRect = function (id) {
      var legendId = document.getElementById(id);
      var legendRect = legendId.getBoundingClientRect();
      var mapId = id.split('_Legend_')[0];
      var svgId = document.getElementById(mapId);
      var svgRect = svgId.getBoundingClientRect();
      return {
        x: legendRect.left - svgRect.left,
        y: legendRect.top - svgRect.top,
        width: legendRect.width,
        height: legendRect.height
      };
    };
    SfMaps.prototype.renderInteractivePointer = function (fill, rect) {
      var path;
      var locX;
      var locY;
      var height = 10;
      var width = 10;
      var direction = this.legendSettings.orientation === "None" ? this.legendSettings.position === "Top" || this.legendSettings.position === "Bottom" ? "Horizontal" : "Vertical" : this.legendSettings.orientation;
      rect.y = this.legendSettings.position === "Float" && this.isTileMap ? rect.y - this.baseMapBounds.mapsAreaRect.y : rect.y;
      if (direction === 'Horizontal') {
        locX = rect.x + rect.width / 2 - (this.legendSettings.position === "Float" && this.isTileMap ? this.baseMapBounds.mapsAreaRect.y : 0);
        var ydifference = 0;
        if (this.legendSettings.invertedPointer === "False") {
          locY = rect.y;
          ydifference = locY - height;
        } else {
          locY = rect.y + rect.height;
          ydifference = locY + height;
        }
        path = this.createInteractiveArrow(locX, locY, width, height, 0, ydifference, true);
      } else {
        locY = rect.y + rect.height / 2;
        var xdifference = 0;
        if (this.legendSettings.invertedPointer === "False") {
          locX = rect.x + rect.width - (this.legendSettings.position === "Float" && this.isTileMap ? this.baseMapBounds.mapsAreaRect.x : 0);
          xdifference = locX + width;
        } else {
          locX = rect.x - (this.legendSettings.position === "Float" && this.isTileMap ? this.baseMapBounds.mapsAreaRect.x : 0);
          xdifference = locX - width;
        }
        path = this.createInteractiveArrow(locX, locY, width, height, xdifference, 0, false);
      }
      var pathOptions = {
        d: path,
        id: this.element.id + '_Interactive_Legend',
        fill: fill,
        stroke: '#000000',
        opacity: 1,
        strokeWidth: 0
      };
      var groupElement = document.getElementById(this.element.id + '_Interactive_Legend_Group');
      if (groupElement === null) {
        groupElement = createGroup(this.element.id + '_Interactive_Legend_Group');
      }
      groupElement.setAttribute('style', 'display: block;');
      var pathEle = this.drawPath(pathOptions);
      var svgElement = document.getElementById(this.element.id + '_svg');
      groupElement.appendChild(pathEle);
      svgElement.appendChild(groupElement);
    };
    SfMaps.prototype.createInteractiveArrow = function (locX, locY, width, height, xdifference, ydifference, isHorizontal) {
      return "M " + locX + " " + locY + " L " + (isHorizontal ? locX - width : xdifference) + " " + (isHorizontal ? ydifference : locY - height) + " L " + (isHorizontal ? locX + width : xdifference) + " " + (isHorizontal ? ydifference : locY + height) + " Z";
    };
    SfMaps.prototype.renderTitleTooltip = function (id, clientValue, event) {
      var _this = this;
      if (id === this.element.id + '_Map_title' && event.target.textContent.indexOf('...') > -1 && !this.isPanning) {
        clearTimeout(this.tooltipCountTimer);
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '_Map_title', clientValue.x, clientValue.y, 0, 0, 'Title', 0);
        if (event.pointerType === 'touch') {
          this.tooltipCountTimer = setTimeout(function () {
            _this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
          }, 1500);
        }
      }
    };
    SfMaps.prototype.renderLegendTitleTooltip = function (id, clientValue, event) {
      var _this = this;
      if (id === this.element.id + '_LegendTitle' && event.target.textContent.indexOf('...') > -1 && !this.isPanning) {
        clearTimeout(this.tooltipCountTimer);
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '_LegendTitle', clientValue.x, clientValue.y, 0, 0, 'LegendTitle', 0);
        if (event.pointerType === 'touch') {
          this.tooltipCountTimer = setTimeout(function () {
            _this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
          }, 1500);
        }
      }
    };
    SfMaps.prototype.renderLegendTextTooltip = function (id, clientValue, event) {
      var _this = this;
      if (id.indexOf("_Legend_Text_Index_") > -1 && event.target.textContent.indexOf('...') > -1 && !this.isPanning) {
        clearTimeout(this.tooltipCountTimer);
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '_LegendText_', clientValue.x, clientValue.y, 0, parseInt(id.split("_Legend_Text_Index_")[1]), 'LegendText', 0);
        if (event.pointerType === 'touch') {
          this.tooltipCountTimer = setTimeout(function () {
            _this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
          }, 1500);
        }
      }
    };
    SfMaps.prototype.tooltipVisiblityChange = function () {
      if (sf.base.Browser.isDevice) {
        var proxy_2 = this;
        window.clearTimeout(proxy_2.tooltipCountTimer);
        this.tooltipCountTimer = setTimeout(function () {
          proxy_2.tooltipCountTimer = null;
          if (document.getElementById(proxy_2.element.id + "_Tooltip")) {
            document.getElementById(proxy_2.element.id + "_Tooltip").style.visibility = "hidden";
          }
        }, 2000);
      }
    };
    SfMaps.prototype.mouseDown = function (event) {
      this.isPinch = false;
      var id = event.target['id'];
      var finalFactor = this.options.factor + (id.indexOf('_ZoomIn_') > 1 && document.getElementById(this.element.id + '_Zooming_ToolBar_ZoomIn_Rect').getAttribute('stroke-opacity') !== '0.3' ? 1 : 0) + (id.indexOf('_ZoomOut_') > 1 && document.getElementById(this.element.id + '_Zooming_ToolBar_ZoomOut_Rect').getAttribute('stroke-opacity') !== '0.3' ? -1 : 0);
      finalFactor = id.indexOf('_Reset_') > 1 ? this.options.minZoom : finalFactor;
      this.isPinchZoomed = false;
      this.isTouch = false;
      this.panComplete = false;
      this.pinchComplete = false;
      this.currentTiles = null;
      this.isReset = false;
      var animatedTiles = document.getElementById(this.element.id + '_animated_tiles');
      if (this.isTileMap && !sf.base.isNullOrUndefined(animatedTiles)) {
        this.currentTiles = animatedTiles.cloneNode(true);
      }
      if (event.type === 'touchstart') {
        if (this.options.enableZoom && (this.options.enablePinchZooming || this.options.enablePanning || this.enableSelectionZoom || !sf.base.isNullOrUndefined(this.markerDragArgument))) {
          event.preventDefault();
        }
        this.clientX = event['touches'][0].pageX;
        this.clientY = event['touches'][0].pageY;
        if (event['touches'].length === 2) {
          this.touchStartList = this.targetTouches(event['touches']);
        }
        this.isTouch = true;
      } else {
        this.clientX = event.pageX;
        this.clientY = event.pageY;
      }
      this.tooltipVisiblityChange();
      var clientValue = this.getMousePosition(this.clientX, this.clientY);
      this.clientX = clientValue.x;
      this.clientY = clientValue.y;
      if (this.options.enableZoom && this.options.enableSelectionZooming && this.zoomClick) {
        this.mouseClick = true;
        event.preventDefault();
      }
      if (!this.mouseClick && id.indexOf('ToolBar_Pan') === -1) {
        if (id.indexOf('_MapAreaBorder') > -1 && this.options.enablePanning) {
          this.allowPanning = true;
        }
        if (!this.enableSelectionZoom && id.indexOf('') > -1 && !(id.indexOf('Zooming') > -1) && this.options.enablePanning) {
          this.allowPanning = true;
        }
      }
      if (id.indexOf('MarkerIndex') > -1 && !(id.indexOf('cluster') > -1) && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
        var dataIndex_1 = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
        var isCluster = false;
        if (!sf.base.isNullOrUndefined(this.clusterData) && this.clusterData.length > 0) {
          isCluster = this.clusterData[0].data.filter(function (el) {
            return el['index'] == dataIndex_1;
          }).length > 0 && this.clusterData[0].layerIndex === layerIndex && this.clusterData[0].markerIndex === markerIndex;
        }
        if (this.markerSettings[layerIndex][markerIndex].EnableDrag && !isCluster) {
          this.markerDragArgument = {
            layerIndex: layerIndex,
            markerIndex: markerIndex,
            dataIndex: dataIndex_1,
            latitude: this.dataSource[layerIndex][markerIndex][dataIndex_1]['Latitude'],
            longitude: this.dataSource[layerIndex][markerIndex][dataIndex_1]['Longitude'],
            targetId: id
          };
          if (this.allowMarkerDragStartEvent) {
            this.dotNetRef.invokeMethodAsync('TriggerMarkerDragStart', layerIndex, markerIndex, dataIndex_1, this.clientX, this.clientY);
          }
        }
      }
      if (id.indexOf('Reset') == -1) {
        this.setToolbarButtonColor(finalFactor, id);
      }
      if (id.indexOf('_Zoom_') > -1 && this.options.enableSelectionZooming && finalFactor > this.options.max) {
        this.removeZoomColor(this.toolbarSelection);
        this.removePanColor(this.toolbarColor);
      } else if (id.indexOf('_Pan_') > -1 && this.options.enablePanning && !this.options.isTileMap && finalFactor > 1) {
        this.removeZoomColor(this.toolbarColor);
        this.removePanColor(this.toolbarSelection);
      }
    };
    SfMaps.prototype.removeToolbarClass = function (zoomClassStyle, zoomInClassStyle, zoomOutClassStyle, panClassStyle, resetClassStyle) {
      if (this.getElementByID(this.element.id + '_Zooming_KitCollection')) {
        if (document.getElementById(this.element.id + '_Zooming_ToolBar_ZoomIn_Group')) {
          this.getElementByID(this.element.id + '_Zooming_ToolBar_ZoomIn_Group').setAttribute('class', zoomInClassStyle);
        }
        if (document.getElementById(this.element.id + '_Zooming_ToolBar_ZoomOut_Group')) {
          this.getElementByID(this.element.id + '_Zooming_ToolBar_ZoomOut_Group').setAttribute('class', zoomOutClassStyle);
        }
        if (document.getElementById(this.element.id + '_Zooming_ToolBar_Reset_Group')) {
          this.getElementByID(this.element.id + '_Zooming_ToolBar_Reset_Group').setAttribute('class', resetClassStyle);
        }
        if (document.getElementById(this.element.id + '_Zooming_ToolBar_Zoom_Group')) {
          this.getElementByID(this.element.id + '_Zooming_ToolBar_Zoom_Group').setAttribute('class', zoomClassStyle);
        }
        if (document.getElementById(this.element.id + '_Zooming_ToolBar_Pan_Group')) {
          this.getElementByID(this.element.id + '_Zooming_ToolBar_Pan_Group').setAttribute('class', panClassStyle);
        }
      }
    };
    SfMaps.prototype.setOpacity = function (circleId, pathId, circleOpacity, pathOpacity) {
      if (this.getElementByID(this.element.id + circleId)) {
        this.getElementByID(this.element.id + circleId).setAttribute('stroke-opacity', circleOpacity.toString());
        this.getElementByID(this.element.id + circleId).setAttribute('fill-opacity', circleOpacity.toString());
        this.getElementByID(this.element.id + pathId).setAttribute('stroke-opacity', pathOpacity.toString());
        this.getElementByID(this.element.id + pathId).setAttribute('fill-opacity', pathOpacity.toString());
      }
    };
    SfMaps.prototype.removeZoomOpacity = function (zoomOpacity, zoomStrokeOpacity, zoomInOpacity, zoomInStrokeOpacity, zoomOutOpacity, zoomOutStrokeOpacity, panOpacity, panStrokeOpacity, resetOpacity, resetStrokeOpacity) {
      this.setOpacity('_Zooming_ToolBar_Zoom_Rect', '_Zooming_ToolBar_Zoom_Path', zoomStrokeOpacity, zoomOpacity);
      this.setOpacity('_Zooming_ToolBar_ZoomIn_Rect', '_Zooming_ToolBar_ZoomIn_Path', zoomInStrokeOpacity, zoomInOpacity);
      this.setOpacity('_Zooming_ToolBar_ZoomOut_Rect', '_Zooming_ToolBar_ZoomOut_Path', zoomOutStrokeOpacity, zoomOutOpacity);
      this.setOpacity('_Zooming_ToolBar_Pan_Rect', '_Zooming_ToolBar_Pan_Path', panStrokeOpacity, panOpacity);
      this.setOpacity('_Zooming_ToolBar_Reset_Rect', '_Zooming_ToolBar_Reset_Path', resetStrokeOpacity, resetOpacity);
    };
    SfMaps.prototype.getElementByID = function (id) {
      return document.getElementById(id);
    };
    SfMaps.prototype.setToolbarButtonColor = function (factor, id) {
      if (document.getElementById(this.element.id + '_Zooming_KitCollection') && id.indexOf(this.element.id + '_Zooming_') > -1 && this.options.enableZoom) {
        document.getElementById(this.element.id + '_Zooming_KitCollection').setAttribute('opacity', '1');
        if (sf.base.Browser.isDevice) {
          this.removeToolbarClass('', '', '', '', '');
        } else {
          this.removeToolbarClass(this.options.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', 'e-maps-toolbar', this.options.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');
        }
        var toolbarShapeOpacity = this.toolbarShapeOpacity;
        var toolbarButtonOpacity = this.toolbarButtonOpacity;
        if (this.isTileMap && factor <= 1.2) {
          if (!sf.base.Browser.isDevice) {
            this.removeToolbarClass(this.options.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', '', this.options.enablePanning ? 'e-maps-toolbar' : '', '');
          }
          if (this.options.enablePanning) {
            this.removePanColor(this.toolbarSelection);
          }
          if (this.enableSelectionZoom && this.options.enableSelectionZooming && !this.isReset) {
            this.removeZoomColor(this.toolbarSelection);
            this.removePanColor(this.toolbarColor);
          }
          if (this.isReset) {
            this.removeZoomColor(this.toolbarColor);
            this.removePanColor(this.toolbarSelection);
          }
          this.removeZoomOpacity(this.options.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.options.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, this.options.enablePanning ? toolbarShapeOpacity : 0.3, this.options.enablePanning ? toolbarButtonOpacity : 0.3, 0.3, 0.3);
        } else if (factor <= 1.2) {
          if (!sf.base.Browser.isDevice) {
            this.removeToolbarClass(this.options.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', '', '', '');
          }
          if (!this.enableSelectionZoom && this.options.enablePanning) {
            this.removePanColor(this.toolbarColor);
          }
          if (this.enableSelectionZoom && this.options.enableSelectionZooming && !this.isReset) {
            this.removeZoomColor(this.toolbarSelection);
            this.removePanColor(this.toolbarColor);
          }
          if (this.isReset) {
            this.removeZoomColor(this.toolbarColor);
          }
          this.removeZoomOpacity(this.options.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.options.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3);
        } else if (factor < this.options.maxZoom) {
          if (!sf.base.Browser.isDevice) {
            this.removeToolbarClass(this.options.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', 'e-maps-toolbar', this.options.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');
          }
          this.removeZoomOpacity(this.options.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.options.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, this.options.enablePanning ? toolbarShapeOpacity : 0.3, this.options.enablePanning ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity);
          if (this.isReset || factor === this.options.minZoom) {
            this.removeZoomOpacity(this.options.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.options.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, this.options.enablePanning ? toolbarShapeOpacity : 0.3, this.options.enablePanning ? toolbarButtonOpacity : 0.3, 0.3, 0.3);
            this.removeToolbarClass(this.options.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', '', this.options.enablePanning ? 'e-maps-toolbar' : '', '');
          }
          if (this.enableSelectionZoom && this.options.enableSelectionZooming) {
            this.removeZoomColor(this.toolbarSelection);
            if (this.isPan && this.options.enablePanning) {
              this.removePanColor(this.toolbarColor);
            }
          } else if (!this.enableSelectionZoom && this.options.enablePanning) {
            this.removePanColor(this.toolbarSelection);
            if (this.options.enableSelectionZooming) {
              this.removeZoomColor(this.toolbarColor);
            }
          }
        } else {
          if (!sf.base.Browser.isDevice) {
            this.removeToolbarClass('', '', 'e-maps-toolbar', this.options.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');
          }
          this.removeZoomOpacity(0.3, 0.3, 0.3, 0.3, toolbarShapeOpacity, toolbarButtonOpacity, this.options.enablePanning ? toolbarShapeOpacity : 0.3, this.options.enablePanning ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity);
          if (this.options.enableSelectionZooming) {
            this.removeZoomColor(this.toolbarColor);
          }
          if (!this.enableSelectionZoom && this.options.enablePanning) {
            this.removePanColor(this.toolbarSelection);
          }
        }
      } else {
        if (!sf.base.Browser.isDevice) {
          this.removePanColor(this.toolbarColor);
          this.removeZoomColor(this.toolbarColor);
          this.removeZoomOpacity(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
          if (document.getElementById(this.element.id + '_Zooming_KitCollection')) {
            document.getElementById(this.element.id + '_Zooming_KitCollection').setAttribute('opacity', '0.3');
          }
        }
      }
    };
    SfMaps.prototype.pinchZooming = function (event) {
      this.pinchFactor = this.scaleFactor;
      var prevLevel = this.scaleFactor;
      var container = this.getBound(this.element.id);
      if (!this.isTileMap) {
        var availSize = this.areaRect;
        this.previousScale = this.scaleFactor;
        this.previousPoint = this.shapeTranslatePoint;
        var prevTilePoint = this.tileTranslatePoint;
        var scale = this.calculateScale(this.touchStartList, this.touchMoveList);
        var touchCenter = this.getTouchCenter(this.touchMoveList);
        var newScale = scale / this.lastScale;
        this.lastScale = scale;
        this.pinchFactor *= newScale;
        this.pinchFactor = Math.min(this.options.maxZoom, Math.max(this.options.minZoom, this.pinchFactor));
        var mapTotalWidth = Math.abs(this.baseMapBounds.minBounds.x - this.baseMapBounds.maxBounds.x);
        var mapTotalHeight = Math.abs(this.baseMapBounds.minBounds.y - this.baseMapBounds.maxBounds.y);
        var currentHeight = Math.abs(this.baseMapBounds.maxBounds.y - this.baseMapBounds.minBounds.y) * this.pinchFactor;
        var translatePointX = this.shapeTranslatePoint.x - (availSize.width / this.scaleFactor - availSize.width / this.pinchFactor) / (availSize.width / (touchCenter.x - container.x));
        var translatePointY = this.shapeTranslatePoint.y - (availSize.height / this.scaleFactor - availSize.height / this.pinchFactor) / (availSize.height / (touchCenter.y - container.y));
        translatePointX = currentHeight < this.areaRect.height && !sf.base.Browser.isDevice ? availSize.x + (-this.baseMapBounds.minBounds.x + (availSize.width / 2 - mapTotalWidth / 2)) : translatePointX;
        translatePointY = currentHeight < this.areaRect.height && !sf.base.Browser.isDevice ? availSize.y + (-this.baseMapBounds.minBounds.y + (availSize.height / 2 - mapTotalHeight / 2)) : translatePointY;
        this.scaleFactor = this.pinchFactor;
        this.shapeTranslatePoint = {
          x: translatePointX,
          y: translatePointY
        };
        this.applyTransform(this.scaleFactor, this.shapeTranslatePoint);
      } else {
        var touchCenter = this.getTouchCenterPoint();
        var distance = Math.sqrt(Math.pow(this.touchMoveList[0].pageX - this.touchMoveList[1].pageX, 2) + Math.pow(this.touchMoveList[0].pageY - this.touchMoveList[1].pageY, 2));
        var factor = this.pinchFactor;
        if (!sf.base.isNullOrUndefined(this.pinchDistance)) {
          if (this.pinchDistance > distance) {
            factor = factor - 1;
          } else if (this.pinchDistance < distance) {
            factor = factor + 1;
          }
          factor = Math.min(this.options.maxZoom, Math.max(this.options.minZoom, factor));
          if (factor != this.pinchFactor) {
            this.pinchFactor = factor;
            this.tileZoomLevel = this.pinchFactor;
            this.scaleFactor = this.pinchFactor;
            this.currentTouchCenter = touchCenter;
            this.getTileTranslatePosition(prevLevel, this.pinchFactor, {
              x: touchCenter.x,
              y: touchCenter.y
            }, null);
            this.translatePoint.x = (this.tileTranslatePoint.x - 0.01 * this.scaleFactor) / Math.pow(2, this.scaleFactor - 1);
            this.translatePoint.y = (this.tileTranslatePoint.y - 0.01 * this.scaleFactor) / Math.pow(2, this.scaleFactor - 1);
            this.generateTiles();
            this.renderMarkers();
            this.clusterMarkerProcess();
          }
        }
        this.pinchDistance = distance;
      }
    };
    SfMaps.prototype.removePanColor = function (selectionColor) {
      if (document.getElementById(this.element.id + '_Zooming_ToolBar_Pan_Rect') && this.options.enablePanning) {
        document.getElementById(this.element.id + '_Zooming_ToolBar_Pan_Path').setAttribute('fill', selectionColor);
        document.getElementById(this.element.id + '_Zooming_ToolBar_Pan_Path').setAttribute('stroke', selectionColor);
      }
    };
    SfMaps.prototype.removeZoomColor = function (selectionColor) {
      if (document.getElementById(this.element.id + '_Zooming_ToolBar_Zoom_Rect') && this.options.enableSelectionZooming) {
        document.getElementById(this.element.id + '_Zooming_ToolBar_Zoom_Path').setAttribute('fill', selectionColor);
        document.getElementById(this.element.id + '_Zooming_ToolBar_Zoom_Path').setAttribute('stroke', selectionColor);
      }
    };
    SfMaps.prototype.getTileTranslatePosition = function (prevLevel, currentLevel, position, type) {
      var tileDefaultSize = 256;
      var prevSize = Math.pow(2, prevLevel) * 256;
      var totalSize = Math.pow(2, currentLevel) * 256;
      var x = (position.x - this.tileTranslatePoint.x) / prevSize * 100;
      var y = (position.y - this.tileTranslatePoint.y) / prevSize * 100;
      var bounds = this.baseMapBounds.availableSize;
      this.tileTranslatePoint.x = currentLevel === 1 ? bounds.width / 2 - tileDefaultSize * 2 / 2 : position.x - x * totalSize / 100;
      this.tileTranslatePoint.y = currentLevel === 1 ? bounds.height / 2 - tileDefaultSize * 2 / 2 : position.y - y * totalSize / 100;
    };
    SfMaps.prototype.calculateScale = function (startTouches, endTouches) {
      var startDistance = this.getDistance(startTouches[0], startTouches[1]);
      var endDistance = this.getDistance(endTouches[0], endTouches[1]);
      return endDistance / startDistance;
    };
    SfMaps.prototype.getDistance = function (a, b) {
      var x = a.pageX - b.pageX;
      var y = a.pageY - b.pageY;
      return Math.sqrt(x * x + y * y);
    };
    SfMaps.prototype.sum = function (a, b) {
      return a + b;
    };
    SfMaps.prototype.getTouchCenter = function (touches) {
      return {
        x: touches.map(function (e) {
          return e['pageX'];
        }).reduce(this.sum) / touches.length,
        y: touches.map(function (e) {
          return e['pageY'];
        }).reduce(this.sum) / touches.length
      };
    };
    SfMaps.prototype.getTouchCenterPoint = function () {
      var touchList = [];
      for (var i = 0; i < this.touchMoveList.length; i++) {
        touchList.push(this.getMousePosition(this.touchMoveList[i]['pageX'], this.touchMoveList[i]['pageY']));
      }
      return {
        x: (touchList[0].x + touchList[1].x) / 2,
        y: (touchList[0].y + touchList[1].y) / 2
      };
    };
    SfMaps.prototype.highlightMap = function (event) {
      var targetElement = event.target;
      var id = targetElement['id'];
      if (!targetElement.classList.contains('highlightLine') && !targetElement.classList.contains('highlightShape') && !targetElement.classList.contains('highlightMarker') && !targetElement.classList.contains('highlightBubble') && !targetElement.classList.contains('highlightNavigation') && !targetElement.classList.contains('highlightPolygon')) {
        this.removeAllHighlight();
      }
      this.targetElementPath = targetElement;
      if (id.indexOf('_LayerIndex_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var dataIndex = id.indexOf('_dataIndex_') > -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : 0;
        if (id.indexOf('shapeIndex') > -1 && id.indexOf('LabelIndex_') == -1 && this.options.layerHighlightSettings[layerIndex] && this.options.layerHighlightSettings[layerIndex].Enable) {
          if (!targetElement.classList.contains('mapShapeSelection')) {
            var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
            this.dotNetRef.invokeMethodAsync('TriggerShapeHighlight', layerIndex, shapeIndex, id);
          }
        } else if (id.indexOf('_BubbleIndex_') > -1) {
          var bubbleIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
          if (this.options.bubbleHighlightSettings[layerIndex][bubbleIndex] && this.options.bubbleHighlightSettings[layerIndex][bubbleIndex].Enable && !targetElement.classList.contains('mapBubbleSelection')) {
            this.dotNetRef.invokeMethodAsync('TriggerItemHighlight', 'Bubble', layerIndex, bubbleIndex, dataIndex, id);
          }
        } else if (id.indexOf('_NavigationIndex_') > -1) {
          var navigationIndex = parseInt(id.split('_NavigationIndex_')[1].split('_')[0], 10);
          if (this.options.navigationHighlightSettings[layerIndex][navigationIndex] && this.options.navigationHighlightSettings[layerIndex][navigationIndex].Enable && !targetElement.classList.contains('mapNavigationSelection')) {
            this.dotNetRef.invokeMethodAsync('TriggerItemHighlight', 'Navigation', layerIndex, navigationIndex, 0, id);
          }
        } else if (id.indexOf('_PolygonIndex_') > -1) {
          var polygonIndex = parseInt(id.split('_PolygonIndex_')[1].split('_')[0], 10);
          if (this.options.polygonHighlightSettings[layerIndex] && this.options.polygonHighlightSettings[layerIndex].Enable && !targetElement.classList.contains('mapPolygonSelection')) {
            this.dotNetRef.invokeMethodAsync('TriggerItemHighlight', 'Polygon', layerIndex, polygonIndex, 0, id);
          }
        } else if (id.indexOf('_MarkerIndex_') > -1 && id.indexOf('_cluster_') === -1 && !(id.indexOf('markerClusterConnectorLine') > -1)) {
          var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
          if (this.options.markerHighlightSettings[layerIndex][markerIndex] && this.options.markerHighlightSettings[layerIndex][markerIndex].Enable && !targetElement.classList.contains('mapMarkerSelection')) {
            this.dotNetRef.invokeMethodAsync('TriggerItemHighlight', 'Marker', layerIndex, markerIndex, dataIndex, id);
          }
        }
      } else if (id.indexOf('_Legend_Shape_') > -1) {
        var legendIndex = parseInt(id.split('_Index_')[1], 10);
        var legendData = this.legendDetails[legendIndex];
        if (this.legendSettings.type === 'Layers') {
          if (!targetElement.classList.contains('mapShapeSelection')) {
            for (var a = 0; a < legendData.length; a++) {
              if (this.options.layerHighlightSettings[legendData[a].layerIndex] && !sf.base.isNullOrUndefined(this.options.layerHighlightSettings[legendData[a].layerIndex]) && this.options.layerHighlightSettings[legendData[a].layerIndex].Enable) {
                targetElement.classList.add('highlightShape');
                var element = document.getElementById(this.element.id + '_LayerIndex_' + legendData[a].layerIndex + '_shapeIndex_' + legendData[a].settingIndex);
                this.handleHighlight(element, 'Shape', this.options.layerHighlightSettings[legendData[a].layerIndex]);
              }
            }
          }
        } else if (this.legendSettings.type === 'Markers') {
          if (!targetElement.classList.contains('mapMarkerSelection')) {
            for (var a = 0; a < legendData.length; a++) {
              if (this.options.markerHighlightSettings[legendData[a].layerIndex] && !sf.base.isNullOrUndefined(this.options.markerHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex]) && this.options.markerHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex].Enable) {
                targetElement.classList.add('highlightMarker');
                var element = document.getElementById(this.element.id + '_LayerIndex_' + legendData[a].layerIndex + '_MarkerIndex_' + legendData[a].settingIndex + '_dataIndex_' + legendData[a].dataIndex);
                this.handleHighlight(element, 'Marker', this.options.markerHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex]);
              }
            }
          }
        } else if (this.legendSettings.type === 'Bubbles') {
          if (!targetElement.classList.contains('mapBubbleSelection')) {
            for (var a = 0; a < legendData.length; a++) {
              if (this.options.bubbleHighlightSettings[legendData[a].layerIndex] && !sf.base.isNullOrUndefined(this.options.bubbleHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex]) && this.options.bubbleHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex].Enable) {
                targetElement.classList.add('highlightBubble');
                var element = document.getElementById(this.element.id + '_LayerIndex_' + legendData[a].layerIndex + '_BubbleIndex_' + legendData[a].settingIndex + '_dataIndex_' + legendData[a].dataIndex);
                this.handleHighlight(element, 'Bubble', this.options.bubbleHighlightSettings[legendData[a].layerIndex][legendData[a].settingIndex]);
              }
            }
          }
        }
      }
    };
    SfMaps.prototype.removeAllHighlight = function () {
      this.removeHighlight('Shape');
      this.removeHighlight('Line');
      this.removeHighlight('Marker');
      this.removeHighlight('Bubble');
      this.removeHighlight('Navigation');
      this.removeHighlight('Polygon');
    };
    SfMaps.prototype.handleHighlight = function (element, type, settings) {
      if (type === 'Marker' || type === 'Bubble' || type === 'Shape') {
        if (!sf.base.isNullOrUndefined(this.legendDetails) && this.legendDetails.length !== 0) {
          for (var a = 0; a < this.legendDetails.length; a++) {
            for (var b = 0; b < this.legendDetails[a].length; b++) {
              if (type === 'Marker' && element.id === this.element.id + '_LayerIndex_' + this.legendDetails[a][b].layerIndex + '_MarkerIndex_' + this.legendDetails[a][b].settingIndex + '_dataIndex_' + this.legendDetails[a][b].dataIndex || type === 'Bubble' && element.id === this.element.id + '_LayerIndex_' + this.legendDetails[a][b].layerIndex + '_BubbleIndex_' + this.legendDetails[a][b].settingIndex + '_dataIndex_' + this.legendDetails[a][b].dataIndex || type === 'Shape' && element.id === this.element.id + '_LayerIndex_' + this.legendDetails[a][b].layerIndex + '_shapeIndex_' + this.legendDetails[a][b].settingIndex) {
                var legendElement = document.getElementById(this.element.id + '_Legend_Shape_Index_' + a);
                legendElement.classList.add('highlight' + type);
                break;
              }
            }
          }
        }
      }
      if (type !== 'Arrow') {
        var styleType = !sf.base.isNullOrUndefined(element.getAttribute('data-geometry')) && element.getAttribute('data-geometry').indexOf('LineString') > -1 ? 'Line' : type;
        if (styleType === 'Bubble' && element.id.indexOf('_BubbleIndex_') > -1 && settings.Enable || styleType === 'Marker' && element.id.indexOf('_MarkerIndex_') > -1 && settings.Enable || (styleType === 'Shape' || styleType === 'Line') && element.id.indexOf('_shapeIndex_') > -1 && settings.Enable || styleType === 'Navigation' && element.id.indexOf('_NavigationIndex_') > -1 && settings.Enable || styleType === 'Polygon' && element.id.indexOf('_PolygonIndex_') > -1 && settings.Enable) {
          element.classList.add('highlight' + styleType);
          if (document.querySelector('#highlight' + styleType + 'Style') !== null && document.querySelector('#highlight' + styleType + 'Style')['length'] !== 0) {
            this.customizeStyle('highlight' + styleType + 'Style', 'highlight' + styleType, settings, element['id']);
          } else {
            this.createStyle('highlight' + styleType + 'Style', 'highlight' + styleType, settings, element['id']);
          }
        }
      } else {
        element.setAttribute('fill', settings.Fill);
        element.setAttribute('fill-opacity', settings.opacity);
        element.setAttribute('stroke-opacity', settings['BorderOpacity']);
      }
    };
    SfMaps.prototype.removeHighlight = function (type) {
      var highlights = document.querySelectorAll('.highlight' + type);
      if (highlights && highlights.length > 0) {
        for (var i = 0; i < highlights.length; i++) {
          highlights[i].classList.remove('highlight' + type);
          if (type === 'Navigation' && highlights[i].id !== '' && (highlights[i].getAttribute('marker-start') !== '' || highlights[i].getAttribute('marker-end') !== '')) {
            var highlightNavigate = document.getElementById(highlights[i].id + '_triangle');
            var layerIndex = parseInt(highlights[i].id.split('_LayerIndex_')[1].split('_')[0], 10);
            var lineIndex = parseInt(highlights[i].id.split('_NavigationIndex_')[1].split('_')[0], 10);
            if (!sf.base.isNullOrUndefined(highlightNavigate)) {
              highlightNavigate.setAttribute('fill', this.navigation[layerIndex][lineIndex].ArrowColor);
              highlightNavigate.setAttribute('opacity', '1');
            }
          }
        }
      }
    };
    SfMaps.prototype.createStyle = function (id, className, setting, elementId) {
      var style = document.createElement('style');
      style.id = id;
      this.highlightStyle(style, className, setting, elementId);
      document.body.appendChild(style);
    };
    SfMaps.prototype.highlightStyle = function (style, className, setting, elementId) {
      if (elementId.indexOf('NavigationIndex') > -1) {
        var color = !sf.base.isNullOrUndefined(setting["Fill"]) ? setting["Fill"] : !sf.base.isNullOrUndefined(setting["BorderColor"]) ? setting["BorderColor"] : "transparent";
        var layerIndex = parseInt(elementId.split('_LayerIndex_')[1].split('_')[0], 10);
        var lineIndex = parseInt(elementId.split('_NavigationIndex_')[1].split('_')[0], 10);
        if (this.navigation[layerIndex][lineIndex].Angle === 0) {
          style.innerHTML = '.' + className + ' {fill: none;fill-opacity:' + setting['Opacity'] + ';stroke:' + color + ';stroke-width:' + setting['BorderWidth'] + ';stroke-opacity:' + setting['BorderOpacity'];
        } else {
          style.innerHTML = '.' + className + ' {fill: none;fill-opacity:' + setting['Opacity'] + ';stroke:' + color + ';stroke-width:' + setting['BorderWidth'] + ';stroke-opacity:' + setting['BorderOpacity'];
        }
      } else {
        if (className.indexOf('Line') > -1) {
          style.innerHTML = '.' + className + ' {fill: transparent;fill-opacity:' + setting['Opacity'] + ';stroke:' + setting['Fill'] + ';stroke-width:' + (this.isTileMap ? setting['BorderWidth'] / Math.pow(2, this.options.factor - 1) : setting['BorderWidth'] / this.options.factor) + ';stroke-opacity:' + setting['BorderOpacity'];
        } else {
          style.innerHTML = '.' + className + ' {fill:' + setting['Fill'] + ';fill-opacity:' + setting['Opacity'] + ';stroke:' + setting['BorderColor'] + ';stroke-width:' + (this.isTileMap ? setting['BorderWidth'] / Math.pow(2, this.options.factor - 1) : setting['BorderWidth'] / this.options.factor) + ';stroke-opacity:' + setting['BorderOpacity'];
        }
      }
    };
    SfMaps.prototype.customizeStyle = function (id, className, setting, elementId) {
      var style = document.getElementById(id);
      this.highlightStyle(style, className, setting, elementId);
    };
    SfMaps.prototype.renderMarkers = function () {
      var layerCollection = document.getElementById(this.element.id + '_LayerCollections');
      for (var k = 0; k < this.layerCount; k++) {
        var templateCollection = document.getElementById(this.element.id + '_LayerIndex_' + k + '_Markers_Template_Group');
        this.markerTemplateTranslate(templateCollection, 0, this.translatePoint.x, this.translatePoint.y, this.scaleFactor);
        var labelCollection = document.getElementById(this.element.id + '_LayerIndex_' + k + '_DataLabel_Group');
        this.labelTemplateTranslate(labelCollection, this.translatePoint.x, this.translatePoint.y, this.scaleFactor);
      }
      for (var i = 0; i < layerCollection.childElementCount; i++) {
        var layerElement = layerCollection.children[i];
        if (layerElement.tagName === 'g') {
          var index = layerElement.id.indexOf('_LayerIndex_') > -1 && parseFloat(layerElement.id.split('_LayerIndex_')[1].split('_')[0]);
          for (var j = 0; j < layerElement.children.length; j++) {
            var currentEle = layerElement.children[j];
            if (currentEle.COMMENT_NODE === currentEle.nodeType) {
              continue;
            }
            if (currentEle.id.indexOf('_Polygon_Group') > -1) {
              currentEle.setAttribute('transform', 'scale(' + Math.pow(2, this.scaleFactor - 1) + ') translate( ' + this.translatePoint.x + ' ' + this.translatePoint.y + ' )');
            } else if (currentEle.id.indexOf('_MarkerGroup') > -1) {
              for (var k = 0; k < currentEle.childElementCount; k++) {
                this.markerTranslate(currentEle.children[k], 0, this.translatePoint.x, this.translatePoint.y, this.scaleFactor, false);
              }
            } else if (currentEle.id.indexOf('_Polygons_Group') > -1) {
              if (!this.isTileMap) {
                currentEle.setAttribute('transform', 'scale(' + this.scaleFactor + ') translate( ' + this.translatePoint.x + ' ' + this.translatePoint.y + ' )');
              } else {
                for (var m = 0; m < currentEle.childElementCount; m++) {
                  var currentGroup = document.getElementById(currentEle.children[m]['id']);
                  for (var k = 0; k < currentGroup.childElementCount; k++) {
                    if (currentGroup.children[k]['id'] !== '') {
                      var layerIndex = parseInt(currentGroup.children[k].id.split('_LayerIndex_')[1].split('_')[0], 10);
                      var lineIndex = parseInt(currentGroup.children[k].id.split('_PolygonIndex_')[1].split('_')[0], 10);
                      this.polygonTranslate(currentGroup.children[k], 0, layerIndex, lineIndex);
                    }
                  }
                }
              }
            } else if (currentEle.id.indexOf('_line_Group') > -1) {
              if (!this.isTileMap) {
                currentEle.setAttribute('transform', 'scale(' + this.scaleFactor + ') translate( ' + this.translatePoint.x + ' ' + this.translatePoint.y + ' )');
              } else {
                currentEle.setAttribute('transform', 'scale(' + Math.pow(2, this.scaleFactor - 1) + ') translate( ' + this.translatePoint.x + ' ' + this.translatePoint.y + ' )');
              }
            } else if (currentEle.id.indexOf('_dataLableIndex_Group') > -1) {
              var factor = Math.pow(2, this.scaleFactor - 1);
              for (var k = 0; k < currentEle.children.length; k++) {
                this.dataLabelTranslate(currentEle.children[k], 0, this.translatePoint.x, this.translatePoint.y, factor, 'DataLabel');
              }
            }
          }
        }
      }
    };
    SfMaps.prototype.setMarkerTranslate = function (element, layerIndex, markerIndex, dataIndex, point) {
      if ((this.dataSource[layerIndex][markerIndex][dataIndex][this.markerSettings[layerIndex][markerIndex].ShapeValuePath] === "Balloon" || this.markerSettings[layerIndex][markerIndex].Type == "Balloon") && !(element.id.indexOf('cluster') > -1)) {
        element.setAttribute('transform', 'translate( ' + (point.x - this.markerSettings[layerIndex][markerIndex].Width / 2) + ' ' + (point.y - this.markerSettings[layerIndex][markerIndex].Height) + ' )' + 'scale(' + this.markerSettings[layerIndex][markerIndex].Width / 30 + ' ' + this.markerSettings[layerIndex][markerIndex].Height / 30 + ' ' + ')');
      } else if ((this.dataSource[layerIndex][markerIndex][dataIndex][this.markerSettings[layerIndex][markerIndex].ShapeValuePath] === "Rectangle" || this.markerSettings[layerIndex][markerIndex].Type == "Rectangle") && !(element.id.indexOf('cluster') > -1)) {
        element.setAttribute('transform', 'translate( ' + (point.x - this.markerSettings[layerIndex][markerIndex].Width / 2) + ' ' + (point.y - this.markerSettings[layerIndex][markerIndex].Height / 2) + ' )');
      } else {
        if (this.isTileMap && element.classList.contains('e-maps-cluster')) {
          element.setAttribute('transform', 'translate( ' + (point.x - this.areaRect.x) + ' ' + (point.y - this.areaRect.y) + ' )');
        } else {
          element.setAttribute('transform', 'translate( ' + point.x + ' ' + point.y + ' )');
        }
      }
    };
    SfMaps.prototype.markerTranslate = function (element, factor, x, y, scale, template) {
      if (element.COMMENT_NODE === element.nodeType || element.TEXT_NODE === element.nodeType) {
        return;
      }
      var layerIndex = parseInt(element.id.split('_LayerIndex_')[1].split('_')[0], 10);
      var markerIndex = parseInt(element.id.split('_MarkerIndex_')[1].split('_')[0], 10);
      var dataIndex = parseInt(element.id.split('_dataIndex_')[1].split('_')[0], 10);
      var latitudeValuePath = !sf.base.isNullOrUndefined(this.markerSettings[layerIndex][markerIndex].LatitudeValuePath) && this.markerSettings[layerIndex][markerIndex].LatitudeValuePath !== '' ? this.markerSettings[layerIndex][markerIndex].LatitudeValuePath : !sf.base.isNullOrUndefined(this.dataSource[layerIndex][markerIndex][dataIndex]['Latitude']) ? 'Latitude' : 'latitude';
      var longitudeValuePath = !sf.base.isNullOrUndefined(this.markerSettings[layerIndex][markerIndex].LongitudeValuePath) && this.markerSettings[layerIndex][markerIndex].LongitudeValuePath !== '' ? this.markerSettings[layerIndex][markerIndex].LongitudeValuePath : !sf.base.isNullOrUndefined(this.dataSource[layerIndex][markerIndex][dataIndex]['Longitude']) ? 'Longitude' : 'longitude';
      var longitude = this.dataSource[layerIndex]['length'] !== 0 ? this.dataSource[layerIndex][markerIndex].length !== 0 ? this.dataSource[layerIndex][markerIndex][dataIndex][longitudeValuePath] : null : null;
      var latitude = this.dataSource[layerIndex]['length'] !== 0 ? this.dataSource[layerIndex][markerIndex].length !== 0 ? this.dataSource[layerIndex][markerIndex][dataIndex][latitudeValuePath] : null : null;
      if (latitude && longitude) {
        if (this.isTileMap) {
          var point = this.convertTileLatLongToPoint({
            x: longitude,
            y: latitude
          }, this.tileZoomLevel, this.tileTranslatePoint, true);
          point['x'] = point['x'] + this.markerSettings[layerIndex][markerIndex]['X'];
          point['y'] = point['y'] + this.markerSettings[layerIndex][markerIndex]['Y'];
          if (!template) {
            this.setMarkerTranslate(element, layerIndex, markerIndex, dataIndex, point);
          } else {
            element['style']['left'] = point.x - this.areaRect.x + 'px';
            element['style']['top'] = point.y - this.areaRect.y + 'px';
          }
        } else {
          var location_2 = this.convertGeoToPoint(latitude, longitude, factor, layerIndex);
          location_2.x = (location_2.x + x) * scale + this.markerSettings[layerIndex][markerIndex]['X'];
          location_2.y = (location_2.y + y) * scale + this.markerSettings[layerIndex][markerIndex]['Y'];
          if (!template) {
            this.setMarkerTranslate(element, layerIndex, markerIndex, dataIndex, location_2);
          } else {
            element['style']['left'] = location_2.x - this.areaRect.x + 'px';
            element['style']['top'] = location_2.y - this.areaRect.y + 'px';
          }
        }
      }
    };
    SfMaps.prototype.polygonTranslate = function (element, factor, layerIndex, polygonIndex) {
      if (!sf.base.isNullOrUndefined(this.polygon[layerIndex])) {
        var d = '';
        var point = [];
        for (var i = 0; i < this.polygonDataSource[layerIndex][polygonIndex].length; i++) {
          var location_3 = this.isTileMap ? this.convertTileLatLongToPoint({
            x: this.polygonDataSource[layerIndex][polygonIndex][i].Longitude,
            y: this.polygonDataSource[layerIndex][polygonIndex][i].Latitude
          }, this.tileZoomLevel, this.tileTranslatePoint, true) : this.convertGeoToPoint(this.polygonDataSource[layerIndex][polygonIndex][i].Latitude, this.polygonDataSource[layerIndex][polygonIndex][i].Longitude, factor, layerIndex);
          point.push(location_3);
        }
        for (var j = 0; j < point.length; j++) {
          d += j === 0 ? 'M ' + point[j]['x'] + ',' + point[j]['y'] : ' L ' + point[j]['x'] + ',' + point[j]['y'];
        }
        d += ' z ';
        element = document.getElementById(this.id + "_LayerIndex_" + layerIndex + "_PolygonIndex_" + polygonIndex);
        element.setAttribute('d', d);
      }
    };
    SfMaps.prototype.navigationTranslate = function (element, factor, layerIndex, lineIndex) {
      if (!sf.base.isNullOrUndefined(this.navigation[layerIndex])) {
        var angle = this.navigation[layerIndex][lineIndex].Angle;
        var direction = void 0;
        var d = void 0;
        var point = [];
        if (this.navigation[layerIndex][lineIndex].Latitude.length === this.navigation[layerIndex][lineIndex].Longitude.length) {
          for (var i = 0; i < this.navigation[layerIndex][lineIndex].Latitude.length; i++) {
            var location_4 = this.isTileMap ? this.convertTileLatLongToPoint({
              x: this.navigation[layerIndex][lineIndex].Longitude[i],
              y: this.navigation[layerIndex][lineIndex].Latitude[i]
            }, this.tileZoomLevel, this.tileTranslatePoint, true) : this.convertGeoToPoint(this.navigation[layerIndex][lineIndex].Latitude[i], this.navigation[layerIndex][lineIndex].Longitude[i], factor, layerIndex);
            point.push(location_4);
          }
        }
        for (var j = 0; j < point['length'] - 1; j++) {
          angle = -1 > angle ? -1 : angle;
          angle = 1 < angle ? 1 : angle;
          var radius1 = this.convertRadius(point[j], point[j + 1]);
          if (angle <= 1 && angle > 0) {
            direction = 0;
            if (point[j]['x'] > point[j + 1]['x']) {
              direction = 1;
            }
          }
          if (angle >= -1 && angle < 0) {
            direction = 1;
            if (point[j]['x'] > point[j + 1]['x']) {
              direction = 0;
            }
          }
          angle = Math.abs(angle);
          d = angle === 0 ? 'M ' + point[j]['x'] + ',' + point[j]['y'] + 'L ' + point[j + 1]['x'] + ',' + point[j + 1]['y'] + ' ' : 'M ' + point[j]['x'] + ',' + point[j]['y'] + ' A ' + (radius1 / 2 + (1 - angle) * radius1 / (angle * 10)) + ' ' + (radius1 / 2 + (1 - angle) * radius1 / (angle * 10)) + ' ' + 0 + ',' + 0 + ',' + direction + ' , ' + point[j + 1]['x'] + ',' + point[j + 1]['y'] + ' ';
          element = document.getElementById(this.id + "_LayerIndex_" + layerIndex + "_NavigationIndex_" + lineIndex + "_Line_" + j);
          element.setAttribute('d', d);
        }
      }
    };
    SfMaps.prototype.dataLabelTranslate = function (element, factor, x, y, scale, type) {
      if (element.COMMENT_NODE === element.nodeType || element.TEXT_NODE === element.nodeType) {
        return;
      }
      var layerIndex = parseInt(element.id.split('_LayerIndex_')[1].split('_')[0], 10);
      var labelIndex = parseFloat(element.id.split('_shapeIndex_')[1].split('_')[0]);
      var labelX;
      var labelY;
      if (type !== 'Template') {
        var currentLabel = this.labelCollection[layerIndex][labelIndex];
        labelX = currentLabel['LocationX'];
        labelY = currentLabel['LocationY'];
        var padding = 5;
        labelX = (labelX + x) * scale - currentLabel['BorderSize']['Height'] / 4 + currentLabel['OffsetX'];
        labelY = (labelY + y) * scale + currentLabel['BorderSize']['Height'] / 4 + currentLabel['OffsetY'];
        if (element.id.indexOf('_RectIndex_') > -1) {
          element.setAttribute('x', (labelX - parseInt(element.getAttribute('width')) / 2).toString());
          element.setAttribute('y', (labelY - (padding + parseInt(element.getAttribute('height')) / 2)).toString());
        } else {
          element.setAttribute('transform', 'translate( ' + labelX + ' ' + labelY + ' )');
        }
      } else {
        var currentLabel = this.dataLabelTemplateCollection[layerIndex][labelIndex];
        labelX = (currentLabel['LocationX'] + x) * scale + currentLabel['OffsetX'];
        labelY = (currentLabel['LocationY'] + y) * scale + currentLabel['OffsetY'];
        element['style']['left'] = labelX + 'px';
        element['style']['top'] = labelY + 'px';
      }
    };
    SfMaps.prototype.convertTileLatLongToPoint = function (center, zoomLevel, tileTranslatePoint, isMapCoordinates) {
      var size = Math.pow(2, zoomLevel) * 256;
      var x = (center.x + 180) / 360;
      var sinLatitude = Math.sin(center.y * Math.PI / 180);
      var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
      var pixelX = center.x;
      var pixelY = center.y;
      if (isMapCoordinates) {
        pixelX = x * size + 0.5 + tileTranslatePoint.x;
        pixelY = y * size + 0.5 + tileTranslatePoint.y;
      }
      return {
        x: pixelX,
        y: pixelY
      };
    };
    SfMaps.prototype.panning = function (xDifference, yDifference, layerX, layerY, scaleFactor, isKeyboardInteraction) {
      this.mergeSeparation();
      if (!this.isTileMap) {
        var previousPoint = this.shapeTranslatePoint;
        var x = this.shapeTranslatePoint.x - xDifference / scaleFactor;
        var y = this.shapeTranslatePoint.y - yDifference / scaleFactor;
        var layerRect = document.getElementById(this.element.id + '_LayerCollections').getBoundingClientRect();
        var elementRect = document.getElementById(this.element.id + '_svg').getBoundingClientRect();
        var legendElement = document.getElementById(this.element.id + '_Legend_Group');
        var legendHeight = !sf.base.isNullOrUndefined(legendElement) ? legendElement.getClientRects()[0].height : 0;
        var panningXDirection = xDifference < 0 ? layerRect.left <= elementRect.left + this.areaRect.x : layerRect.left + layerRect.width >= elementRect.left + elementRect.width + this.areaRect.x + this.marginLeft;
        var panningYDirection = yDifference < 0 ? layerRect.top <= elementRect.top + this.areaRect.y : layerRect.top + layerRect.height + legendHeight + this.marginTop >= elementRect.top + elementRect.height;
        if (panningXDirection && panningYDirection) {
          this.shapeTranslatePoint = {
            x: x,
            y: y
          };
          this.applyTransform(this.scaleFactor, this.shapeTranslatePoint);
        } else if (panningXDirection) {
          this.shapeTranslatePoint = {
            x: x,
            y: this.shapeTranslatePoint.y
          };
          this.applyTransform(this.scaleFactor, this.shapeTranslatePoint);
        } else if (panningYDirection) {
          this.shapeTranslatePoint = {
            x: this.shapeTranslatePoint.x,
            y: y
          };
          this.applyTransform(this.scaleFactor, this.shapeTranslatePoint);
        }
      } else {
        var x = this.tileTranslatePoint.x - xDifference - (sf.base.Browser.isDevice && scaleFactor == 1 ? xDifference / 2 : 0);
        var y = this.tileTranslatePoint.y - yDifference;
        this.tileTranslatePoint.x = x;
        this.tileTranslatePoint.y = y;
        if (this.tileTranslatePoint.y > -10 && yDifference < 0 || this.tileTranslatePoint.y < -((Math.pow(2, scaleFactor) - 2) * 256) && yDifference > 0) {
          this.tileTranslatePoint.x = x + xDifference;
          this.tileTranslatePoint.y = y + yDifference;
        }
        if (isKeyboardInteraction) {
          xDifference = 0;
          yDifference = 0;
        }
        this.translatePoint.x = this.tileTranslatePoint.x / Math.pow(2, scaleFactor - 1);
        this.translatePoint.y = this.tileTranslatePoint.y / Math.pow(2, scaleFactor - 1);
        this.generateTiles();
        this.renderMarkers();
      }
    };
    SfMaps.prototype.applyTransform = function (scaleFactor, shapeTranslatePoint) {
      var x = !this.isTileMap ? shapeTranslatePoint.x : this.translatePoint.x;
      var y = !this.isTileMap ? shapeTranslatePoint.y : this.translatePoint.y;
      var layerCollection = document.getElementById(this.element.id + '_LayerCollections');
      for (var i = 0; i < layerCollection.children.length; i++) {
        var layerElement = layerCollection.children[i];
        if (layerElement.COMMENT_NODE === layerElement.nodeType) {
          continue;
        }
        if (layerElement.tagName === 'g') {
          var factor = this.calculateFactor(parseFloat(layerElement.id.split('_LayerIndex_')[1].split('_')[0]));
          var index = layerElement.id.indexOf('_LayerIndex_') > -1 && parseFloat(layerElement.id.split('_LayerIndex_')[1].split('_')[0]);
          for (var j = 0; j < layerElement.children.length; j++) {
            var currentEle = layerElement.children[j];
            if (currentEle.COMMENT_NODE === currentEle.nodeType) {
              continue;
            }
            if (!sf.base.isNullOrUndefined(currentEle.id)) {
              if (currentEle.id.indexOf('Polygon') > -1 || currentEle.id.indexOf('_line_Group') > -1) {
                currentEle.setAttribute('transform', 'scale(' + scaleFactor + ') translate( ' + x + ' ' + y + ' )');
              } else if (currentEle.id.indexOf('_MarkerGroup') > -1) {
                for (var k = 0; k < currentEle.children.length; k++) {
                  if (!sf.base.isNullOrUndefined(currentEle.children[k].id)) {
                    this.markerTranslate(currentEle.children[k], factor, x, y, scaleFactor, false);
                  }
                }
              } else if (currentEle.id.indexOf('_bubble_Group_') > -1) {
                for (var k = 0; k < currentEle.children.length; k++) {
                  var childElement = currentEle.children[k];
                  if (!sf.base.isNullOrUndefined(childElement.id)) {
                    var layerIndex = parseFloat(childElement.id.split('_LayerIndex_')[1].split('_')[0]);
                    var bubleIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[0]);
                    var dataIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[2]);
                    if (this.bubbleCollection[layerIndex] && this.bubbleCollection[layerIndex][bubleIndex]) {
                      var currentBubble = this.bubbleCollection[layerIndex][bubleIndex][dataIndex];
                      var centerX = currentBubble['ZoomTranslatePoint']['X'];
                      var centerY = currentBubble['ZoomTranslatePoint']['Y'];
                      var currentX = (centerX + x) * scaleFactor;
                      var currentY = (centerY + y) * scaleFactor;
                      if (currentBubble.Type == 1) {
                        currentX -= currentBubble.Radius;
                        currentY -= currentBubble.Radius;
                      }
                      childElement.setAttribute('transform', 'translate( ' + currentX + ' ' + currentY + ' )');
                    }
                  }
                }
              } else if (currentEle.id.indexOf('_dataLableIndex_Group') > -1) {
                for (var k = 0; k < currentEle.children.length; k++) {
                  this.dataLabelTranslate(currentEle.children[k], factor, x, y, scaleFactor, 'DataLabel');
                }
              }
            }
          }
        }
      }
      for (var m = 0; m < this.layerCount; m++) {
        var factor = this.calculateFactor(m);
        var templateCollection = document.getElementById(this.element.id + '_LayerIndex_' + m + '_Markers_Template_Group');
        this.markerTemplateTranslate(templateCollection, factor, x, y, scaleFactor);
        var labelCollection = document.getElementById(this.element.id + '_LayerIndex_' + m + '_DataLabel_Group');
        this.labelTemplateTranslate(labelCollection, x, y, scaleFactor);
      }
    };
    SfMaps.prototype.markerTemplateTranslate = function (templateCollection, factor, x, y, scaleFactor) {
      if (templateCollection) {
        for (var k = 0; k < templateCollection.childElementCount; k++) {
          this.markerTranslate(templateCollection.children[k], factor, x, y, scaleFactor, true);
        }
      }
    };
    SfMaps.prototype.labelTemplateTranslate = function (labelTemplateCollection, x, y, scaleFactor) {
      if (labelTemplateCollection) {
        var factor = this.isTileMap ? Math.pow(2, scaleFactor - 1) : scaleFactor;
        for (var k = 0; k < labelTemplateCollection.childElementCount; k++) {
          this.dataLabelTranslate(labelTemplateCollection.children[k], 0, x, y, factor, 'Template');
        }
      }
    };
    SfMaps.prototype.calculateFactor = function (layerIndex) {
      var horFactor;
      var verFactor = 1;
      var divide = 10;
      var exp = 'e+1';
      var bounds = this.baseMapBounds;
      var mapSize = {
        width: this.areaRect.width,
        height: this.areaRect.height
      };
      var mapHeight;
      var mapWidth;
      if (bounds) {
        var start = this.convertGeoToPoint(bounds.latitudeMin, bounds.longitudeMin, null, layerIndex);
        var end = this.convertGeoToPoint(bounds.latitudeMax, bounds.longitudeMax, null, layerIndex);
        mapHeight = end.y - start.y;
        mapWidth = end.x - start.x;
      } else {
        mapHeight = mapWidth = 500;
      }
      if (mapHeight < mapSize.height) {
        horFactor = parseFloat(Math.abs(Number(mapSize.height / Number(mapHeight.toString() + exp)) * 100).toString().split('.')[0]) / divide;
      } else {
        horFactor = mapSize.height / mapHeight;
      }
      if (mapWidth < mapSize.width) {
        verFactor = parseFloat(Math.abs(Number(mapSize.width / Number(mapWidth.toString() + exp)) * 100).toString().split('.')[0]) / divide;
      } else {
        verFactor = mapSize.width / mapWidth;
      }
      return Math.min(verFactor, horFactor);
    };
    SfMaps.prototype.convertRadius = function (point1, point2) {
      var value1 = point2['x'] - point1['x'];
      var value2 = point2['y'] - point1['y'];
      var value = Math.sqrt(Math.pow(value1, 2) + Math.pow(value2, 2));
      return value;
    };
    SfMaps.prototype.convertGeoToPoint = function (latitude, longitude, factor, layerIndex) {
      var mapSize = {
        width: this.areaRect.width,
        height: this.areaRect.height
      };
      var x;
      var y;
      var value;
      var lat;
      var lng;
      var temp;
      var latRadian = this.degreesToRadians(latitude);
      var lngRadian = this.degreesToRadians(longitude);
      var size = factor === null || factor === undefined ? Math.min(mapSize.width, mapSize.height) : Math.min(mapSize.width, mapSize.height) * factor;
      var type = this.projectionType;
      if (this.geometryType[layerIndex] != "Normal") {
        switch (type) {
          case 'Mercator':
            var pixelOrigin = {
              x: size / 2,
              y: size / 2
            };
            x = pixelOrigin.x + longitude * (size / 360);
            var sinY = this.calculateBound(Math.sin(this.degreesToRadians(latitude)), -0.9999, 0.9999);
            y = pixelOrigin.y + 0.5 * Math.log((1 + sinY) / (1 - sinY)) * -(size / (2 * Math.PI));
            break;
          case 'Winkel3':
            value = this.aitoff(lngRadian, latRadian);
            lng = (value.x + lngRadian / (Math.PI / 2)) / 2;
            lat = (value.y + latRadian) / 2;
            break;
          case 'Miller':
            lng = lngRadian;
            lat = 1.25 * Math.log(Math.tan(Math.PI / 4 + .4 * latRadian));
            break;
          case 'Eckert3':
            temp = Math.sqrt(Math.PI * (4 + Math.PI));
            lng = 2 / temp * lngRadian * (1 + Math.sqrt(1 - 4 * latRadian * latRadian / (Math.PI * Math.PI)));
            lat = 4 / temp * latRadian;
            break;
          case 'AitOff':
            value = this.aitoff(lngRadian, latRadian);
            lng = value.x;
            lat = value.y;
            break;
          case 'Eckert5':
            lng = lngRadian * (1 + Math.cos(latRadian)) / Math.sqrt(2 + Math.PI);
            lat = 2 * latRadian / Math.sqrt(2 + Math.PI);
            break;
          case 'Equirectangular':
            lng = lngRadian;
            lat = latRadian;
            break;
          case 'Eckert6':
            var epsilon = 1e-6;
            temp = (1 + Math.PI / 2) * Math.sin(latRadian);
            var delta = Infinity;
            for (var i = 0; i < 10 && Math.abs(delta) > epsilon; i++) {
              delta = (latRadian + Math.sin(latRadian) - temp) / (1 + Math.cos(latRadian));
              latRadian = latRadian - delta;
            }
            temp = Math.sqrt(2 + Math.PI);
            lng = lngRadian * (1 + Math.cos(latRadian)) / temp;
            lat = 2 * latRadian / temp;
            break;
        }
      } else {
        x = factor == null ? longitude : Math.abs((longitude - this.baseMapBounds.longitudeMin) * factor);
        y = factor == null ? latitude : Math.abs((this.baseMapBounds.latitudeMax - latitude) * factor);
      }
      return {
        x: x,
        y: y
      };
    };
    SfMaps.prototype.aitoff = function (x, y) {
      var cosy = Math.cos(y);
      var sincia = Math.sin(Math.cos(cosy * Math.cos(x /= 2)));
      return {
        x: 2 * cosy * Math.sin(x) * sincia,
        y: Math.sin(y) * sincia
      };
    };
    SfMaps.prototype.degreesToRadians = function (deg) {
      return deg * (Math.PI / 180);
    };
    SfMaps.prototype.calculateBound = function (value, min, max) {
      if (!sf.base.isNullOrUndefined(min)) {
        value = Math.max(value, min);
      }
      if (!sf.base.isNullOrUndefined(max)) {
        value = Math.min(value, max);
      }
      return value;
    };
    SfMaps.prototype.getTileGeoLocation = function (layerX, layerY) {
      var container = this.getBound(this.element.id);
      var element = this.getBound(this.element.id + '_tile_parent');
      return this.pointToLatLong(layerX + this.areaRect.x - (element.x - container.x), layerY + this.areaRect.y - (element.y - container.y));
    };
    SfMaps.prototype.pointToLatLong = function (pageX, pageY) {
      var mapSize = 256 * Math.pow(2, this.scaleFactor);
      var x1 = this.clip(pageX - this.translatePoint.x * Math.pow(2, this.scaleFactor - 1), 0, mapSize - 1) / mapSize - 0.5;
      var y1 = 0.5 - this.clip(pageY - this.translatePoint.y * Math.pow(2, this.scaleFactor - 1), 0, mapSize - 1) / mapSize;
      var lat = 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;
      var lng = 360 * x1;
      return {
        latitude: lat,
        longitude: lng
      };
    };
    SfMaps.prototype.generateTiles = function () {
      var size = {
        width: this.baseMapBounds.availableSize.width,
        height: this.baseMapBounds.availableSize.height
      };
      var xCount = 0;
      var yCount = 0;
      var xLeft = 0;
      var xRight = 0;
      xCount = yCount = Math.pow(2, this.tileZoomLevel);
      var tiles = [];
      if (this.tileTranslatePoint.x + xCount * 256 < size.width) {
        xLeft = this.tileTranslatePoint.x > 0 ? Math.ceil(this.tileTranslatePoint.x / 256) : 0;
        xRight = this.tileTranslatePoint.x + xCount * 256 < size.width ? Math.ceil((size.width - (this.tileTranslatePoint.x + xCount * 256)) / 256) : 0;
      }
      xCount += xLeft + xRight;
      xCount = this.horizontalPanXCount >= xCount ? this.horizontalPanXCount : xCount;
      this.horizontalPan = false;
      var endY = Math.min(yCount, (-this.tileTranslatePoint.y + size.height) / 256 + 1);
      var endX = Math.min(xCount, (-this.tileTranslatePoint.x + size.width + xRight * 256) / 256 + 1);
      var startX = -(this.tileTranslatePoint.x + xLeft * 256 + 256) / 256;
      var startY = -(this.tileTranslatePoint.y + 256) / 256;
      for (var i = Math.round(startX); i < Math.round(endX); i++) {
        for (var j = Math.round(startY); j < Math.round(endY); j++) {
          var x = 256 * i + this.tileTranslatePoint.x;
          var y = 256 * j + this.tileTranslatePoint.y;
          if (x > -256 && x <= size.width && y > -256 && y < size.height) {
            if (j >= 0) {
              var tileI = i;
              if (i < 0) {
                tileI = tileI % yCount + yCount;
              }
              var tile = {
                x: tileI % yCount,
                y: j,
                left: x,
                top: y,
                height: 256,
                width: 256,
                src: null
              };
              if (this.urlTemplate.indexOf('virtualearth') === -1) {
                tile.src = this.urlTemplate.replace('level', this.scaleFactor.toString()).replace('tileX', tile.x.toString()).replace('tileY', tile.y.toString());
              } else {
                tile.src = this.getBingMap(tile, this.urlTemplate);
              }
              tiles.push(tile);
            }
          }
        }
      }
      var animatedElement = document.getElementById(this.element.id + '_animated_tiles');
      var tileArray = [];
      for (var j = 0; j < tiles.length; j++) {
        var tileElement = document.getElementById(this.element.id + 'tile' + j);
        var imgElement = null;
        var isNewTile = false;
        tileArray.push(j);
        if (!tileElement) {
          tileElement = document.createElement('div');
          tileElement.id = this.element.id + 'tile' + j;
          tileElement.style.userSelect = 'none';
          imgElement = document.createElement('img');
          isNewTile = true;
        } else {
          tileElement.style.removeProperty('display');
          imgElement = tileElement.children[0];
        }
        if (imgElement.src !== tiles[j].src) {
          imgElement.setAttribute('src', tiles[j].src);
        }
        tileElement.style.position = 'absolute';
        tileElement.style.left = tiles[j].left + 'px';
        tileElement.style.top = tiles[j].top + 'px';
        tileElement.style.height = tiles[j].height + 'px';
        tileElement.style.width = tiles[j].width + 'px';
        if (isNewTile) {
          tileElement.appendChild(imgElement);
          animatedElement.appendChild(tileElement);
        }
      }
      for (var l = tiles.length; l < animatedElement.childElementCount; l++) {
        var isExistingElement = false;
        for (var a = 0; a < this.currentTiles.childElementCount; a++) {
          if (!isExistingElement && this.currentTiles.children[a].id === animatedElement.children[l].id) {
            isExistingElement = true;
          }
        }
        if (isExistingElement) {
          animatedElement.children[l].style.display = 'none';
        } else {
          animatedElement.removeChild(animatedElement.children[l]);
        }
      }
    };
    SfMaps.prototype.getBingMap = function (tile, imageUrl) {
      var quadKey = '';
      // eslint-disable-next-line prefer-const
      var subDomains = ['t0', 't1', 't2', 't3'];
      var maxZoom = Math.min(this.tileZoomLevel, this.options.maxZoom);
      for (var i = maxZoom; i > 0; i--) {
        var digit = 0;
        var mask = 1 << i - 1;
        if ((tile.x & mask) !== 0) {
          digit++;
        }
        if ((tile.y & mask) !== 0) {
          digit += 2;
        }
        quadKey = quadKey + '' + digit;
      }
      var subDomain = subDomains[Math.min(parseInt(quadKey.substr(quadKey.length - 1, 1), 10), subDomains.length)];
      imageUrl = imageUrl.replace('{quadkey}', quadKey).replace('{subdomain}', subDomain);
      return imageUrl += '&mkt=' + 'en-US' + '&ur=IN&Key=' + this.key;
    };
    SfMaps.prototype.clip = function (value, minValue, maxValue) {
      return Math.min(Math.max(value, minValue), maxValue);
    };
    SfMaps.prototype.svgPoint = function (elem, x, y) {
      var p = this.svg.createSVGPoint();
      p.x = x - (this.isTileMap ? this.areaRect.x : 0);
      p.y = y - (this.isTileMap ? this.areaRect.y : 0);
      return p.matrixTransform(elem.getScreenCTM().inverse());
    };
    SfMaps.prototype.clusterExpand = function (target, options) {
      var datasource = JSON.parse(options.dataSource);
      var layerIndex = parseInt(target[0].split('_LayerIndex_')[1].split('_')[0], 10);
      var clusterSetting = this.markerClusterCollection[layerIndex];
      var data;
      var id = target[0].split('_LayerIndex_');
      var index = parseInt(id[1].split('_')[0], 10);
      var markCollection = [];
      var clusterCollection = [];
      if (target[0].indexOf('_MarkerIndex_') > -1) {
        var markerIndex = parseInt(id[1].split('_MarkerIndex_')[1].split('_')[0], 10);
        var dataIndex = parseInt(id[1].split('_dataIndex_')[1].split('_')[0], 10);
        if (!isNaN(markerIndex)) {
          data = datasource[dataIndex];
          var collection1 = [];
          if (target[0].indexOf('_cluster_') > -1 && clusterSetting.AllowClustering) {
            for (var i = 0; i < datasource.length; i++) {
              if (datasource[i]['Latitude'] === data['Latitude'] && datasource[i]['Longitude'] === data['Longitude']) {
                collection1.push({
                  data: data,
                  index: index
                });
              }
            }
          }
          if (target[0].indexOf('_cluster_') > -1) {
            var isClusterSame = false;
            var clusterElement = document.getElementById(target[0].indexOf('_datalabel_') > -1 ? target[0].split('_datalabel_')[0] : target[0]);
            var indexes = void 0;
            if (this.markerClusterCollection[layerIndex].Shape !== 'Balloon' && !sf.base.isNullOrUndefined(clusterElement)) {
              indexes = clusterElement.innerHTML.split(',').map(String);
            } else if (!sf.base.isNullOrUndefined(clusterElement.firstElementChild)) {
              indexes = clusterElement.firstElementChild.innerHTML.split(',').map(String);
            }
            collection1 = [];
            for (var k = 0; k < indexes.length; k++) {
              var markerData = this.dataSource[layerIndex][parseInt(indexes[k].split(":")[0])][parseInt(indexes[k].split(":")[1])];
              collection1.push({
                data: markerData,
                index: parseInt(indexes[k].split(":")[1])
              });
              markerData['text'] = '';
              markCollection.push(markerData);
            }
            isClusterSame = false;
            clusterCollection.push({
              data: collection1,
              layerIndex: index,
              markerIndex: markerIndex,
              dataIndex: dataIndex,
              targetClusterIndex: +(target[0].split('_cluster_')[1].indexOf('_datalabel_') > -1 ? target[0].split('_cluster_')[1].split('_datalabel_')[0] : target[0].split('_cluster_')[1]),
              isClusterSame: isClusterSame
            });
          }
        }
      }
      if (clusterCollection.length > 0) {
        this.clusterData = clusterCollection;
        var markerGroup = document.getElementById(id[0] + '_LayerIndex_' + layerIndex + '_MarkerGroup');
        if (this.markerClusterExpandCheck) {
          this.mergeSeparateCluster(this.clusterData, id[0]);
          this.markerClusterExpandCheck = false;
        } else {
          this.clusterSeparate(this.clusterData, markerGroup, true, id[0], clusterSetting);
          this.markerClusterExpandCheck = true;
        }
      }
    };
    SfMaps.prototype.mergeSeparateCluster = function (clusterData, id) {
      var layerIndex = clusterData[0].layerIndex;
      var clusterIndex = clusterData[0].targetClusterIndex;
      var markerIndex = clusterData[0].markerIndex;
      var dataIndex = clusterData[0].dataIndex;
      var markerId = id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex;
      var clusterId = markerId + '_dataIndex_' + dataIndex + '_cluster_' + clusterIndex;
      var clusterEle = this.getElementId(clusterId);
      var clusterEleLabel = this.getElementId(clusterId + '_datalabel_' + clusterIndex);
      if (!sf.base.isNullOrUndefined(clusterEle)) {
        clusterEle.style.visibility = 'visible';
      }
      if (!sf.base.isNullOrUndefined(clusterEleLabel)) {
        clusterEleLabel.style.visibility = 'visible';
      }
      var markerEle;
      var markerDataLength = clusterData[0].data.length;
      if (this.clusterLocation.length != 0) {
        var indexes = [];
        if (clusterEle.tagName == 'g') {
          indexes = clusterEle.firstElementChild.innerHTML.split(',').map(String);
        } else {
          indexes = clusterEle.innerHTML.split(',').map(String);
        }
        for (var i = 0; i < markerDataLength; i++) {
          var markerIndex1 = parseInt(indexes[i].split(':')[0]);
          var dataIndex1 = parseInt(indexes[i].split(':')[1]);
          var markerId1 = id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex1;
          markerEle = this.getElementId(markerId1 + '_dataIndex_' + dataIndex1);
          if (!sf.base.isNullOrUndefined(markerEle)) {
            if (markerEle.parentElement.id.indexOf('Template') === -1) {
              var markerInfo = this.markerSettings[layerIndex][markerIndex];
              if (markerInfo.Type === 'Balloon') {
                markerEle.setAttribute('transform', 'translate( ' + this.clusterLocation[i]['x'] + ' ' + this.clusterLocation[i]['y'] + ')' + 'scale( ' + markerInfo.Width / 30 + ' ' + markerInfo.Height / 30 + ' ) ');
              } else {
                markerEle.setAttribute('transform', 'translate( ' + this.clusterLocation[i]['x'] + ' ' + this.clusterLocation[i]['y'] + ')');
              }
            } else {
              markerEle.style.left = this.clusterLocation[i].x + 'px';
              markerEle.style.top = this.clusterLocation[i].y + 'px';
            }
            markerEle.style.visibility = 'hidden';
            markerEle.style.content = 'marker';
            markerEle.classList.add('e-maps-marker-hidden');
          }
        }
      }
      this.clusterLocation = [];
      this.removeElement(id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_markerClusterConnectorLine');
    };
    SfMaps.prototype.removeElement = function (id) {
      var element = document.getElementById(id);
      if (!sf.base.isNullOrUndefined(element)) {
        element.remove();
      }
    };
    SfMaps.prototype.drawPath = function (options) {
      var path = document.getElementById(options.id);
      if (sf.base.isNullOrUndefined(path)) {
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      }
      path.setAttribute('id', options.id);
      path.setAttribute('d', options.d);
      path.setAttribute('opacity', options.opacity.toString());
      path.setAttribute('stroke', options.stroke);
      path.setAttribute('stroke-width', options.strokeWidth.toString());
      if (!sf.base.isNullOrUndefined(options.fill)) {
        path.setAttribute('fill', options.fill);
      }
      return path;
    };
    SfMaps.prototype.clusterSeparate = function (clusterData, markerElement, isDom, id, connectorLine) {
      var layerIndex = clusterData[0].layerIndex;
      var markerIndex = clusterData[0].markerIndex;
      var clusterIndex = clusterData[0].targetClusterIndex;
      var dataIndex = clusterData[0].dataIndex;
      var container = document.getElementById(id);
      var containerBound = container.getBoundingClientRect();
      var getElementFunction = isDom ? this.getElementId : markerElement.querySelector.bind(markerElement);
      var getQueryConnect = isDom ? '' : '#';
      var markerId = id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex;
      var clusterId = markerId + '_dataIndex_' + dataIndex + '_cluster_' + clusterIndex;
      var clusterEle = getElementFunction(getQueryConnect + '' + clusterId);
      var clusterEleLabel = getElementFunction(getQueryConnect + '' + clusterId + '_datalabel_' + clusterIndex);
      clusterEle.style.visibility = 'hidden';
      clusterEleLabel.style.visibility = 'hidden';
      var markerEle = getElementFunction(getQueryConnect + '' + markerId + '_dataIndex_' + dataIndex);
      var height = 25;
      var width = 25;
      var centerX = +clusterEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[0];
      var centerY = +clusterEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[1].split(')')[0].trim();
      var radius = width + 5;
      var area = 2 * 3.14 * radius;
      var totalMarker = 0;
      var numberOfMarker = Math.round(area / width);
      totalMarker += numberOfMarker;
      var markerDataLength = clusterData[0].data.length;
      var percent = Math.round(height / area * 100);
      percent = markerDataLength < numberOfMarker ? 100 / markerDataLength : percent;
      var angle = percent / 100 * 360;
      var newAngle = markerDataLength < numberOfMarker ? 45 : 0;
      var count = 1;
      var start = 'M ' + centerX + ' ' + centerY + ' ';
      var path = '';
      var indexes = [];
      if (clusterEle.tagName == 'g') {
        indexes = clusterEle.firstElementChild.innerHTML.split(',').map(String);
      } else {
        indexes = clusterEle.innerHTML.split(',').map(String);
      }
      for (var i = 0; i < markerDataLength; i++) {
        var markerIndex1 = parseInt(indexes[i].split(':')[0]);
        var dataIndex1 = parseInt(indexes[i].split(':')[1]);
        var markerId1 = id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex1;
        if (totalMarker === i || Math.round(newAngle) >= 360) {
          count++;
          radius = (width + 5) * count;
          newAngle = 0;
          area = 2 * 3.14 * radius;
          numberOfMarker = Math.round(area / height);
          percent = Math.round(height / area * 100);
          while ((percent === 0 ? 1 : percent) * numberOfMarker < 100) {
            numberOfMarker++;
          }
          angle = percent / 100 * 360;
          totalMarker += numberOfMarker;
        }
        var x1 = centerX + radius * Math.sin(Math.PI * 2 * newAngle / 360);
        var y1 = centerY + radius * Math.cos(Math.PI * 2 * newAngle / 360);
        path += start + 'L ' + x1 + ' ' + y1 + ' ';
        markerEle = getElementFunction(getQueryConnect + '' + markerId1 + '_dataIndex_' + dataIndex1);
        if (!sf.base.isNullOrUndefined(markerEle.getAttribute('transform'))) {
          var x = parseFloat(markerEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[0]);
          var y = parseFloat(markerEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[1].split(')')[0].trim());
          this.clusterLocation.push({
            x: x,
            y: y
          });
        } else if (markerEle.parentElement.id.indexOf('Template') > -1) {
          this.clusterLocation.push({
            x: parseFloat(markerEle.style.left.replace('px', '')),
            y: parseFloat(markerEle.style.top.replace('px', ''))
          });
        }
        var markerInfo = this.markerSettings[layerIndex][markerIndex1];
        if (markerEle.parentElement.id.indexOf('Template') === -1) {
          if (markerInfo.Type === 'Balloon') {
            markerEle.setAttribute('transform', 'translate( ' + (x1 - markerInfo.Width / 2) + ' ' + (y1 - markerInfo.Height) + '  ) ' + 'scale( ' + markerInfo.Width / 30 + ' ' + markerInfo.Height / 30 + ' ) ');
          } else {
            markerEle.setAttribute('transform', 'translate( ' + x1 + ' ' + y1 + ')');
          }
        } else {
          markerEle.style.left = x1 + 'px';
          markerEle.style.top = y1 + 'px';
        }
        markerEle['style']['visibility'] = 'visible';
        clusterEleLabel['style']['visibility'] = 'hidden';
        newAngle += angle;
      }
      var options = {
        d: path,
        id: id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex + '_markerClusterConnectorLine',
        stroke: sf.base.isNullOrUndefined(connectorLine.LineColor) ? '#000000' : connectorLine.LineColor,
        opacity: connectorLine.LineOpacity,
        strokeWidth: connectorLine.LineWidth
      };
      markerElement = isDom ? getElementFunction(id + '_LayerIndex_' + layerIndex + '_MarkerGroup') : markerElement;
      var groupEle = createGroup(id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_markerClusterConnectorLine');
      groupEle.appendChild(this.drawPath(options));
      markerElement.insertBefore(groupEle, markerElement.querySelector('#' + markerId + '_dataIndex_0'));
    };
    SfMaps.prototype.getElementId = function (id) {
      return document.getElementById(id);
    };
    SfMaps.prototype.shapeHighlightHandle = function (fill, opacity, layerIndex) {
      var highlighProperty = this.options.layerHighlightSettings[layerIndex];
      this.handleHighlight(this.targetElementPath, 'Shape', {
        BorderColor: highlighProperty['BorderColor'],
        BorderWidth: highlighProperty['BorderWidth'] / this.scaleFactor,
        BorderOpacity: highlighProperty['BorderOpacity'],
        Enable: highlighProperty['Enable'],
        EnableMultiSelect: highlighProperty['EnableMultiSelect'],
        Fill: fill,
        Opacity: opacity
      });
    };
    SfMaps.prototype.itemHighlightHandle = function (fill, opacity, layerIndex, settingIndex, type) {
      if (type === 'Bubble') {
        var bubbleHighlighProperty = this.options.bubbleHighlightSettings[layerIndex][settingIndex];
        this.handleHighlight(this.targetElementPath, 'Bubble', {
          BorderColor: bubbleHighlighProperty['BorderColor'],
          BorderWidth: bubbleHighlighProperty['BorderWidth'],
          BorderOpacity: bubbleHighlighProperty['BorderOpacity'],
          Enable: bubbleHighlighProperty['Enable'],
          EnableMultiSelect: bubbleHighlighProperty['EnableMultiSelect'],
          Fill: fill,
          Opacity: opacity
        });
      }
      if (type === 'Marker') {
        var markerHighlighProperty = this.options.markerHighlightSettings[layerIndex][settingIndex];
        this.handleHighlight(this.targetElementPath, 'Marker', {
          BorderColor: markerHighlighProperty['BorderColor'],
          BorderWidth: markerHighlighProperty['BorderWidth'],
          BorderOpacity: markerHighlighProperty['BorderOpacity'],
          Enable: markerHighlighProperty['Enable'],
          EnableMultiSelect: markerHighlighProperty['EnableMultiSelect'],
          Fill: fill,
          Opacity: opacity
        });
      }
      if (type === 'Navigation') {
        var navigationHighlighProperty = this.options.navigationHighlightSettings[layerIndex][settingIndex];
        for (var i = 0; i <= this.navigation[layerIndex][settingIndex].Latitude.length; i++) {
          var navigationHighlight = document.getElementById(this.element.id + '_LayerIndex_' + layerIndex + '_NavigationIndex_' + 0 + '_Line_' + i);
          this.handleHighlight(navigationHighlight, 'Navigation', {
            BorderColor: navigationHighlighProperty['BorderColor'],
            BorderWidth: navigationHighlighProperty['BorderWidth'],
            BorderOpacity: navigationHighlighProperty['BorderOpacity'],
            Enable: navigationHighlighProperty['Enable'],
            EnableMultiSelect: navigationHighlighProperty['EnableMultiSelect'],
            Fill: fill,
            Opacity: opacity
          });
        }
        if (this.targetElementPath.getAttribute('marker-start') !== '' || this.targetElementPath.getAttribute('marker-end') !== '') {
          var highlightNavigate = document.getElementById(this.targetElementPath['id'] + '_triangle');
          this.handleHighlight(highlightNavigate, 'Arrow', {
            BorderColor: highlightNavigate['BorderColor'],
            BorderWidth: highlightNavigate['BorderWidth'],
            BorderOpacity: highlightNavigate['BorderOpacity'],
            Enable: highlightNavigate['Enable'],
            EnableMultiSelect: highlightNavigate['EnableMultiSelect'],
            Fill: fill,
            Opacity: opacity
          });
        }
      }
      if (type === 'Polygon') {
        var polyonHighlighProperty = this.options.polygonHighlightSettings[layerIndex];
        var polygonHighlight = document.getElementById(this.element.id + '_LayerIndex_' + layerIndex + '_PolygonIndex_' + settingIndex);
        this.handleHighlight(polygonHighlight, 'Polygon', {
          BorderColor: polyonHighlighProperty['BorderColor'],
          BorderWidth: polyonHighlighProperty['BorderWidth'],
          BorderOpacity: polyonHighlighProperty['BorderOpacity'],
          Enable: polyonHighlighProperty['Enable'],
          EnableMultiSelect: polyonHighlighProperty['EnableMultiSelect'],
          Fill: fill,
          Opacity: opacity
        });
      }
    };
    SfMaps.prototype.datalabelAnimate = function (element, duration, opacity, isRect) {
      var height = 0;
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: 0,
        progress: function progress(args) {
          if (args.timeStamp > args.delay) {
            height = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute('style', 'user-select: none; visibility: visible;');
            element.setAttribute(isRect ? 'fill-opacity' : 'opacity', (opacity * height).toString());
          }
        },
        end: function end(model) {
          element.style.visibility = 'visible';
          element.setAttribute(isRect ? 'fill-opacity' : 'opacity', opacity.toString());
        }
      });
    };
    SfMaps.prototype.elementAnimate = function (element, delay, duration, x, y, ele, radius, type, shape, width, markerHeight) {
      var _this = this;
      if (sf.base.isNullOrUndefined(radius)) {
        radius = 0;
      }
      var centerX = x;
      var centerY = y;
      var height = 0;
      new sf.base.Animation({}).animate(element, {
        duration: duration,
        delay: delay,
        progress: function progress(args) {
          if (args.timeStamp > args.delay) {
            height = (args.timeStamp - args.delay) / args.duration;
            element.style.visibility = 'visible';
            element.setAttribute('transform', 'translate( ' + (centerX - radius * height) + ' ' + (centerY - radius * height) + ' ) scale(' + height + ')');
          }
        },
        end: function end(model) {
          element.style.visibility = 'visible';
          element.setAttribute('transform', '');
          if (type === 'Balloon' || shape === 'Balloon') {
            element.setAttribute('transform', 'translate( ' + x + ' ' + y + '  ) ' + 'scale( ' + width / 30 + ' ' + markerHeight / 30 + ' ) ');
          } else {
            element.setAttribute('transform', 'translate( ' + x + ' ' + y + '  )');
          }
          if (!sf.base.isNullOrUndefined(_this.dotNetRef)) {
            _this.dotNetRef.invokeMethodAsync('TriggerAnimation', element);
          }
          if (!ele) {
            return;
          }
        }
      });
    };
    SfMaps.prototype.markerAnimation = function (id, marker) {
      var markers = JSON.parse(marker.markerData);
      for (var i = 0; i < markers.length; i++) {
        for (var j = 0; j < markers[i].MarkerAnimation.length; j++) {
          if (markers[i].MarkerAnimation[j].IsMarkerShape) {
            for (var k = 0; k < markers[i].MarkerAnimation[j].DataSourceLength; k++) {
              var markerChild = document.getElementById(id + '_LayerIndex_' + i + '_MarkerIndex_' + j + '_dataIndex_' + k);
              var shapePath = !sf.base.isNullOrUndefined(this.dataSource[markers[i].MarkerAnimation[j].Layer][j][k][markers[i].MarkerAnimation[j].ShapeValuePath]) ? this.dataSource[markers[i].MarkerAnimation[j].Layer][j][k][markers[i].MarkerAnimation[j].ShapeValuePath] : ' ';
              this.elementAnimate(markerChild, markers[i].MarkerAnimation[j].AnimationDelay, markers[i].MarkerAnimation[j].AnimationDuration, markerChild['transform']['baseVal'][0]['matrix']['e'], markerChild['transform']['baseVal'][0]['matrix']['f'], null, 0, markers[i].MarkerAnimation[j].MarkerType, shapePath, markers[i].MarkerAnimation[j].Width, markers[i].MarkerAnimation[j].Height);
            }
          }
        }
      }
      for (var i = 0; i < this.labelCollection.length; i++) {
        var isAnimation = this.labelCollection[i] != null && this.labelCollection[i].length > 0 ? this.labelCollection[i][0].AnimationDuration > 0 : false;
        if (isAnimation) {
          for (var j = 0; j < (this.labelCollection[i] != null ? this.labelCollection[i].length : 0); j++) {
            var currentLabel = this.labelCollection[i][j];
            var labelChild = document.getElementById(id + '_LayerIndex_' + i + '_shapeIndex_' + j + '_LabelIndex_' + j);
            var labelRectChild = document.getElementById(id + '_LayerIndex_' + i + '_shapeIndex_' + j + '_RectIndex_' + j);
            if (!sf.base.isNullOrUndefined(labelChild)) {
              this.datalabelAnimate(labelChild, currentLabel.AnimationDuration, currentLabel.Font.Opacity, false);
              if (!sf.base.isNullOrUndefined(labelRectChild)) {
                this.datalabelAnimate(labelRectChild, currentLabel.AnimationDuration, currentLabel.Opacity, true);
              }
            }
          }
        }
      }
    };
    SfMaps.prototype.bubbleAnimation = function (id, bubble) {
      var bubbles = JSON.parse(bubble.bubbleData);
      for (var i = 0; i < bubbles.length; i++) {
        for (var j = 0; j < bubbles[i].MarkerAnimation.length; j++) {
          for (var k = 0; k < bubbles[i].MarkerAnimation[j].DataSourceLength; k++) {
            var bubbleChild = document.getElementById(id + '_LayerIndex_' + i + '_BubbleIndex_' + j + '_dataIndex_' + k);
            if (!sf.base.isNullOrUndefined(bubbleChild)) {
              this.elementAnimate(bubbleChild, bubbles[i].MarkerAnimation[j].AnimationDelay, bubbles[i].MarkerAnimation[j].AnimationDuration, bubbleChild['transform']['baseVal'][0]['matrix']['e'], bubbleChild['transform']['baseVal'][0]['matrix']['f'], null, 0, ' ', ' ', 0, 0);
            }
          }
        }
      }
    };
    SfMaps.prototype.toolbarOpacity = function (toolbarButtonOpacity, toolbarShapeOpacity) {
      this.removeZoomOpacity(toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity);
    };
    SfMaps.prototype.clusterMarkerProcess = function () {
      var isClusterCleared = false;
      for (var i = 0; i < this.layerCount; i++) {
        if (!isClusterCleared) {
          this.mergeSeparation();
          this.removeCluster();
          isClusterCleared = true;
        }
        this.clusterMarkers(i);
      }
    };
    SfMaps.prototype.clusterMarkers = function (layerIndex) {
      var markerCluster = this.markerClusterCollection[layerIndex];
      if (markerCluster.AllowClustering) {
        var bounds1 = void 0;
        var bounds2 = void 0;
        var id = this.id;
        var indexCollection = [];
        var colloideBounds = [];
        var tempX = 0;
        var tempY = 0;
        var clusterGroup = createGroup(id + '_LayerIndex_' + layerIndex + '_cluster');
        var postionY = 15 / 4;
        var m = 0;
        var markerCollection = void 0;
        var tempElement = void 0;
        var balloonGroup = void 0;
        var clusterColloideBounds = [];
        var markerTemplateCheck = void 0;
        var containerBound = document.getElementById(id);
        var markerTemplate = document.getElementById(id + '_LayerIndex_' + layerIndex + '_MarkerGroup');
        if (!sf.base.isNullOrUndefined(markerTemplate) && markerTemplate.childElementCount <= 0) {
          if (markerTemplate.childElementCount <= 0) {
            markerTemplate = document.getElementById(id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group');
            markerTemplateCheck = true;
          }
        }
        markerTemplate = !sf.base.isNullOrUndefined(markerTemplate) ? markerTemplate : document.getElementById(id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group');
        if (markerTemplate) {
          for (var o = 0; o < markerTemplate.childElementCount; o++) {
            if (!(markerTemplate.children[o]['id'].indexOf('markerClusterConnectorLine') > -1)) {
              indexCollection = [];
              var markerIndex = parseInt(markerTemplate.children[o]['id'].split('_MarkerIndex_')[1].split('_')[0], 10);
              var dataIndex = parseInt(markerTemplate.children[o]['id'].split('_dataIndex_')[1].split('_')[0], 10);
              var isBalloonShape = (this.markerSettings[layerIndex][markerIndex]['Type'] === 'Balloon' || this.markerSettings[layerIndex][markerIndex]['Type'] === 'Image') && sf.base.isNullOrUndefined(this.markerSettings[layerIndex][markerIndex]['ShapeValuePath']);
              if (markerTemplate.children[o]['style']['visibility'] !== 'hidden') {
                tempElement = markerTemplate.children[o];
                var bounds1_1 = tempElement.getBoundingClientRect();
                indexCollection.push(markerIndex.toString() + ":" + dataIndex.toString());
                if (bounds1_1 !== null) {
                  for (var p = o + 1; p < markerTemplate.childElementCount; p++) {
                    if (markerTemplate.children[p]['style']['visibility'] !== 'hidden') {
                      tempElement = markerTemplate.children[p];
                      var secondMarkerIndex = parseInt(tempElement['id'].split('_MarkerIndex_')[1].split('_')[0], 10);
                      var secondDataIndex = parseInt(tempElement['id'].split('_dataIndex_')[1].split('_')[0], 10);
                      var bounds2_1 = tempElement.getBoundingClientRect();
                      if (bounds2_1 !== null) {
                        if (!(bounds1_1.left > bounds2_1.right || bounds1_1.right < bounds2_1.left || bounds1_1.top > bounds2_1.bottom || bounds1_1.bottom < bounds2_1.top)) {
                          colloideBounds.push(bounds2_1);
                          markerTemplate.children[p].style.visibility = 'hidden';
                          markerTemplate.children[p].style.content = 'marker';
                          markerTemplate.children[p].classList.add('e-maps-marker-hidden');
                          indexCollection.push(secondMarkerIndex.toString() + ":" + secondDataIndex.toString());
                        }
                      }
                    }
                  }
                  tempX = bounds1_1.left + bounds1_1.width / 2;
                  tempY = bounds1_1.top + (isBalloonShape ? bounds1_1.height : bounds1_1.height / 2);
                  if (colloideBounds.length > 0) {
                    var container = containerBound.getBoundingClientRect();
                    tempX = this.isTileMap ? tempX - container['left'] - this.areaRect.x : tempX - container['left'];
                    tempY = this.isTileMap ? tempY - container['top'] - this.areaRect.y : tempY - container['top'];
                    var dataIndex_2 = parseInt(markerTemplate.children[o]['id'].split('_dataIndex_')[1].split('_')[0], 10);
                    var layerIndex_2 = parseInt(markerTemplate.children[o]['id'].split('_LayerIndex_')[1].split('_')[0], 10);
                    var transform = markerTemplate.children[o].getAttribute('transform');
                    if (transform) {
                      tempX += this.isTileMap ? 0 : markerTemplateCheck ? this.areaRect.x : 0;
                      tempY += this.isTileMap ? 0 : markerTemplateCheck ? this.areaRect.y : 0;
                    } else {
                      tempX = parseFloat(markerTemplate.children[o]['style']['left'].replace('px', '')) + (this.isTileMap ? 0 : markerTemplateCheck ? this.areaRect.x : 0);
                      tempY = parseFloat(markerTemplate.children[o]['style']['top'].replace('px', '')) + (this.isTileMap ? 0 : markerTemplateCheck ? this.areaRect.y : 0);
                    }
                    var clusterID = id + '_LayerIndex_' + layerIndex_2 + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex_2 + '_cluster_' + m;
                    var labelID = id + '_LayerIndex_' + layerIndex_2 + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex_2 + '_cluster_' + m + '_datalabel_' + m;
                    m++;
                    var shape = void 0;
                    switch (markerCluster.Shape) {
                      case 'Circle':
                        shape = this.createClusterShape('circle', clusterID, markerCluster.Fill, markerCluster.Opacity, 'translate( ' + tempX + ' ' + tempY + ' )', true, indexCollection, markerCluster);
                        shape.setAttribute('r', (markerCluster.Height + markerCluster.Width) / 4);
                        break;
                      case 'Rectangle':
                        shape = this.createClusterShape('rect', clusterID, markerCluster.Fill, markerCluster.Opacity, 'translate( ' + tempX + ' ' + tempY + ' )', true, indexCollection, markerCluster);
                        shape.setAttribute('x', -(markerCluster.Width / 2));
                        shape.setAttribute('y', -(markerCluster.Height / 2));
                        shape.setAttribute('height', markerCluster.Height);
                        shape.setAttribute('width', markerCluster.Width);
                        break;
                      case 'Balloon':
                        balloonGroup = createGroup(clusterID);
                        var balloonPath = 'M15,0C8.8,0,3.8,5,3.8,11.2C3.8,17.5,9.4,24.4,15,30c5.6-5.6,11.2-12.5,11.2-18.8C26.2,5,21.2,0,15,0z M15,16' + 'c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S17.8,16,15,16z';
                        shape = this.createClusterShape('path', clusterID, markerCluster.Fill, markerCluster.Opacity, 'translate( ' + -(markerCluster.Width / 2) + ', ' + -markerCluster.Height + ' ) scale( ' + markerCluster.Width / 30 + ', ' + markerCluster.Height / 30 + ' )', true, indexCollection, markerCluster);
                        shape.classList.remove('clusterGroup');
                        shape.setAttribute('d', balloonPath);
                        balloonGroup.appendChild(shape);
                        balloonGroup.style.visibility = 'visible';
                        balloonGroup.style.cursor = 'pointer';
                        balloonGroup.setAttribute('class', 'clusterGroup');
                        if (markerTemplateCheck) {
                          balloonGroup.classList.add('e-maps-cluster');
                        }
                        balloonGroup.setAttribute('transform', 'translate( ' + tempX + ' ' + tempY + ' )');
                        break;
                      case 'Image':
                        var locationX = 0;
                        var locationY = 0;
                        var x = -(locationX + markerCluster.Width / 2);
                        var y = -(locationY + markerCluster.Height / 2);
                        shape = this.createClusterShape('image', clusterID, null, null, 'translate( ' + tempX + ' ' + tempY + ' )', true, indexCollection, markerCluster);
                        shape.setAttributeNS(null, 'height', markerCluster.Height);
                        shape.setAttributeNS(null, 'width', markerCluster.Width);
                        shape.setAttributeNS('http://www.w3.org/1999/xlink', 'href', markerCluster.ImageUrl);
                        shape.setAttributeNS(null, 'x', x);
                        shape.setAttributeNS(null, 'y', y);
                        break;
                      case 'Cross':
                      case 'Diamond':
                      case 'Star':
                      case 'Triangle':
                      case 'HorizontalLine':
                      case 'VerticalLine':
                      case 'InvertedTriangle':
                      case 'Pentagon':
                        var path = '';
                        path = calculateShape(markerCluster.Shape, {
                          height: markerCluster.Height,
                          width: markerCluster.Width
                        }, {
                          x: 0,
                          y: 0
                        });
                        shape = this.createClusterShape('path', clusterID, markerCluster.Fill, markerCluster.Opacity, 'translate( ' + tempX + ' ' + tempY + ' )', false, indexCollection, markerCluster);
                        shape.setAttribute('d', path);
                        if (markerCluster.Shape === 'Cross' || markerCluster.Shape === 'HorizontalLine' || markerCluster.Shape === 'VerticalLine') {
                          shape.setAttribute('stroke', markerCluster.Fill);
                          shape.setAttribute('stroke-width', ((markerCluster.Width + markerCluster.Height) / 4).toString());
                        }
                        break;
                    }
                    if (markerCluster.Shape !== 'Balloon') {
                      if (!(markerTemplateCheck && this.isTileMap)) {
                        shape.setAttribute('class', 'clusterGroup');
                      }
                    }
                    if (markerTemplateCheck && markerCluster.Shape !== 'Balloon') {
                      shape.classList.add('e-maps-cluster');
                    }
                    var textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('id', labelID);
                    textElement.setAttribute('x', '0');
                    textElement.setAttribute('y', postionY.toString());
                    textElement.setAttribute('fill', markerCluster.LabelColor);
                    textElement.setAttribute('font-size', markerCluster.LabelSize);
                    textElement.setAttribute('font-style', markerCluster.LabelFontStyle);
                    textElement.setAttribute('font-family', markerCluster.LabelFontFamily);
                    textElement.setAttribute('font-weight', markerCluster.LabelFontWeight);
                    textElement.setAttribute('text-anchor', 'middle');
                    textElement.setAttribute('transform', 'translate( ' + tempX + ' ' + tempY + ' )');
                    textElement.setAttribute('opacity', markerCluster.LabelOpacity);
                    textElement.style.visibility = 'visible';
                    textElement.style.cursor = 'pointer';
                    textElement.setAttribute('class', 'clusterGroup');
                    textElement.innerHTML = (colloideBounds.length + 1).toString();
                    if (markerTemplateCheck) {
                      textElement.classList.add('e-maps-cluster');
                    }
                    clusterGroup.appendChild(textElement);
                    clusterGroup.setAttribute('class', 'clusterGroup');
                    if (markerCluster.Shape !== 'Balloon') {
                      clusterGroup.appendChild(shape);
                    } else {
                      clusterGroup.appendChild(balloonGroup);
                    }
                    markerTemplate.children[o].style.visibility = 'hidden';
                    markerTemplate.children[o].style.content = 'marker';
                    markerTemplate.children[o].classList.add('e-maps-marker-hidden');
                  }
                  colloideBounds = [];
                }
              }
            }
          }
        }
        if (clusterGroup.childElementCount > 0) {
          var layerElement = document.getElementById(id + '_LayerIndex_' + layerIndex);
          layerElement.appendChild(clusterGroup);
          markerCollection = document.getElementById(id + '_LayerIndex_' + layerIndex + '_MarkerGroup');
          for (var o = 0; o < clusterGroup.childElementCount; o++) {
            if (clusterGroup.children[o]['style']['visibility'] !== 'hidden') {
              tempElement = clusterGroup.children[o];
              bounds1 = tempElement.getBoundingClientRect();
              if (bounds1 !== null && !(tempElement.id.indexOf('_datalabel_') > -1)) {
                for (var p = o + 1; p < clusterGroup.childElementCount; p++) {
                  if (clusterGroup.children[p]['style']['visibility'] !== 'hidden') {
                    var tempElement1 = clusterGroup.children[p];
                    var markerIndex = parseInt(tempElement1['id'].split('_MarkerIndex_')[1].split('_')[0], 10);
                    var dataIndex = parseInt(tempElement1['id'].split('_dataIndex_')[1].split('_')[0], 10);
                    bounds2 = tempElement1.getBoundingClientRect();
                    if (bounds2 !== null && !(tempElement1.id.indexOf('_datalabel_') > -1)) {
                      if (!(bounds1.left > bounds2.right || bounds1.right < bounds2.left || bounds1.top > bounds2.bottom || bounds1.bottom < bounds2.top)) {
                        clusterColloideBounds.push(tempElement1);
                        clusterColloideBounds.push(clusterGroup.children[p - 1]);
                        clusterGroup.children[p]['style']['visibility'] = 'hidden';
                        clusterGroup.children[p - 1]['style']['visibility'] = 'hidden';
                        indexCollection.push(markerIndex.toString() + ":" + dataIndex.toString());
                      }
                    }
                  }
                }
                if (clusterColloideBounds.length > 0) {
                  tempElement = clusterGroup.children[o];
                  for (var i = 0; i < clusterColloideBounds.length; i++) {
                    if (tempElement.tagName === 'g') {
                      tempElement.children[0].textContent = tempElement.children[0].textContent + ',' + clusterColloideBounds[i].textContent;
                    } else {
                      tempElement.textContent = tempElement.textContent + ',' + clusterColloideBounds[i].textContent;
                    }
                    clusterGroup.children[o - 1].textContent = (+clusterGroup.children[o - 1].textContent + +clusterColloideBounds[i + 1].textContent).toString();
                    i++;
                  }
                }
                clusterColloideBounds = [];
              }
            }
          }
          while (0 < clusterGroup.children.length) {
            markerCollection.insertBefore(clusterGroup.children[0], markerCollection.firstChild);
          }
          layerElement = document.getElementById(id + '_LayerIndex_' + layerIndex);
          layerElement.appendChild(markerCollection);
          layerElement.removeChild(clusterGroup);
        }
      }
    };
    SfMaps.prototype.createClusterShape = function (shapeType, id, fill, opacity, transform, isClass, indexCollection, border) {
      var shape = document.createElementNS('http://www.w3.org/2000/svg', shapeType);
      shape.setAttribute('id', id);
      shape.setAttribute('fill', fill);
      shape.setAttribute('stroke', border['BorderColor']);
      shape.setAttribute('stroke-width', border['BorderWidth']);
      shape.setAttribute('stroke-dasharray', border['DashArray']);
      shape.setAttribute('fill-opacity', opacity);
      shape.setAttribute('stroke-opacity', border['BorderOpacity']);
      shape.setAttribute('transform', transform);
      shape.setAttribute('style', 'visibility:visible');
      shape.setAttribute('style', 'cursor: pointer');
      if (!isClass) {
        shape.setAttribute(null, 'class', 'clusterGroup');
      } else {
        shape.setAttribute('class', 'clusterGroup');
      }
      shape.innerHTML = indexCollection;
      return shape;
    };
    SfMaps.prototype.mergeSeparation = function () {
      if (this.markerClusterExpandCheck && this.clusterData) {
        this.mergeSeparateCluster(this.clusterData, this.id);
        this.markerClusterExpandCheck = false;
      }
    };
    SfMaps.prototype.click = function (event) {
      var _this = this;
      if (event.type === 'pointerdown' && event.pointerType === 'mouse') {
        return;
      }
      var id = event.target['id'];
      var clientValue = this.getMousePosition(event.pageX, event.pageY);
      var parentId = id.split('_')[0];
      if ((id.indexOf('_Left_Page_Rect') > -1 || id.indexOf('_Right_Page_Rect') > -1) && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.dotNetRef.invokeMethodAsync('TriggerLegendPaging', id.indexOf('_Left_Page_Rect') > -1 ? 1 : 0);
      }
      if (id.indexOf('_Zooming_') > -1 && this.options.enableZoom) {
        var eventType = event.type === 'pointerdown' ? 'click' : event.type;
        var factor = 1;
        this.mergeSeparation();
        if (id.indexOf('_ZoomIn_') > -1) {
          factor = this.factorCount === 0 ? this.options.factor + 1 : this.scaleFactor + 1;
          this.factorCount++;
          this.triggerEnableZoom(factor, id.split('_Zooming_ToolBar_')[1].split('_')[0], eventType);
        }
        if (id.indexOf('_ZoomOut_') > -1) {
          factor = this.factorCount === 0 ? this.options.factor - 1 : this.scaleFactor - 1;
          this.factorCount++;
          this.triggerEnableZoom(factor, id.split('_Zooming_ToolBar_')[1].split('_')[0], eventType);
        }
        if (id.indexOf('_Reset_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.zoomClick = false;
          var zoomType = id.split('_Zooming_ToolBar_')[1].split('_')[0];
          this.removeCluster();
          this.dotNetRef.invokeMethodAsync('TriggerZoom', zoomType, eventType);
        }
        if (id.indexOf('_Zoom_') > -1) {
          if (document.getElementById(this.id + '_Zooming_ToolBar_Zoom_Rect').getAttribute('stroke-opacity') !== '0.3') {
            this.zoomClick = true;
            this.allowPanning = false;
            this.enableSelectionZoom = true;
          }
        }
        if (id.indexOf('_Pan_') > -1) {
          if (document.getElementById(this.id + '_Zooming_ToolBar_Pan_Rect').getAttribute('stroke-opacity') !== '0.3') {
            this.zoomClick = false;
            this.allowPanning = false;
            this.enableSelectionZoom = false;
            this.isPan = true;
          }
        }
      }
      if (id.indexOf("MapAreaBorder") > -1 || id.indexOf("shapeIndex") > -1 || id.indexOf("_Legend_") > -1 || id.indexOf("BubbleIndex") > -1 || id.indexOf("Zooming") > -1 || id.indexOf("MapMargin") > -1 || id === '' || this.markerClusterExpandCheck) {
        this.mergeSeparation();
      }
      if ((id === '' || id.indexOf(this.element.id) === -1) && !sf.base.isNullOrUndefined(event.target['offsetParent'])) {
        var parentId_2 = event.target['offsetParent']['id'];
        id = parentId_2.indexOf('_MarkerIndex_') > -1 ? parentId_2 : id;
      }
      if (id.indexOf('_LayerIndex_') > -1 && id.indexOf('_MarkerIndex_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var markerIndex = parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10);
        var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
        var element = document.getElementById(id);
        var dataElement = void 0;
        if (id.indexOf('cluster') > -1 || id.indexOf('Cluster') > -1) {
          this.mergeSeparation();
          if (id.indexOf('_cluster_') > -1 && id.indexOf('_datalabel_') > -1) {
            element = document.getElementById(id.split('_datalabel')[0]);
          }
          if (this.markerClusterCollection[layerIndex].Shape === 'Balloon') {
            if (!sf.base.isNullOrUndefined(element.firstElementChild) && element.firstElementChild.innerHTML.length > 0) {
              dataElement = element.firstElementChild.innerHTML.split(',');
            }
          } else {
            if (!sf.base.isNullOrUndefined(element) && element.innerHTML.length > 0) {
              dataElement = element.innerHTML.split(',');
            }
          }
        }
        this.removeAllHighlight();
        if (!(id.indexOf('markerClusterConnectorLine') > -1) && id.indexOf('_MarkerIndex_') > -1 || id.indexOf('cluster') > -1 && (event.type == "click" || event.type == "pointerdown")) {
          this.dotNetRef.invokeMethodAsync('TriggerMarkerClick', layerIndex, markerIndex, dataIndex, id, clientValue.x, clientValue.y, dataElement, id.indexOf('cluster') > -1 ? 'cluster' : 'marker', this.isTouch, event['layerX'], event['layerY']);
        }
      }
      if (id.indexOf('shapeIndex') > -1 && this.options.tooltipDisplayMode === 'Click' && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var shapeIndex = parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, shapeIndex, 'Shape', 0);
      }
      if (id.indexOf('_LayerIndex_') > -1 && id.indexOf('BubbleIndex') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var markerIndex = parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10);
        var dataIndex = parseInt(id.split('_dataIndex_')[1].split('_')[0], 10);
        var element = document.getElementById(id);
        this.dotNetRef.invokeMethodAsync('TriggerBubbleClick', layerIndex, markerIndex, dataIndex, id, clientValue.x, clientValue.y, event['layerX'], event['layerY']);
      }
      if (id.indexOf('_Legend_') > -1 && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.removeAllHighlight();
        if (!(event.pointerType === "touch" && event.type === "pointerdown")) {
          this.dotNetRef.invokeMethodAsync('TriggerLegendClick', parseInt(id.split('_Index_')[1].split('_')[0], 10));
        }
      }
      if (id.indexOf('_shapeIndex_') === -1 && id.indexOf('_MarkerIndex_') === -1 && id.indexOf('_BubbleIndex_') === -1 && this.options.tooltipDisplayMode === 'Click' && !sf.base.isNullOrUndefined(this.dotNetRef)) {
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
      }
      if (event.pointerType === 'touch' && id.indexOf('_cluster_') === -1 && (id.indexOf('_shapeIndex_') > -1 || id.indexOf('BubbleIndex') > -1 || id.indexOf('_MarkerIndex_') > -1)) {
        var layerIndex = parseInt(id.split('_LayerIndex_')[1].split('_')[0], 10);
        var markerIndex = id.indexOf('_BubbleIndex_') > -1 ? parseInt(id.split('_BubbleIndex_')[1].split('_')[0], 10) : id.indexOf('_MarkerIndex_') > -1 ? parseInt(id.split('_MarkerIndex_')[1].split('_')[0], 10) : parseInt(id.split('_shapeIndex_')[1].split('_')[0], 10);
        var dataIndex = id.indexOf('_BubbleIndex_') > -1 || id.indexOf('_MarkerIndex_') > -1 ? parseInt(id.split('_dataIndex_')[1].split('_')[0], 10) : 0;
        var type = id.indexOf('_BubbleIndex_') > -1 ? "Bubble" : id.indexOf('_MarkerIndex_') > -1 ? "Marker" : "Shape";
        clearTimeout(this.tooltipCountTimer);
        this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', id, clientValue.x, clientValue.y, layerIndex, type === 'Shape' ? markerIndex : dataIndex, type, markerIndex);
        this.tooltipCountTimer = setTimeout(function () {
          _this.dotNetRef.invokeMethodAsync('TriggerShapeTooltip', '', clientValue.x, clientValue.y, 0, 0, '', 0);
        }, 1500);
      }
      this.renderTitleTooltip(id, clientValue, event);
      this.renderLegendTitleTooltip(id, clientValue, event);
      this.renderLegendTextTooltip(id, clientValue, event);
      this.renderInteractiveLegend(id, event);
    };
    SfMaps.prototype.removeCluster = function () {
      var samecluster = document.querySelectorAll('[class="clusterGroup"]');
      if (samecluster.length > 0) {
        for (var i_1 = 0; i_1 < samecluster.length; i_1++) {
          document.getElementById(samecluster[i_1].id).remove();
        }
      } else {
        samecluster = document.querySelectorAll('[class="clusterGroup e-maps-cluster"]');
        if (samecluster.length > 0) {
          for (var i = 0; i < samecluster.length; i++) {
            document.getElementById(samecluster[i].id).remove();
          }
        }
      }
      var visibleMarker = document.querySelectorAll('[class="e-maps-marker-hidden"]');
      for (var i_2 = 0; i_2 < visibleMarker.length; i_2++) {
        var visibilityChange = document.getElementById(visibleMarker[i_2].id);
        visibilityChange.style.visibility = 'visible';
        visibilityChange.classList.remove('e-maps-marker-hidden');
      }
    };
    SfMaps.prototype.createImageUrl = function (element, type) {
      var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element.outerHTML + '</svg>';
      return window.URL.createObjectURL(new Blob(type === 'SVG' ? [svgData] : [new XMLSerializer().serializeToString(element)], {
        type: 'image/svg+xml'
      }));
    };
    SfMaps.prototype.imageExport = function (type, fileName, allowDownload, theme) {
      return __awaiter(this, void 0, void 0, function () {
        var proxy;
        return __generator(this, function (_a) {
          proxy = this;
          return [2 /*return*/, new Promise(function (resolve, reject) {
            var imageCanvasElement = document.createElement('canvas');
            var elementBound = proxy.element.getBoundingClientRect();
            imageCanvasElement.width = elementBound.width;
            imageCanvasElement.height = elementBound.height;
            var element = document.getElementById(proxy.element.id + '_svg');
            var url = proxy.createImageUrl(element, type);
            var tileElementCount = document.getElementById(proxy.element.id + '_animated_tiles').children.length;
            var context = imageCanvasElement.getContext('2d');
            var titleElement = document.getElementById(proxy.element.id + '_Map_title');
            var borderElement = document.getElementById(proxy.element.id + '_MapMargin');
            if (!sf.base.isNullOrUndefined(borderElement)) {
              context.fillStyle = borderElement.getAttribute('fill');
              if ((theme === 'Tailwind' || theme === 'Bootstrap5' || theme === 'Fluent' || theme === 'Material3') && (context.fillStyle === 'rgba(255, 255, 255, 0)' || context.fillStyle === 'rgba(0, 0, 0, 0)' || context.fillStyle === 'transparent')) {
                context.fillStyle = 'rgba(255,255,255, 1)';
              } else if ((theme === 'TailwindDark' || theme === 'Bootstrap5Dark' || theme === 'FluentDark' || theme === 'Material3Dark') && (context.fillStyle === 'rgba(255, 255, 255, 0)' || context.fillStyle === 'rgba(0, 0, 0, 0)' || context.fillStyle === 'transparent')) {
                context.fillStyle = 'rgba(0, 0, 0, 1)';
              }
              context.fillRect(0, 0, elementBound.width, elementBound.height);
            }
            if (!sf.base.isNullOrUndefined(titleElement)) {
              context.font = titleElement.getAttribute('font-size') + ' Arial';
              context.fillStyle = titleElement.getAttribute('fill');
              context.fillText(titleElement.textContent, parseFloat(titleElement.getAttribute('x')), parseFloat(titleElement.getAttribute('y')));
            }
            context.save();
            var svgParent = document.getElementById(proxy.element.id + '_Tile_SVG_Parent');
            context.rect(parseFloat(svgParent.style.left), parseFloat(svgParent.style.top), parseFloat(svgParent.style.width), parseFloat(svgParent.style.height));
            context.clip();
            context.fillRect(0, 0, elementBound.width, elementBound.height);
            proxy.exportedCount = 0;
            var promises = [];
            for (var i = 0; i < tileElementCount; i++) {
              var tile = document.getElementById(proxy.element.id + 'tile' + i);
              var exportTileImg = new Image();
              exportTileImg.crossOrigin = 'Anonymous';
              promises.push(proxy.renderImages(imageCanvasElement, tile, context, exportTileImg, tileElementCount, type, fileName, url, proxy, allowDownload));
              exportTileImg.src = tile.children[0].getAttribute('src');
            }
            Promise.all(promises).then(function (values) {
              for (var i = 0; i < values.length; i++) {
                if (values[i] != null) {
                  resolve(values[i]);
                  break;
                }
              }
            });
          })];
        });
      });
    };
    SfMaps.prototype.renderImages = function (canvasElement, tile, context, exportTileImg, tileElementCount, type, fileName, url, proxy, allowDownload) {
      return new Promise(function (resolve, reject) {
        exportTileImg.onload = function () {
          proxy.exportedCount++;
          context.setTransform(1, 0, 0, 1, parseFloat(tile.style.left) + 10, parseFloat(tile.style.top) + parseFloat(document.getElementById(proxy.element.id + '_tile_parent').style.top));
          var tileBorder = 1;
          context.drawImage(exportTileImg, 0, 0, 256 + tileBorder, 256 + tileBorder);
          if (proxy.exportedCount === tileElementCount) {
            var svgParent_1 = document.getElementById(proxy.element.id + '_Tile_SVG_Parent');
            url = proxy.createImageUrl(svgParent_1.children[0], type);
            var image_1 = new Image();
            image_1.onload = function () {
              context.setTransform(1, 0, 0, 1, parseFloat(svgParent_1.style.left), parseFloat(svgParent_1.style.top));
              context.drawImage(image_1, 0, 0);
              if (allowDownload) {
                proxy.triggerDownload(type, fileName, canvasElement.toDataURL('image/png').replace('image/png', 'image/octet-stream'));
                resolve(null);
              } else {
                var base64String = type === 'JPEG' ? canvasElement.toDataURL('image/jpeg') : type === 'PNG' ? canvasElement.toDataURL('image/png') : '';
                resolve(base64String);
              }
            };
            image_1.src = url;
          } else {
            resolve(null);
          }
        };
      });
    };
    SfMaps.prototype.triggerDownload = function (type, fileName, url) {
      var anchorElement = document.createElement('a');
      anchorElement.download = fileName + '.' + type.toLocaleLowerCase();
      anchorElement.href = url;
      anchorElement.click();
    };
    SfMaps.prototype.getMousePosition = function (pageX, pageY) {
      var elementRect = this.element.getBoundingClientRect();
      var pageXOffset = this.element.ownerDocument.defaultView.pageXOffset;
      var pageYOffset = this.element.ownerDocument.defaultView.pageYOffset;
      var clientTop = this.element.ownerDocument.documentElement.clientTop;
      var clientLeft = this.element.ownerDocument.documentElement.clientLeft;
      this.positionX = elementRect.left + pageXOffset - clientLeft;
      this.positionY = elementRect.top + pageYOffset - clientTop;
      return new MapLocation(pageX - this.positionX, pageY - this.positionY);
    };
    SfMaps.prototype.getBound = function (id) {
      var element = document.getElementById(id);
      return {
        x: element.offsetLeft,
        y: element.offsetTop
      };
    };
    SfMaps.prototype.createToolbarStyle = function (color, parentToolbar) {
      var zoomPath = document.getElementById(this.element.id + '_Zooming_ToolBar_Zoom_Path');
      if (!sf.base.isNullOrUndefined(zoomPath)) {
        zoomPath.setAttribute('stroke', this.toolbarColor);
      }
      if (!this.enableSelectionZoom) {
        this.zoomClick = false;
      }
      var zoomStyle = document.getElementById(this.element + '_zoomToolbar_style');
      if (zoomStyle) {
        zoomStyle.parentNode.removeChild(zoomStyle);
      }
      var css = '.e-maps-toolbar:hover { opacity:1; } .e-maps-toolbar:hover > circle { stroke:' + color + '; } .e-maps-toolbar:hover > path { fill: ' + color + ' ;  stroke: ' + color + '; }' + '.e-maps-toolbar:hover { cursor: pointer; } .e-maps-cursor-disable:hover { cursor: not-allowed; } .e-maps-panning:hover { cursor: pointer; } ' + '.e-maps-popup-close { display: block; opacity: 0; }';
      var style = document.createElement('style');
      style.id = this.element + '_zoomToolbar_style';
      style.appendChild(document.createTextNode(css));
      parentToolbar.appendChild(style);
    };
    SfMaps.prototype.render = function () {
      this.wireEvents();
    };
    return SfMaps;
  }();
  var Maps = {
    getMarker: function getMarker(target, options, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.clusterExpand(target, options);
      }
    },
    markerCluster: function markerCluster(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.clusterMarkerProcess();
      }
    },
    clusterSeperation: function clusterSeperation(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.mergeSeparation();
      }
    },
    itemHighlight: function itemHighlight(fill, opacity, layerIndex, settingIndex, type, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.itemHighlightHandle(fill, opacity, layerIndex, settingIndex, type);
      }
    },
    shapeHighlight: function shapeHighlight(fill, opacity, layerIndex, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.shapeHighlightHandle(fill, opacity, layerIndex);
      }
    },
    panDirection: function panDirection(xDiff, yDiff, x, y, scale, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        var animatedTiles = document.getElementById(instance.element.id + '_animated_tiles');
        if (instance.isTileMap && !sf.base.isNullOrUndefined(animatedTiles)) {
          instance.currentTiles = animatedTiles.cloneNode(true);
        }
        instance.panning(xDiff, yDiff, x, y, scale, false);
        if (!sf.base.isNullOrUndefined(instance.dotNetRef)) {
          instance.dotNetRef.invokeMethodAsync('UpdateTranslatePoint', instance.isTileMap ? instance.translatePoint : instance.shapeTranslatePoint, instance.tileTranslatePoint, instance.scaleFactor, false);
        }
      }
    },
    initialize: function initialize(element, options, dotNetRef) {
      var instance = new SfMaps(element.id, element, options, dotNetRef);
      instance.render();
      return this.getElementSize(element.id);
    },
    updateInstance: function updateInstance(id, options) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.dataSource = options.dataSource ? JSON.parse(options.dataSource) : null;
        instance.options.layerHighlightSettings = JSON.parse(options.layerHighlightSettings);
        instance.options.markerHighlightSettings = JSON.parse(options.markerHighlightSettings);
        instance.options.bubbleHighlightSettings = JSON.parse(options.bubbleHighlightSettings);
        instance.options.navigationHighlightSettings = JSON.parse(options.navigationHighlightSettings);
        instance.options.polygonHighlightSettings = JSON.parse(options.polygonHighlightSettings);
        instance.options.selectionSettings = JSON.parse(options.selectionSettings);
      }
    },
    getElementSize: function getElementSize(id) {
      var elementWidth;
      var elementHeight;
      var x;
      var y;
      var element = document.getElementById(id);
      if (element !== null) {
        var elementRect = element.getBoundingClientRect();
        elementWidth = elementRect.width;
        elementHeight = elementRect.height;
        x = elementRect['x'];
        y = elementRect['y'];
      }
      return {
        width: elementWidth,
        height: elementHeight,
        isIE: sf.base.Browser.isIE,
        x: x,
        y: y,
        isDevice: sf.base.Browser.isDevice
      };
    },
    getElementBounds: function getElementBounds(id) {
      var htmlElement = document.getElementById(id);
      if (htmlElement) {
        var bounds = htmlElement.getBoundingClientRect();
        return {
          width: bounds.width,
          height: bounds.height,
          top: bounds.top,
          bottom: bounds.bottom,
          left: bounds.left,
          right: bounds.right
        };
      }
      return null;
    },
    getBound: function getBound(id) {
      var element = document.getElementById(id);
      return {
        x: element.offsetLeft,
        y: element.offsetTop
      };
    },
    getBoundData: function getBoundData(id) {
      var element = document.getElementById(id);
      return {
        x: element.getBoundingClientRect()['x'],
        y: element.getBoundingClientRect()['y']
      };
    },
    getTileZoom: function getTileZoom(id, left, top, url, height, width, index) {
      return __awaiter(this, void 0, void 0, function () {
        var element, scale, image, layerElement, i, j, k, layerIndex, markerIndex, dataIndex, point;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              element = document.getElementById(id + '_animated_tiles');
              scale = parseInt(element['className'], 10);
              element.children[index].setAttribute('style', 'top:' + '' + top + '; height:' + '' + height + ';width:' + '' + width + '; left:' + '' + left + '; position:absolute;');
              element.children[index].innerHTML = '';
              image = document.createElement('img');
              image.src = url;
              element.children[index].appendChild(image);
              layerElement = document.getElementById(id + '_LayerCollections');
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < layerElement.children.length)) return [3 /*break*/, 8];
              j = 0;
              _a.label = 2;
            case 2:
              if (!(j < layerElement.children[i].childElementCount)) return [3 /*break*/, 7];
              if (!(layerElement.children[i].children[j].id.indexOf('MarkerGroup') > -1)) return [3 /*break*/, 6];
              k = 0;
              _a.label = 3;
            case 3:
              if (!(k < layerElement.children[i].children[j].childElementCount)) return [3 /*break*/, 6];
              layerIndex = parseInt(layerElement.children[i].children[j].children[k].id.split('_LayerIndex_')[1].split('_')[0], 10);
              markerIndex = parseInt(layerElement.children[i].children[j].children[k].id.split('_MarkerIndex_')[1].split('_')[0], 10);
              dataIndex = parseInt(layerElement.children[i].children[j].children[k].id.split('_dataIndex_')[1].split('_')[0], 10);
              return [4 /*yield*/, this.dotNetRef.invokeMethodAsync('ZoomMarker', layerIndex, markerIndex, dataIndex, 0, 0, scale)];
            case 4:
              point = _a.sent();
              layerElement.children[i].children[j].children[k].setAttribute('transform', 'translate(' + point[0] + ',' + point[1] + ')');
              _a.label = 5;
            case 5:
              k++;
              return [3 /*break*/, 3];
            case 6:
              j++;
              return [3 /*break*/, 2];
            case 7:
              i++;
              return [3 /*break*/, 1];
            case 8:
              return [2 /*return*/, index];
          }
        });
      });
    },
    getLayer: function getLayer(id) {
      var element = document.getElementById(id + '_LayerCollections');
      var bound = element.getBoundingClientRect();
      return {
        Bottom: bound.bottom,
        Height: bound.height,
        Left: bound.left,
        Right: bound.right,
        Top: bound.top,
        Width: bound.width,
        X: bound['x'],
        Y: bound['y']
      };
    },
    getElement: function getElement(id) {
      var element = document.getElementById(id);
      var bound = element.getBoundingClientRect();
      return {
        Bottom: bound.bottom,
        Height: bound.height,
        Left: bound.left,
        Right: bound.right,
        Top: bound.top,
        Width: bound.width,
        X: bound['x'],
        Y: bound['y']
      };
    },
    getSvg: function getSvg(id) {
      var element = document.getElementById(id + '_svg');
      var bound = element.getBoundingClientRect();
      return {
        Bottom: bound.bottom,
        Height: bound.height,
        Left: bound.left,
        Right: bound.right,
        Top: bound.top,
        Width: bound.width,
        X: bound['x'],
        Y: bound['y']
      };
    },
    updateTileTranslatePoint: function updateTileTranslatePoint(tileTranslatePoint, translatePoint, areaRectX, areaRectY, areaRectWidth, areaRectHeight, marginLeft, marginTop, tileZoomLevel, labelProp, labelPropTemplate, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.tileTranslatePoint = {
          x: tileTranslatePoint.x,
          y: tileTranslatePoint.y
        };
        instance.translatePoint = {
          x: translatePoint.x,
          y: translatePoint.y
        };
        instance.areaRect = {
          x: areaRectX,
          y: areaRectY,
          width: areaRectWidth,
          height: areaRectHeight
        };
        instance.marginLeft = marginLeft;
        instance.marginTop = marginTop;
        instance.labelCollection = JSON.parse(labelProp);
        instance.dataLabelTemplateCollection = JSON.parse(labelPropTemplate);
        instance.tileZoomLevel = instance.options.factor = instance.scaleFactor = tileZoomLevel;
        if ((tileZoomLevel === instance.options.maxZoom || tileZoomLevel > 1 || tileZoomLevel === 1) && instance.previousId === "") {
          if (sf.base.Browser.isDevice) {
            instance.setToolbarButtonColor(instance.tileZoomLevel, id + "_Zooming_");
          }
          if (tileZoomLevel === instance.options.maxZoom) {
            if (document.getElementById(instance.id + '_Zooming_ToolBar_Zoom_Rect')) {
              document.getElementById(instance.id + '_Zooming_ToolBar_Zoom_Path').setAttribute('fill', instance.toolbarColor);
              document.getElementById(instance.id + '_Zooming_ToolBar_Zoom_Path').setAttribute('stroke', instance.toolbarColor);
              instance.isPan = false;
            }
          }
        }
        if (instance.isTileMap && instance.previousId.indexOf("_Reset_") > -1) {
          if (!instance.options.enablePanning) {
            if (document.getElementById(instance.id + '_Zooming_ToolBar_Pan_Rect')) {
              document.getElementById(instance.id + '_Zooming_ToolBar_Pan_Path').setAttribute('fill', instance.toolbarColor);
              document.getElementById(instance.id + '_Zooming_ToolBar_Pan_Path').setAttribute('stroke', instance.toolbarColor);
            }
          }
          instance.enableSelectionZoom = instance.enableSelectionZoom ? false : instance.enableSelectionZoom;
        }
        instance.isPan = instance.previousId.indexOf("_Reset_") > -1 && instance.options.enablePanning ? true : instance.isPan;
      }
    },
    updateTranslatePoint: function updateTranslatePoint(translatePoint, areaRectX, areaRectY, areaRectWidth, areaRectHeight, marginLeft, marginTop, zoomFactor, labelProp, labelPropTemplate, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.shapeTranslatePoint = translatePoint;
        instance.areaRect = {
          x: areaRectX,
          y: areaRectY,
          width: areaRectWidth,
          height: areaRectHeight
        };
        instance.marginLeft = marginLeft;
        instance.marginTop = marginTop;
        instance.options.factor = instance.scaleFactor = zoomFactor;
        instance.labelCollection = JSON.parse(labelProp);
        instance.dataLabelTemplateCollection = JSON.parse(labelPropTemplate);
      }
    },
    updateZoomSettings: function updateZoomSettings(id, zoomSettings) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.options.enableZoom = zoomSettings.enable;
        instance.options.zoomOnClick = zoomSettings.zoomOnClick;
        instance.options.doubleClickZoom = zoomSettings.doubleClickZoom;
        instance.options.enablePanning = zoomSettings.enablePanning;
        instance.options.enablePinchZooming = zoomSettings.pinchZooming;
        instance.options.enableSelectionZooming = zoomSettings.enableSelectionZooming;
        instance.options.enableMouseWheelZoom = zoomSettings.mouseWheelZoom;
      }
    },
    updateMarkerCollection: function updateMarkerCollection(id, collection) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.dataSource = JSON.parse(collection.markerDataSource);
      }
    },
    updateCollection: function updateCollection(id, collection) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.options.layerHighlightSettings = JSON.parse(collection.layerHighlightSettings);
        instance.options.markerHighlightSettings = JSON.parse(collection.markerHighlightSettings);
        instance.options.navigationHighlightSettings = JSON.parse(collection.navigationHighlightSettings);
        instance.options.polygonHighlightSettings = JSON.parse(collection.polygonHighlightSettings);
        instance.bubbleCollection = JSON.parse(collection.bubble);
        instance.labelCollection = JSON.parse(collection.dataLabel);
        instance.dataLabelTemplateCollection = JSON.parse(collection.dataLabelTemplate);
        instance.markerSettings = JSON.parse(collection.markerSettings);
        instance.geometryType = JSON.parse(collection.geometryType);
        instance.allowMarkerDragStartEvent = collection.allowMarkerDragStartEvent;
        instance.navigation = JSON.parse(collection.navigationLine);
        instance.polygon = JSON.parse(collection.polygon);
        instance.markerClusterCollection = JSON.parse(collection.markerCluster);
        instance.baseMapBounds = {
          latitudeMax: collection.latitudeMax,
          latitudeMin: collection.latitudeMin,
          longitudeMax: collection.longitudeMax,
          longitudeMin: collection.longitudeMin,
          minBounds: collection.minBounds,
          maxBounds: collection.maxBounds,
          availableSize: collection.availableSize,
          mapsAreaRect: collection.mapsAreaRect
        };
        instance.isTileMap = collection.isTileMap;
        instance.legendSettings = JSON.parse(collection.legendSettings);
        instance.legendDetails = collection.legendDetails != null ? JSON.parse(collection.legendDetails) : null;
        instance.legendFill = collection.legendFill != null ? JSON.parse(collection.legendFill) : null;
        instance.legendShapeCollection = collection.legendShapeCollection != null ? JSON.parse(collection.legendShapeCollection) : null;
        instance.urlTemplate = collection.urlTemplate;
        instance.key = collection.key;
        instance.dataSource = JSON.parse(collection.markerDataSource);
        instance.polygonDataSource = JSON.parse(collection.polygonDataSource);
        instance.toolbarSelection = collection.toolbarSelection;
        instance.toolbarColor = collection.toolbarColor;
        instance.mapsBorderWidth = collection.mapsBorder;
        instance.toolbarButtonOpacity = collection.toolbarButtonOpacity;
        instance.toolbarShapeOpacity = collection.toolbarShapeOpacity;
        instance.removeAllHighlight();
      }
    },
    updateLayerHighlight: function updateLayerHighlight(index, setting, isBorder, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (!isBorder) {
          instance.options.layerHighlightSettings[index].Fill = setting.fill;
          instance.options.layerHighlightSettings[index].Opacity = setting.opacity;
          instance.options.layerHighlightSettings[index].Enable = setting.enable;
        } else {
          instance.options.layerHighlightSettings[index].BorderColor = setting.borderColor;
          instance.options.layerHighlightSettings[index].BorderWidth = setting.borderWidth;
          instance.options.layerHighlightSettings[index].BorderOpacity = setting.borderOpacity;
        }
      }
    },
    updateMarkerHighlight: function updateMarkerHighlight(layerIndex, index, setting, isBorder, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (!isBorder) {
          instance.options.markerHighlightSettings[layerIndex][index].Fill = setting.fill;
          instance.options.markerHighlightSettings[layerIndex][index].Opacity = setting.opacity;
          instance.options.markerHighlightSettings[layerIndex][index].Enable = setting.enable;
        } else {
          instance.options.markerHighlightSettings[layerIndex][index].BorderColor = setting.borderColor;
          instance.options.markerHighlightSettings[layerIndex][index].BorderWidth = setting.borderWidth;
          instance.options.markerHighlightSettings[layerIndex][index].BorderOpacity = setting.borderOpacity;
        }
      }
    },
    updateBubbleHighlight: function updateBubbleHighlight(layerIndex, index, setting, isBorder, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (!isBorder) {
          instance.options.bubbleHighlightSettings[layerIndex][index].Fill = setting.fill;
          instance.options.bubbleHighlightSettings[layerIndex][index].Opacity = setting.opacity;
          instance.options.bubbleHighlightSettings[layerIndex][index].Enable = setting.enable;
        } else {
          instance.options.bubbleHighlightSettings[layerIndex][index].BorderColor = setting.borderColor;
          instance.options.bubbleHighlightSettings[layerIndex][index].BorderWidth = setting.borderWidth;
          instance.options.bubbleHighlightSettings[layerIndex][index].BorderOpacity = setting.borderOpacity;
        }
      }
    },
    updateTooltipDisplayMode: function updateTooltipDisplayMode(id, displayMode) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.options.tooltipDisplayMode = displayMode;
      }
    },
    updateNavigationHighlight: function updateNavigationHighlight(layerIndex, index, setting, isBorder, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (!isBorder) {
          instance.options.navigationHighlightSettings[layerIndex][index].Fill = setting.fill;
          instance.options.navigationHighlightSettings[layerIndex][index].Opacity = setting.opacity;
          instance.options.navigationHighlightSettings[layerIndex][index].Enable = setting.enable;
        } else {
          instance.options.navigationHighlightSettings[layerIndex][index].BorderColor = setting.borderColor;
          instance.options.navigationHighlightSettings[layerIndex][index].BorderWidth = setting.borderWidth;
          instance.options.navigationHighlightSettings[layerIndex][index].BorderOpacity = setting.borderOpacity;
        }
      }
    },
    updatePolygonHighlight: function updatePolygonHighlight(layerIndex, setting, isBorder, id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        if (!isBorder) {
          instance.options.polygonHighlightSettings[layerIndex].Fill = setting.fill;
          instance.options.polygonHighlightSettings[layerIndex].Opacity = setting.opacity;
          instance.options.polygonHighlightSettings[layerIndex].Enable = setting.enable;
        } else {
          instance.options.polygonHighlightSettings[layerIndex].BorderColor = setting.borderColor;
          instance.options.polygonHighlightSettings[layerIndex].BorderWidth = setting.borderWidth;
          instance.options.polygonHighlightSettings[layerIndex].BorderOpacity = setting.borderOpacity;
        }
      }
    },
    exportToImage: function exportToImage(type, fileName, allowDownload, id, theme) {
      return __awaiter(this, void 0, void 0, function () {
        var returnValue, instance;
        var _this = this;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              instance = window.sfBlazor.getCompInstance(id);
              if (!(instance && instance.element)) return [3 /*break*/, 2];
              return [4 /*yield*/, instance.imageExport(type, fileName, allowDownload, theme)];
            case 1:
              returnValue = _a.sent();
              _a.label = 2;
            case 2:
              if (!(returnValue instanceof Promise)) return [3 /*break*/, 4];
              return [4 /*yield*/, returnValue.then(function (data) {
                return __awaiter(_this, void 0, void 0, function () {
                  return __generator(this, function (_a) {
                    return [2 /*return*/, data];
                  });
                });
              })];
            case 3:
              _a.sent();
              return [3 /*break*/, 5];
            case 4:
              return [2 /*return*/, returnValue];
            case 5:
              return [2 /*return*/];
          }
        });
      });
    },
    getLegendRect: function getLegendRect(id, top) {
      var legendId = document.getElementById(id);
      var legendRect = legendId.getBoundingClientRect();
      var mapId = id.split('_Legend_')[0];
      var svgId = document.getElementById(mapId);
      var svgRect = svgId.getBoundingClientRect();
      return {
        x: legendRect.left - svgRect.left,
        y: legendRect.top - svgRect.top,
        width: legendRect.width,
        height: legendRect.height
      };
    },
    markerAnimation: function markerAnimation(id, marker) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.markerAnimation(id, marker);
      }
    },
    layerAnimation: function layerAnimation(id, point, scale, currentPoint, currentScale, duration) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        var layerGroup = document.getElementById(id + '_LayerIndex_0');
        for (var i = 0; i < layerGroup.children.length; i++) {
          if (layerGroup.children[i].getAttribute('transform') !== null) {
            this.zoomAnimation(layerGroup.children[i], 0, duration, currentPoint, currentScale, point, scale, instance);
          }
        }
      }
    },
    slope: function slope(previousLocation, point) {
      if (previousLocation.x === point.x) {
        return null;
      }
      return (point.y - previousLocation.y) / (point.x - previousLocation.x);
    },
    interception: function interception(point, slopeValue) {
      if (slopeValue === null) {
        return point.x;
      }
      return point.y - slopeValue * point.x;
    },
    zoomAnimation: function zoomAnimation(element, delay, duration, currentPoint, scale, previousLocation, preScale, elementInstance) {
      var delta = 0;
      var point = {
        x: currentPoint.x,
        y: currentPoint.y
      };
      var diffScale = scale - preScale;
      var currentLocation = {
        x: 0,
        y: 0
      };
      var currentScale = 1;
      if (scale === preScale) {
        element.setAttribute('transform', 'scale( ' + scale + ' ) translate( ' + point.x + ' ' + point.y + ' )');
        return;
      }
      var slopeFactor = this.slope(previousLocation, point);
      var slopeIntersection = this.interception(previousLocation, slopeFactor);
      var horizontalDifference = point.x - previousLocation.x;
      var verticalDifference = point.y - previousLocation.y;
      element.style.removeProperty('visibility');
      this.animate(element, duration, function (args) {
        if (args.timeStamp > args.delay) {
          delta = (args.timeStamp - args.delay) / args.duration;
          currentScale = preScale + delta * diffScale;
          currentLocation.x = previousLocation.x + delta * horizontalDifference / (currentScale / scale);
          if (sf.base.isNullOrUndefined(slopeFactor)) {
            currentLocation.y = previousLocation.y + delta * verticalDifference;
          } else {
            currentLocation.y = slopeFactor * currentLocation.x + slopeIntersection;
          }
          elementInstance.applyTransform(currentScale, currentLocation);
        }
      }, function (model) {
        elementInstance.applyTransform(scale, point);
        this.markerCluster(elementInstance.id);
        if (!sf.base.isNullOrUndefined(this.dotNetRef)) {
          this.dotNetRef.invokeMethodAsync('TriggerAnimation', element);
        }
      });
    },
    bubbleAnimation: function bubbleAnimation(id, bubble) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.bubbleAnimation(id, bubble);
      }
    },
    animate: function animate(element, duration, process, end) {
      var proxy = this;
      var start = null;
      var clearAnimation;
      var markerStyle = 'visibility:visible';
      var startAnimation = function startAnimation(timeStamp) {
        if (!start) {
          start = timeStamp;
        }
        var progress = timeStamp - start;
        if (progress < duration) {
          process.call(proxy, {
            element: element,
            delay: 0,
            timeStamp: progress,
            duration: duration
          });
          window.requestAnimationFrame(startAnimation);
        } else {
          window.cancelAnimationFrame(clearAnimation);
          end.call(proxy, {
            element: element
          });
          element.setAttribute('style', markerStyle);
        }
      };
      clearAnimation = window.requestAnimationFrame(startAnimation);
    },
    getToolbarAlign: function getToolbarAlign(id, data) {
      var verticalAlignment = data.verticalAlignment;
      var horizontalAlignment = data.horizontalAlignment;
      var zoomToolbar = document.getElementById(id + '_Zooming_KitCollection');
      var toolBarSize;
      var toolBarSizeParent;
      if (!sf.base.isNullOrUndefined(zoomToolbar)) {
        toolBarSize = zoomToolbar.getBoundingClientRect();
      }
      var zoomToolbarParent = document.getElementById(id + '_ToolBar');
      if (!sf.base.isNullOrUndefined(zoomToolbarParent)) {
        toolBarSizeParent = zoomToolbarParent.getBoundingClientRect();
      }
      var x = 0;
      var y = 0;
      switch (verticalAlignment) {
        case 0:
          y = data.y;
          break;
        case 1:
          y = data.height / 2 - toolBarSize.height / 2 + data.mapsBorder;
          break;
        case 2:
          y = data.height - toolBarSize.height + data.mapsBorder - 2 * data.buttonPadding;
          break;
      }
      switch (horizontalAlignment) {
        case 0:
          x = data.x;
          break;
        case 1:
          x = data.width / 2 - (!sf.base.isNullOrUndefined(toolBarSize) ? toolBarSize.width === 0 ? toolBarSizeParent.width : toolBarSize.width : 0) / 2 + data.mapsBorder;
          break;
        case 2:
          x = data.width - (!sf.base.isNullOrUndefined(toolBarSize) ? toolBarSize.width === 0 ? toolBarSizeParent.width : toolBarSize.width : 0) - 2 * data.buttonPadding + data.mapsBorder;
          break;
      }
      var parentToolbar = document.getElementById(id + '_ToolBar');
      parentToolbar.style.left = x + 'px';
      parentToolbar.style.top = y + 'px';
      parentToolbar.style.visibility = 'visible';
      var color = data.color;
      var instance = window.sfBlazor.getCompInstance(id);
      if (instance && instance.element) {
        instance.createToolbarStyle(color, parentToolbar);
      }
    },
    getTemplate: function getTemplate(data, template, top, left, id, index, templateCheck, parentId) {
      var dataValue = data[0];
      var properties = Object.keys(dataValue);
      var templateHtml = template;
      for (var i = 0; i < properties.length; i++) {
        if (properties[i].toLowerCase() !== 'latitude' && properties[i].toLowerCase() !== 'longitude') {
          templateHtml = templateHtml.replace(new RegExp('{{:' + properties[i] + '}}', 'g'), dataValue[properties[i].toString()]);
        }
      }
      var markerTemplate = document.createElementNS('http://www.w3.org/2000/svg', 'div');
      markerTemplate.setAttribute('id', id);
      markerTemplate.style.position = 'absolute';
      markerTemplate.style.transform = 'translate(-50 %, -50 %)';
      markerTemplate.style.left = left.toString();
      markerTemplate.style.top = top.toString();
      markerTemplate.innerHTML = templateHtml.toString();
      var secondTemplateGroup = document.getElementById(parentId + '_LayerIndex_0_Markers_Template_Group');
      secondTemplateGroup.appendChild(markerTemplate);
      var markerTemplateGroup = document.getElementById(parentId + '_Secondary_Element');
      markerTemplateGroup.appendChild(secondTemplateGroup);
      var templateId = document.getElementById(parentId);
      templateId.appendChild(markerTemplateGroup);
      return templateHtml;
    },
    dispose: function dispose(id) {
      var instance = window.sfBlazor.getCompInstance(id);
      if (!sf.base.isNullOrUndefined(instance)) {
        instance.destroy();
      }
    }
  };
  return Maps;
}();

/***/ })

}]);(async()=>{await import(`${document.baseURI}_content/Syncfusion.Blazor/scripts/syncfusion-blazor-base.min.js?v=19.3.1`).then(()=>{sfBlazor.loadDependencies('sfmaps');})})();